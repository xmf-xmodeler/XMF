parserImport XOCL;

/******************************************************************************
 *                                                                            *
 *                                Clause Blocks                               *
 *                               ---------------                              *
 *                                                                            *
 *  When a clause is translated into a clause-normal-form it becomes a        *
 *  disjunctive sequence of(conjunctive sequence of(Recognizer)). Each element*
 *  of the outer sequence is an alternative that can be tried independently   *
 *  of the other alternatives. Each alternative is compiled to produce a      *
 *  clause block and the collection of clause blocks form the parse table for *
 *  a grammar. A clause block defines the number of local variables required  *
 *  to perform the recognizers in sequence and defines the basic token types  *
 *  that predict the block. In essence, a grammar is compiled to a collection *
 *  of clause blocks that are then run by a parsing machine.                  *
 *                                                                            *
 ******************************************************************************/ 

import Parser;
import BNF;

context BNF

  @Class Block extends Recognizer
  
    // The parsing machine uses stack frames to contain the
    // local variables used in a clause. The number of locals
    // required by a block is defined by locals...
  
    @Attribute locals         : Integer         (?,!)     end
    
    // The arg map is used to associate names with local 
    // positions at run-time...
    
    @Attribute argMap         : Seq(Integer)    (?,!)     end
    
    // The instructions of a block are the basic recognizers
    // that are performed by the parsing machine...
    
    @Attribute instrs         : Seq(Recognizer) (?,!)     end
    
    // The tokenizer produces tokens of the following types and
    // the instructions in the block are predicted by a token
    // of the appropriate type when the field is set...
    
    @Attribute namePredicts   : Boolean         (?,!)     end
    @Attribute intPredicts    : Boolean         (?,!)     end
    @Attribute floatPredicts  : Boolean         (?,!)     end
    @Attribute strPredicts    : Boolean         (?,!)     end
    @Attribute charPredicts   : Boolean         (?,!)     end
    @Attribute termPredicts   : Boolean         (?,!)     end
    @Attribute EOFPredicts    : Boolean         (?,!)     end
    
    // A sequence of token types for user defined tokens...
    
    @Attribute userPredicts   : Seq(Integer)    (?,!,+,-) end
    
    // A cache of the predictions...
    
    @Attribute predicts       : Set(String)     (?,!,+,-) end
    
    @Constructor(locals,instrs) ! end
    
    @Operation calcArgMap(args,locals)
    
      // The arg map records the position of the locals
      // as supplied as arguments to the block...
      
      self.argMap := args->collect(a | locals->indexOf(a))
    end
    
    @Operation calculateSets(grammar,clause):Boolean
    
      // Calculate the nullable, and first sets for this block...
      
      let changed = false
      in changed := self.calculateNullable(grammar,clause);
         @Count i from 0 to instrs->size do
           changed := changed or self.calculateFirst(grammar,clause,i);
           changed := changed or self.checkCall(grammar,clause,i)
         end;
         changed
      end
    end
           
    @Operation calculateFirst(grammar,clause,i):Boolean
    
      // C ::= G H I X
      // If G H I are all nullable then add the firsts of X
      // to C...
      
      if instrs->take(i)->forAll(b | b.nullable(grammar))
      then 
        let first = instrs->at(i).first(grammar)
        in if not first->forAll(n | clause.first()->includes(n))
           then 
             clause.setFirst(first + clause.first());
             true
           else false
           end
        end
      else false
      end
    end
                   
    @Operation calculateNullable(grammar,clause):Boolean
    
      // The owning clause is nullable if all the block instructions
      // can succeed without consuming any input...
      
      if instrs->forAll(p | p.nullable(grammar))
      then 
        if not clause.nullable() 
        then 
          clause.setNullable(true);
          true
        else false
        end
      else false
      end
    end     
    
    @Operation calculateFollow(grammar,clause,i):Boolean
    
      // Set the follow terminals for the ith instruction. The
      // follow non-terminals are those that occur after the
      // instruction has succeeded...
      
      if instrs->drop(i + 1)->forAll(b | b.nullable(grammar))
      then 
        let follow = instrs->at(i).follow(grammar)
        in if not clause.follow()->forAll(n | follow->includes(n))
           then 
             instrs->at(i).setFollow(grammar,follow + clause.follow());
             true
           else false
           end
        end
      else false
      end
    end
    
    @Operation checkCall(grammar,clause,i):Boolean   
    
      // Given C ::= X Y Call(Z) G H I
      // If G H I is nullable then add in follow(C) to follow(Z).
      // If G H is nullable then add in first(I) to follow(Z)
      
      let changed = false
      in if instrs->at(i).isKindOf(Call)
         then 
           changed := self.calculateFollow(grammar,clause,i);
           let rest = instrs->drop(i+1)
           in @Count j from 0 to rest->size do
                if rest->take(j-1)->forAll(b | b.nullable(grammar))
                then 
                  let follow = instrs->at(i).follow(grammar);
                      first = rest->at(j).first(grammar)
                  in if not first->forAll(n | follow->includes(n))
                     then changed := true
                     end;
                     instrs->at(i).setFollow(grammar,follow + first)
                  end
                end
              end
            end
          end;
          changed
       end
     end
     
     @Operation compileLocals(args,locals,grammar)
     
       // Various instructions are transformed into a more efficient
       // form...
       
       let locals = (locals + instrs->iterate(i L = Set{} | L + i.FV()))->asSeq.qsort(@Operation(x,y) x < y end)
       in self.locals := locals->size;
          self.calcArgMap(args,locals);
          self.instrs := instrs->collect(i |
            @CaseObj i of
              Bind[name] do
                // Use the locals index to update the stack frame...
                SetLoc(locals->indexOf(name))
              end
              Cons[ ] do
                // A Cons() instruction uses pseudo locals $head and
                // $tail. These are referenced by index in the stack 
                // frame...
                i.setHeadIndex(locals->indexOf("$head"));
                i.setTailIndex(locals->indexOf("$tail"));
                i
              end
              Call[name,args] do
                // Check that the arguments to a call are all bound. Note
                // that call args *must* be variables. If they are OK
                // then replace the names with the indices...
                let unbound = args->select(a | not locals->includes(a))
                in if unbound->isEmpty
                   then Call(name,args,args->collect(a | locals.indexOf(a)))
                   else self.ferror("Unbound arg(s) 箕誉轭汜祆莹箕誉渝覃躅怙躅洮钺礤狎珞孱孱孱屐箦孱孱孱老疱蜥糸镱漯蜷铘ī骘蝽狒篝滹豸箕誉湖ア渝覃轭篝蝮┗骘蝽狒篝滹豸痱邃殂艉┗殒钺礤序邃殂趔翳孱骘蝽狒篝滹豸⑽犴瀣孱浠殒骒镝粜蝈溟泗翳孱骘蝽狒篝滹豸⑵祜狒孱浠殒轭粜蝈溟泗翳孱骘蝽狒篝滹豸⑸铘孱浠殒篝蛐蝈溟泗翳孱骘蝽狒篝滹豸⒂趄孱浠殒汨狎序邃殂趔翳孱骘蝽狒篝滹豸⒚栳颥孱浠殒翦蝽序邃殂趔翳孱骘蝽狒篝滹豸⒃弪憩孱浠殒畔菩蝈溟泗翳孱骘蝽狒篝滹豸⑴掀孱浠骘蝽狒篝滹豸箕誉ア渝覃痱邃殂趔踞笥羼孱老疱蜥糸镱羼踽歙忪镢氅郝镲戾犷阻孱珧犴磲轶泔眇殪邃麇礤蜱翳疳蝈铘沆狨箦轭麸翳汨殪犷蝈泔眇殪瀹深磲铢汜箦翳轶蝈篚祠轭忪镢塍翳狒狎翳筢礤狍翳矬轭翳疳蝈铘澡弪彐矧翳忪镢塍汜忮箬狎邃澡箬狎轭汜镱禊忮腩秣徭翦颡泔瘗轭犷泔眇殪狒轱町澡轶镳弪狒轱轶躞邃麸汨邈骘羼蹰鲠戾钽瀹祜汜祗忪镢氘祜汜祗ī犷ㄡ蜱歪忪镢氘狎缤狃ī┉炬矧领歙疳轵疳轵踞舁癌疳轵踞舁暴犷轭篝蝮倔辁忪镢氘轭篝蝮ī倔辁犷钺礤序邃殂趔忪镢氘钺礤序邃殂趔ī犷轭粜蝈溟泗忪镢氘轭粜蝈溟泗蟥犷骒镝粜蝈溟泗忪镢氘骒镝粜蝈溟泗蟥犷篝蛐蝈溟泗忪镢氘篝蛐蝈溟泗蟥犷汨狎序邃殂趔忪镢氘汨狎序邃殂趔ī犷翦蝽序邃殂趔忪镢氘翦蝽序邃殂趔ī犷畔菩蝈溟泗忪镢氘畔菩蝈溟泗蟥犷痱邃殂趔忪镢氘痱邃殂趔ī孱老疱蜥糸镱屮疱泗邃ī河弭ㄓ趄轭绌义趱蝾翳簌篝屙钺礤镦翳屮疱泗邃麸脲豉疱螽痱邃殂趔殒钺礤序邃殂趔翳孱渝酐⒙蹰祠轭ㄎ犴濠屐箦渝酐孱殒骒镝粜蝈溟泗翳孱渝酐⒙蹰祠轭ㄆ祜狒屐箦渝酐孱殒轭粜蝈溟泗翳孱渝酐⒙蹰祠轭ㄉ铘屐箦渝酐孱殒篝蛐蝈溟泗翳孱渝酐⒙蹰祠轭ㄓ趄屐箦渝酐孱殒汨狎序邃殂趔翳孱渝酐⒙蹰祠轭描狎屐箦渝酐孱殒翦蝽序邃殂趔翳孱渝酐⒙蹰祠轭ㄔ弪愆屐箦渝酐孱殒畔菩蝈溟泗翳孱渝酐⒙蹰祠轭ㄅ掀屐箦渝酐孱孱老疱蜥糸镱骈蝮趔ㄧ蜥眄狎轭篝蝮冕煦蹯狒弩翳箦镦骈蝮簌礅镬螽殒轭篝蝮鹃笈眇豉翳孱渝酐屐箦殒轭篝蝮捐遽洚铛祆徕戾ㄧ蜥眄狎翳孱箦戽骈蝮趔ㄧ蜥眄狎轭篝蝮爵衢飑轭篝蝮捐遽洚骈蝮舁珧犴磲颟屐箦轭篝蝮捐遽洚骈蝮舁珧犴磲颟孱孱孱老疱蜥糸镱轶阵弪序邃殂趔翦蝽轭犰河趄轭绌郝镲戾犷翦蝽轭犰镦翳骘蝽迈殪糸瞑钺礤豉疱轶溴骈铄怡翳躞弪翦蝽轭犰栳笮蝈骈á迈殪糸瞑孱老疱蜥糸镱痱邃殂舁沆狨箦珧犴磲颟冕煦蹯狒弩翳箦镦痱邃殂翦麸脲豉疱骘翳忪镢氘澡痱邃殂糸镱狎箦轭翦蝽镦翳痱邃殂糸镱箪雉轭翳忪镢氘戾箦戽骈蝮趔ㄧ蜥眄狎轭篝蝮轭殒轭篝蝮炬矧领歙楫铛祆徕戾ㄧ蜥眄狎┅翳孱戾沆狨箦骘祆秣ī轭箦戽痱邃殂舁ㄐ譬鹃钽祯溟铉á迈殪糸瞑畔譬┅孱屐箦箦戽痱邃殂舁些孱孱孱老疱蜥糸镱痱邃殂舁翦蝽轭犰蠛渝舁郁蜷铉┅渝趔翳狃痱镳蜷狒痱邃殂糸镱篝狒镦翳忪镢氘榔矧翦蝽轭犰轭翦蝽轭犰滹烂狍翦蝽轭犰镦⒙蹰祠轭ㄅ掀滹箦戽箦襞掀序邃殂趔趄蹂孱⒙蹰祠轭ㄆ祜狒滹箦戽箦羝祜狒序邃殂趔趄蹂孱⒙蹰祠轭ㄉ铘滹箦戽箦羯铘序邃殂趔趄蹂孱⒙蹰祠轭ㄎ犴濠滹箦戽箦粑犴逍蝈溟泗蟥趄蹂孱⒙蹰祠轭ㄓ趄滹箦戽箦粲趄序邃殂趔趄蹂孱⒙蹰祠轭描狎滹箦戽箦裘栳蛐蝈溟泗蟥趄蹂孱⒙蹰祠轭ㄌ轭濠滹箦戽箦裘栳蛐蝈溟泗蟥趄蹂孱⒙蹰祠轭ㄔ弪愆滹箦戽箦粼弪硇蝈溟泗蟥趄蹂孱屐箦殒箦戽轶阵弪序邃殂趔翦蝽轭犰翳孱箦戽徜湓镎箦蛐蝈溟泗蟥箦戽躞弪序邃殂趔赠疱翦蝽轭犰┅屐箦箦戽徜湓镄蝈溟泗蟥翦蝽轭犰孱孱孱孱老疱蜥糸镱躞弪序邃殂趔赠疱翦蝽轭犰河趄轭绌荷铘彗弪清翳轭翦珏豉疱疳螋镦翳躞弪溴骈铄迈殪糸瞑钺礤豉疱翦蝽轭犰戾疳轵翦蝽轭犰箴扉袈á艾癌翳孱狎绮疳轵踞舁暴翳孱豉疱狎绮篚庥趄轭绋艾狎绮倔辁暴轭豉疱狍深舁孱孱孱