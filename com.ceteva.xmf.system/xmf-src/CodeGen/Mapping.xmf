parserImport XOCL;

/******************************************************************************
 *                                                                            *
 *                   Generation of Code Elements from Strings                 *
 *                   ---------------------------------------                  *
 *                                                                            *
 *    The code template is supplied as a string. The template must be         *
 *    translated into code that generates the text. The code-generating text  *
 *    must faithfully reproduce the output generated by the dropping and      *
 *    lifting. This is done in a two stage process. The first stage is to     *
 *    produce code elements from the string. The second stage is to produce   *
 *    XOCL code from the code elements. The first stage is performed by a     *
 *    mapping. The mapping steps through the string and follows the nesting   *
 *    structure of the lifting and dropping creating appropriate code elements*
 *    via a stack.                                                            *
 *                                                                            *
 ******************************************************************************/


import CodeGen;

context CodeGen

  @Class Mapping
  
    // The input string...
  
    @Attribute chars        : String end
    
    // The stack of code elements being generated...
    
    @Attribute stack        : Stack = Stack() end
    
    // The current position in the string...
    
    @Attribute index        : Integer end
    
    // The token indicating a start lift...
    
    @Attribute startLift    : String end
    
    // The token indicating the end of a lift...
    
    @Attribute endLift      : String end
    
    // The token indicating the start of a drop...
    
    @Attribute startDrop    : String end
    
    // The token indicating the end of a drop...
    
    @Attribute endDrop      : String end
    
    // Ignore these...
    
    @Attribute startExtract : String = "** NOT DEFINED **" end
    @Attribute endExtract   : String = "** NOT DEFINED **" end
    
    @Constructor(chars,startLift,endLift,startDrop,endDrop) end
    
    @Constructor(chars,startLift,endLift,startDrop,endDrop,startExtract,endExtract) end
    
    @Constructor(stack) ! end
    
    @Operation consumeStartLift()
    
      // Consume the start-lift token...
      
      self.index := index + startLift->size;
      @While self.isSpace() and not self.EOI() do
        self.index := index + 1
      end
    end
    
    @Operation consumeStartDrop()
    
      // Consume the start-drop token...
      
      self.index := index + startDrop->size
    end
    
    @Operation consumeStartExtract()
    
      // Consume the start-extract token...
      
      self.index := index + startExtract->size
    end
    
    @Operation consumeEndLift()
    
      // Consume the end-lift token...
      
      self.index := index + endLift->size
    end
    
    @Operation consumeEndDrop()
    
      // Consume the end-drop token...
      
      self.index := index + endDrop->size
    end
    
    @Operation consumeEndExtract()
    
      // Consume the end-extract token...
      
      self.index := index + endExtract->size
    end
    
    @Operation EOI():Boolean
    
      // The end-of-input has been reached when all
      // the chars have been consumed...
      
      index = chars->size
    end
    
    @Operation hasPrefix(p:String):Boolean
    
      // Returns true when the current input starts 
      // with the token p...
      
      let hasPrefix = true;
          i = index
      in @While hasPrefix and not i = chars->size and (i - index) < p->size do
           hasPrefix := chars->at(i) = p->at(i - index);
           i := i + 1
         end;
         hasPrefix
      end
    end
    
    @Operation isEndLift():Boolean
    
      // Returns true when the next token is end-lift...
      
      self.hasPrefix(endLift)
    end
    
    @Operation isEndDrop():Boolean
    
      // Returns true when the next token is end-drop...
      
      self.hasPrefix(endDrop)
    end 
    
    @Operation isEndExtract():Boolean
    
      // Returns true when the next token is end-extract...
      
      self.hasPrefix(endExtract)
    end
    
    @Operation isNewLine():Boolean 
    
      // Returns true when the next char is new-line..
      
      chars->at(index) = "\n"->at(0) or chars->at(index) = "\r"->at(0)
    end
    
    @Operation isSpace():Boolean
    
      // Returns true when the next char is a space
      // or is tab...
      
      chars->at(index) = " "->at(0) or
      chars->at(index) = "\t" 
    end
    
    @Operation isStartLift():Boolean
    
      // Returns true when the next token is start-lift...
      
      self.hasPrefix(startLift)
    end
    
    @Operation isStartDrop():Boolean
    
      // Returns true when the next token is start-drop...
      
      self.hasPrefix(startDrop)
    end
    
    @Operation isStartExtract():Boolean
    
      // Returns true when the next token is start-extract...
      
      self.hasPrefix(startExtract)
    end
    
    @Operation isWhiteSpace():Boolean
    
      // Returns true when the next char is white-space...
      
      self.isSpace() or
      chars->at(index) = "\n"->at(0) or
      chars->at(index) = "\r"->at(0)
    end
    
    @Operation liftIndent():Integer
    
      // When a start-lift is encountered, we try to work
      // out the current tabbing indent. This operation
      // calculates the number of spaces that follow the
      // start-lift after a new-line...
      
      let index = index + startLift->size;
          indent = 0;
          found = false
      in @While not found do
           @CaseInt[256] chars->at(index) of
             " "->at(0),"\t"->at(0) do
               index := index + 1;
               indent := indent + 1
             end
             "\n"->at(0),"\r"->at(0) do
               index := index + 1;
               indent := 0
             end
             else found := true
           end 
         end;
         indent+1
      end
    end 
    
    @Operation processDrop(margin,indent0,indent)
    
      // A start-drop has been encountered. All of the text
      // following the start-drop up to the corresponding
      // end-drop will be consumed and contained within a
      // Drop code-element. This is done by pushing all the
      // elements onto the stack and then creating a Drop
      // contaiing the elements when the end-drop is found...
      
      // Get rid of the start-drop...
      
      self.consumeStartDrop();
      
      // Pushes an empty stack of code-elements...
      
      self.start();
      
      // Create code elements until the corresponding
      // end-drop is found...
      
      @While not self.EOI() and not self.isEndDrop() do
      
        // Newlines are retained...
        
        if self.isNewLine()
        then indent := self.reduceNewLine(margin)
        elseif self.isStartExtract()
        then
          let textPos = (indent - indent0) + margin
          in 
             // Create a literal from any text that has
             // been encountered...
             
             self.reduceLit(); 
             
             // Process the extract-block...
             
             self.pushElement(self.processExtract(textPos+self.liftIndent(),textPos));
             
             // Push a new buffer ready for the
             // next literal...
             
             self.restart()
          end
          
        elseif self.isStartLift()
        then
        
          // Start a nested-lift...
        
          let textPos = (indent - indent0) + margin
          in 
             
             // Process the recently read literal chars...
             
             self.reduceLit(); 
             
             // Push the lift-block...
             
             self.pushElement(self.processLift(textPos+self.liftIndent(),textPos));
             
             // Push a new buffer ready for the 
             // next literal...
             
             self.restart()
          end
          
        // Otherwise add the current character
        // to the buffer at the head of the stack...
        
        else self.pushChar()
        end
      end;
      
      // We are now expecting the end-drop token...
      
      if self.EOI()
      then self.error("Expecting " + endDrop + " but found EOI.")
      else 
      
        // Consume the token...
        
        self.consumeEndDrop();
        
        // Consume any literal chars that have
        // been pushed...
        
        self.reduceLit();
        
        // Create the Drop...
        
        self.reduceDrop()
      end
    end
    
    @Operation processExtract(margin,indent0,indent)
    
      // An extract should not have any nested components 
      // just consume the characters and push an
      // extract...
      
      self.consumeStartExtract();
      
      // Push an empty stack of code elements...
      
      self.start();
      @While not self.EOI() and not self.isEndExtract()
      do
        self.pushChar()
      end;
      if self.EOI()
      then self.error("Expecting " + endExtract + " but found EOI.")
      else
        self.consumeEndExtract();
        self.reduceExtract()
      end
    end
    
    @Operation processLift(margin,indent)
    
      // A start-lift has been encountered. The intermediate
      // components are consumed and a Lift is created and
      // returned...
      
      // Consume the token...
      
      self.consumeStartLift();
      
      // Push an empty stack of code elements...
      
      self.start();
      
      // Until the corresponding end-lift token is
      // found, push the elements...
      
      @While not self.EOI() and not self.isEndLift() do
      
        if self.isNewLine()
        then indent := self.reduceNewLine(margin)
        elseif self.isStartExtract()
        then
          self.reduceLit(); 
          self.pushElement(self.processExtract(margin,indent,indent));
          self.restart()
        elseif self.isStartDrop()
        then 
          self.reduceLit();
          self.pushElement(self.processDrop(margin,indent,indent));
          self.restart()
        else self.pushChar()
        end
      end;
      if self.EOI()
      then self.error("Expecting " + endLift + " but found EOI.")
      else 
        self.consumeEndLift();
        self.reduceLit();
        self.reduceLift(margin)
      end
    end
    
    @Operation pushChar()
    
      // Elements are added to the top-stack. Generally
      // the head element is a buffer. The next literal
      // char is added to the top-buffer...
      
      let elements = stack.top() then
          b = elements.top()
      in b.add(chars->at(index));
         self.index := index + 1
      end
    end
    
    @Operation pushElement(element)
    
      // Add an element to the top-stack...
      
      let elements = stack.top()
      in elements.push(element)
      end
    end
    
    @Operation reduceDrop()
    
      // An end-drop has been consumed. The top-stack
      // contains the elements to be dropped...
      
      let elements = stack.pop().asSeq()
      in Drop(elements)
      end
    end
    
    @Operation reduceExtract()
    
      // An end-extract has been consumed. The top-stack
      // contains the elements to be extracted...
      
      let elements = stack.pop() then
          b = elements.pop() then
          str = b.toString()
      in 
        Extract(str)
      end
    end
          
    @Operation reduceLift(margin)
    
      // An end-lift has been encountered. The top-stack
      // contains the elements to be lifted...
      
      let elements = stack.pop().asSeq()
      in Lift(margin,elements)
      end
    end
          
    @Operation reduceLit()
    
      // The literal being constructed at the head of the
      // top-stack has terminated. The buffer is replaced
      // by a literal...
      
      let elements = stack.top() then
          b = elements.pop() then
          str = b.toString()
      in elements.push(Literal(str))
      end
    end
    
    @Operation reduceNewLine(margin)
    
      // When new-lines are encountered in the template
      // they are retained in the code-element so that
      // indentation can be manipulated...
      
      self.reduceLit();
      self.index := index + 1;
      let whiteSpace = self.skipWhiteSpace()
      in stack.top().push(NewLine(margin,whiteSpace));
         self.restart();
         whiteSpace
      end
    end
    
    @Operation restart()
    
      // Create a new empty literal buffer in a
      // sequence of existing code-elements...
      
      let elements = stack.top()
      in elements.push(Buffer(10,true))
      end
    end
    
    @Operation skipWhiteSpace()
    
      // Ignore white-space...
      
      let chars = 0
      in @While not self.EOI() and self.isWhiteSpace() do
           self.index := index + 1;
           chars := chars + 1
         end;
         chars
      end
    end
    
    @Operation start()
    
      // Start a completely new sequence of code-elements...
      
      let elements = Stack()
      in elements.push(Buffer(10,true));
         stack.push(elements)
      end
    end
    
  
  end