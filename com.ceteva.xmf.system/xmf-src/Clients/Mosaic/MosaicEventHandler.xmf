parserImport XOCL;

import Clients;
import Mosaic;

context Mosaic

  @Class MosaicEventHandler extends EventHandler

    @Operation dispatchEvent(message,parameters) 
      @Case message.name of
        "shutdownRequest" do self.shutdown()                  end
        "shutDownAndSave" do self.shutDownAndSave(parameters) end
        "consoleDot"      do self.consoleDot(parameters)      end
        "nameLookup"      do self.nameLookup(parameters)      end
        "send"            do self.sendEvent(parameters)       end
      end
    end
    
    @Operation sendEvent(parameters)
      self.debug("send",parameters);
      let target = parameters.at(0);
          name = parameters.at(1);
          args = parameters.at(2).asSeq()
      in if xmf.handles().hasKey(target) 
         then 
           let element = xmf.handles().get(target)
           in element.send(name,args)
           end
         else xmf.message("Cannot find target for handle: " + target)
         end
      end
    end
    
    @Operation shutdown()
      self.debug("shutdown",Seq{});
      if xmf.question("Are you sure you want to quit?")
      then 
        if xmf.saveImageAndInflater() = true
        then self.owner().commandInterpreter().shutdown()
        end
      end
    end
    
    @Operation shutDownAndSave(parameters)
      self.debug("shutDownAndSave",parameters);
      let imagePath = parameters.at(0);
          inflationPath = parameters.at(1);
          ok = true
      in if imagePath.fileExists()
         then ok := xmf.question("Overwrite " + imagePath)
         end;
         if ok and inflationPath.fileExists()
         then ok := xmf.question("Overwrite " + inflationPath)
         end;
         if ok
         then 
           self.owner().commandInterpreter().saveInflater(inflationPath);
           if xmf.saveImage(imagePath)
           then self.owner().commandInterpreter().shutdown()
           else self.owner().commandInterpreter().inflate(inflationPath)
           end
         else self.owner().commandInterpreter().shutdown()
         end
      end
    end
    
    @Operation consoleDot(parameters)
      self.debug("consoleDot",parameters);
      let text = parameters.at(0) then
          type = ExpressionGrammar.parse(text,"exp")
      in if type = Null
         then self.owner().commandInterpreter().consoleDot(Seq{})
         else 
           @TypeCase(type)
              Class do
                let atts = type.allAttributes()->asSeq->collect(a | Seq{"field",a.name.toString()});
                    ops = type.allOperations()->asSeq->collect(o | Seq{"operation",o.name.toString() + "(" + o.paramNames()->separateWith(",") + ")"})
                in self.owner().commandInterpreter().consoleDot(atts + ops)
                end
              end
              Classifier do
                let ops = type.allOperations()->asSeq->collect(o | Seq{"operation",o.name.toString() + "(" + o.paramNames()->separateWith(",") + ")"})
                in self.owner().commandInterpreter().consoleDot(ops)
                end
              end
           end
         end
      end
    end

    @Operation nameLookup(parameters)
      self.debug("nameLookup",parameters);
      let possiblePath = parameters.at(0) then
          path = possiblePath->splitBy(":",0,0)->reject(x | x = "")
      in if path->forAll(x | x.isKindOf(String)) and path->size > 0
         then 
           let root = path->head
           in if root.isBoundDynamic()
              then 
                let value = root.lookup()
                in if value.isKindOf(NameSpace)
                   then 
                     let element = value.lookupPath(path->tail,null)
                     in if element <> null and element.isKindOf(NameSpace)
                        then self.owner().commandInterpreter().namespace(element.names()->asSeq)
                        end
                     end
                   else self.owner().commandInterpreter().namespace(Seq{})
                   end
                end
              end
           end
         end
      end
    end
  end