parserImport XOCL;

import Clients;
import Mosaic;

context Mosaic

  @Class MosaicEventHandler extends EventHandler

    @Operation dispatchEvent(message,parameters) 
      @Case message.name of
        "fileDropped"      do self.fileDropped(parameters)       end
        "shutdownRequest"  do self.shutdown()                    end
        "shutDownAndSave"  do self.shutDownAndSave(parameters)   end
        "consoleDot"       do self.consoleDot(parameters)        end
        "nameLookup"       do self.nameLookup(parameters)        end
        "send"             do self.sendEvent(parameters)         end
        "getAllCategories" do self.getAllCategories()            end
        "getAllProjects"   do self.getAllProjects(parameters)    end
        "getDiagrams"      do self.getDiagrams(parameters)       end
        "getProjectModels" do self.getProjectModels(parameters)  end
        "getModelDiagrams" do self.getModelDiagrams(parameters)  end
        "addCategory"      do self.addCategory(parameters)       end
        "renameCategory"   do self.renameCategory(parameters)    end
        "removeCategory"   do self.removeCategory(parameters)    end
        "addProject"       do self.addProject(parameters)        end
        "renameProject"    do self.renameProject(parameters)     end
        "removeProject"    do self.removeProject(parameters)     end
        "assignCategoryToProject" do self.assignCategoryToProject(parameters)  end
        "unassignCategoryFromProject" do self.unassignCategoryFromProject(parameters)  end
        "addModel"         do self.addModel(parameters)          end
        "renameModel"      do self.renameModel(parameters)       end
        "removeModel"      do self.removeModel(parameters)       end
        "addDiagram"       do self.addDiagram(parameters)        end
        "renameDiagram"    do self.renameDiagram(parameters)     end
        "removeDiagram"    do self.removeDiagram(parameters)     end
        "startFmmlxClient" do xmf.findClient(Clients::FmmlxDiagrams::FmmlxDiagramClient).getCommunicator() end
      end
    end
    
    @Operation fileDropped(parameters)
      self.debug("fileDropped",parameters);
      let file = parameters.at(0)
      in if file.hasSuffix(".o")
         then file.loadBin(true)
         elseif file.hasSuffix(".xmf")
         then 
           Compiler::compileFile(file,true,true);
           (file.truncate(file->size - 4) + ".o").loadBin(true)
         end
      end
    end      
    
    @Operation sendEvent(parameters)
      self.debug("send",parameters);
      let target = parameters.at(0);
          name = parameters.at(1);
          args = parameters.at(2).asSeq()
      in if xmf.handles().hasKey(target) 
         then 
           let element = xmf.handles().get(target)
           in element.send(name,args)
           end
         else xmf.message("Cannot find target for handle: " + target)
         end
      end
    end
      
    @Operation shutdown()
      self.debug("shutdown",Seq{});
      let answer = xmf.questionYesNoCancel("Save image before quit?") 
      in
      	if answer <> "" // do nothing on Cancel
      	then 
        	if (answer = "No") then
        	  self.owner().commandInterpreter().shutdown()
        	elseif (xmf.saveImageAndInflater() = true) then
        	  self.owner().commandInterpreter().shutdown()
        	end
      	end
      end
    end
    
    @Operation shutDownAndSave(parameters)
      self.debug("shutDownAndSave",parameters);
      let imagePath = parameters.at(0);
          inflationPath = parameters.at(1);
          answer = "Yes"
      in if imagePath.fileExists() and inflationPath.fileExists() // will typically be true, otherwise this method is not called
         then answer := xmf.questionYesNoCancel("Overwrite " + imagePath + " and .xml?")
         else
           if imagePath.fileExists()
           then answer := xmf.questionYesNoCancel("Overwrite " + imagePath + "?")
           end;
           if answer = "Yes" and inflationPath.fileExists()
           then answer := xmf.questionYesNoCancel("Overwrite " + inflationPath + "?")
           end
         end;
         if answer = "Yes"
         then 
           self.owner().commandInterpreter().saveInflater(inflationPath);
           if xmf.saveImage(imagePath)
           then self.owner().commandInterpreter().shutdown()
           else self.owner().commandInterpreter().inflate(inflationPath)
           end
         elseif answer = "No" then self.owner().commandInterpreter().shutdown()
         // else canceled
         end
      end
    end
    
    @Operation consoleDot(parameters)
      self.debug("consoleDot",parameters);
      let text = parameters.at(0) then
          type = ExpressionGrammar.parse(text,"exp")
      in if type = Null
         then self.owner().commandInterpreter().consoleDot(Seq{})
         else 
           @TypeCase(type)
              Class do
                let atts = type.allAttributes()->asSeq->iterate(a col = Seq{} | if not (a.isIntrinsic andthen a.instLevel.minLevel < type.level.minLevel-1)
												    then
						    							col.including(Seq{"field",a.name.toString()})
													else
														col
													end);
                    ops = type.allOperations()->asSeq->iterate(o col = Seq{} | if not (o.isIntrinsic andthen o.instLevel.minLevel < (type.level.minLevel-1))
												    then
						    							col.including(Seq{"operation",o.name.toString() + "(" + o.paramNames()->separateWith(",") + ")"})
													else 
														col
													end)
				in
				  @While type.hasStructuralFeature("delegatesTo") andthen type.delegatesTo <> null
				  do 
					//(type + " hasStructuralFeature delegatesTo").println();
					type := type.delegatesTo;
					atts := atts + type.allAttributes()->asSeq->collect(a | Seq{"field",a.name.toString()});
                    ops  := ops  + type.allOperations()->asSeq->collect(o | Seq{"operation",o.name.toString() + "(" + o.paramNames()->separateWith(",") + ")"})                 
                  end; //while/do 
				self.owner().commandInterpreter().consoleDot(atts + ops)
                end //let/then/in
              end
              Classifier do
                let ops = type.allOperations()->asSeq->collect(o | Seq{"operation",o.name.toString() + "(" + o.paramNames()->separateWith(",") + ")"})
                in self.owner().commandInterpreter().consoleDot(ops)
                end
              end
           end
         end
      end
    end

    @Operation nameLookup(parameters)
      self.debug("nameLookup",parameters);
      let possiblePath = parameters.at(0) then
          path = possiblePath->splitBy(":",0,0)->reject(x | x = "")
      in if path->forAll(x | x.isKindOf(String)) and path->size > 0
         then 
           let root = path->head
           in if root.isBoundDynamic()
              then 
                let value = root.lookup()
                in if value.isKindOf(NameSpace)
                   then 
                     let element = value.lookupPath(path->tail,null)
                     in if element <> null and element.isKindOf(NameSpace)
                        then self.owner().commandInterpreter().namespace(element.names()->asSeq)
                        end
                     end
                   else self.owner().commandInterpreter().namespace(Seq{})
                   end
                end
              end
           end
         end
      end
    end
    
    // -------------------
    
    @Operation getAllCategories() 
//        let 
//           pmc = xmf.projectManager()
//        then
//        in
//        end;
        self.owner().commandInterpreter().setAllCategories(["First Category", "Second Category", "Fourth Category"])
    end
    
    @Operation getAllProjects(parameters) 
      let 
        P = Projects::Project.allInstances();
        names = [];
        paths = []
      in
        @For p in P do if p.owner <> null then
          names := names + [p.name()];
          paths := paths + [p.path()]
        end end;
        self.owner().commandInterpreter().setAllProjects(paths)
      end
    end
    
    @Operation getDiagrams(parameters)
	  let 
		result=[];
		packagePath = parameters.at(0);
		client = xmf.findClient(Clients::FmmlxDiagrams::FmmlxDiagramClient) 
	  then
		diagrams = client.diagrams
	  in
	    @For key in diagrams.keys() do
	      let
	        diagram=diagrams.get(key)
	      in
	      	if diagram.package.path()=packagePath then
	      	  result:=result+[[key,diagram.diagramName.toString(),diagram.diagramType.name.toString()]]
	        end	  
	      end  
	    end;
	    self.owner().commandInterpreter().setDiagrams(result)	  
	  end	      			
	end
	 
    @Operation getProjectModels(parameters) 
      let // 1
        projectPath = parameters.at(0);
        results = [];
        project = null
      in // 1
        @For p in Projects::Project.allInstances() do // 2
          if // 3
            p.path() = projectPath
          then 
            project := p
          end
        end; // 2
        if // 2
          project <> null 
        then 
          let // 3
            package = project.package
          in
            if package.owner <> null then  // 4
              results := [package.path()];
              @For pp in package.packages do if pp.owner <> null then
                results :=  results + [pp.path()]
              end end
            end // 4
          end // 3
//        else 
//          results := []
        end; // 2
        self.owner().commandInterpreter().setProjectModels(results)
      end // 1
    end // O
    
    @Operation addProject(parameters) 
      if 
        parameters.at(0).isValidName() 
      then 
        let
          projectName = parameters.at(0)
        then
          model = FMMLx::FmmlxPackage(projectName)
    	then
    	  project = Projects::Project(model, projectName, null)
  	in
  	  model.addParent(FMMLx);
          Root.add(model);
          xmf.projectManager("MyProjects").add(project)
        end
      end
        // throw(Exception("not yet implemented (param:" + projectName + ")")) 
    end
    
    @Operation addCategory(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation renameCategory(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation removeCategory(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    
    @Operation renameProject(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation removeProject(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation assignCategoryToProject(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation unAassignCategoryFromProject(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    
    @Operation addModel(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation renameModel(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation removeModel(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    
    @Operation addDiagram(parameters)  throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation renameDiagram(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    @Operation removeDiagram(parameters) throw(Exception("not yet implemented (param:" + parameters + ")")) end
    
  end