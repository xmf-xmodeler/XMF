parserImport XOCL;

import Signatures;
import NamedElement;
import XOCL;
import OCL;
import Walkers;
import Code;
import Clients;
import TextEditor;
import FileTextEditor;
import Stacks;

context TextEditor

  @Class EditorWalker extends CompilerWalker 

    @Attribute editor : FileTextEditor  end

    @Constructor(editor) ! end

    @Operation getNameSpace(path:Seq(String),nameSpaces:Seq(NameSpace)):NameSpace
      if path = []
      then nameSpaces->head
      else 
        let n:NameSpace = @Find(n,nameSpaces) when n.hasElement(path->head) do n.getElement(path->head) else null end
        in if n = null
           then null
           else self.getNameSpace(path->tail,[n]+nameSpaces)
           end
        end
      end
    end

    @Operation globalVar(name:String):Boolean

      // Global variables will not be in the environment managed by the walker.
      // Return true when the name is available everywhere...

      XCore.hasElement(name) orelse 
      Root.hasElement(name)  orelse 
      name="super"           orelse 
      name="declare"         orelse 
      name="hidden"
    end

    @Operation handleImports(imports:Seq(Import),env)
      // Add all the bindings from the imported name-space to the env...
      let nameSpaces = [Root]
      in @For i in imports do
           let path:Seq(String) = i.nameSpace then
               nameSpace:NameSpace = self.getNameSpace(path,nameSpaces);
               getName(e) = if e.hasStructuralFeature("name") then e.name else "$" end then
               names(n:NameSpace):[Symbol] = n.contents()->collect(c | getName(c))
           in if nameSpace <> null
              then
                nameSpaces := [nameSpace]+nameSpaces;
                @For name in names(nameSpace) do
                  if nameSpace.hasElement(name)
                  then 
                    let e = nameSpace.getElement(name)
                    in if e.isKindOf(XCore::Class)
                       then env := env.bind(name.toString(),TypeDescriptor(e.of(),e,i,"Defined in " + e.resourceName))
                       else env := env.bind(name.toString(),ImportDescriptor(null,i))
                       end
                    end
                  end
                end
              end
           end
         end;
         env
       end
    end

    @Operation walkApply(args:Seq(OCL),operator:OCL,env)
      self.walk(operator,env);
      @For arg in args do
        self.walk(arg,env)
      end
    end

    @Operation walkAttribute(line:Integer,doc:Performable,init:Performable,meta:Performable,modifiers:AttributeModifiers,mult:String,name:String,properties:Seq(Element),type:Performable,env)
      self.walk(init,env);
      self.walk(type,env)
    end

    @Operation walkBinExp(binOp:String,left:OCL,right:OCL,env)
      self.walk(left,env);
      self.walk(right,env)
    end

    @Operation walkBinding(name:String,env)
      null
    end

    @Operation walkBoolExp(line:Integer,value:Boolean,env)
      null
    end

    @Operation walkCollExp(args:Seq(OCL),collOp:String,collection:OCL,env)
      self.walk(collection,env);
      @For arg in args do
        self.walk(arg,env)
      end
    end

    @Operation walkClass(line:Integer,defs:Seq(Performable),isAbstract:Boolean,metaClass:Performable,name:String,parents:Seq(Performable),env)
      let atts = defs->select(d | d.isKindOf(XOCL::Attribute)) then
          env0 = atts->iterate(a e=env | e.bind(a.name,AttDescriptor(a.type,a))) then
          env0 = parents->iterate(parent env = env0 | self.bindInheritedAtts(parent,env))
      in self.walk(metaClass,env);
         @For parent in parents do self.walk(parent,env) end;
         @For def in defs do self.walk(def,env0) end
      end
    end

    @Operation bindInheritedAtts(parent:Performable,env) 
      if parent.isKindOf(Var)
      then 
        let name:String = parent.name.toString()
        in if env.binds(name)
           then 
             let v:VarDescriptor = env.lookup(name)
             in if v.isKindOf(TypeDescriptor)
                then 
                  let c:Classifier = v.meta
                  in if c <> null andthen c.isKindOf(XCore::Class)
                     then 
                       @For a in c.allAttributes() do
                         env := env.bind(a.name.toString(),AttDescriptor(a.type,parent))
                       end
                     end
                  end;
                  env
                else env
                end
             end
           else env
           end
         end
       else env
       end
     end
        

    @Operation walkCompilationUnit(resource:String,exps:Seq(Performable),imports:Seq(Import),source:String,parserImports:Seq(ParserImport),env)
      let env0 = self.addCompilationUnitDefs(imports,exps,env)
      in @For exp in exps do
           self.walk(exp,self.handleImports(imports,env0))
         end
      end
    end

    @Operation addCompilationUnitDefs(imports:Seq(Import),exps:Seq(Performable),env)

      // A compilation unit typically contains definitions of the form context P D where P is
      // a path to a name space and D is a definition with a name. In addition there may be
      // path updates of the form P::N := M where P is a path to a name space and N is a named 
      // element to be added or updated. Assuming P is imported in the compilation unit, then 
      // the name of D is available as a free variable anywhere. This operation extends the 
      // supplied environment with variable descriptors for these definitions...

      @Letrec
        importedNames = imports->iterate(i paths = [["Root"],["XCore"]] | paths + [i.nameSpace]);
        equalPaths(p1:Seq(String),p2:Seq(String)):Boolean = 
          if p1 = [] and p2 = []
          then true
          elseif p1 = [] or p2 = []
          then false
          else p1->head = p2->head and equalPaths(p1->tail,p2->tail)
          end;
        isDef(e:Performable):Boolean = e.isKindOf(XOCL::Def) or e.isKindOf(OCL::Operation);
        toPath(p:Path):Seq(String) =
          if p.root.isKindOf(Var)
          then [p.root.name.toString()]+p.names->butLast
          else []
          end
      in @For exp in exps do
           if exp.isKindOf(ContextDef)
           then
             if isDef(exp.element)
             then 
               if importedNames->exists(p | equalPaths(exp.path,p))
               then env := env.bind(exp.element.name.toString(),VarDescriptor(null,exp.element))
               end
             end
           elseif exp.isKindOf(PathUpdate)
           then 
             if importedNames->exists(p | equalPaths(toPath(exp.path),p))
             then env := env.bind(exp.path.names->last.toString(),VarDescriptor(null,exp))
             end
           end
         end; 
         env
      end
    end
    

    @Operation walkConsExp(head:OCL,tail:OCL,env)
      self.walk(head,env);
      self.walk(tail,env)
    end

    @Operation walkConst(value:Element,env)
      null
    end

    @Operation walkConstructor(line:Integer,charStart:Integer,charEnd:Integer,body:Performable,doc:Performable,names:Seq(String),toString:Boolean,env)
       charStart := charStart + "@Constructor("->size;
       @For name in names do
         self.walkVar(line,charStart,charStart+name->size,name,env);
         charStart := charStart + name->size + 1
       end
    end

    @Operation walkContextDef(element:OCL,isForward:Boolean,path:Seq(Element),env)
      self.walk(element,env)
    end

    @Operation walkDot(name:String,target:OCL,env)
      self.walk(target,env)
    end

    @Operation walkFind(line:Integer,charStart:Integer,charEnd:Integer,action:Performable,alternative:Performable,collection:Performable,name:String,test:Performable,env)
       let locStart = charStart + "@For ("->size then
           locEnd = locStart+name->size then
           loc = let loc = Located() in (loc.charStart := locStart).charEnd := locEnd end then
           env0 = env.bind(name,VarDescriptor(null,loc))
       in self.walk(collection,env);
          self.walk(action,env0);
          self.walk(alternative,env0);
          self.walk(test,env0)
       end
    end

    @Operation walkFloatExp(line:Integer,postPoint:String,prePoint:String,env)
      null
    end

    @Operation walkFor(line:Integer,charStart:Integer,charEnd:Integer,body:Performable,colls:Seq(Performable),directive:String,guard:Performable,isExp:Boolean,names:Seq(String),env)
       @For c in colls do self.walk(c,env) end;
       @Letrec
         mkLocated(charStart:Integer,charEnd:Integer):Located =
           let l = Located() 
           in l.charStart := charStart; l.charEnd := charEnd; l
           end;
         bind(names:Seq(String),i:Integer,env) =
           if names=[]
           then env
           else 
             let name = names->head then
                 length = name->size
             in bind(names->tail,i+length+1,env.bind(name,VarDescriptor(null,mkLocated(i,i+length))))
             end
           end
       in self.walk(body,bind(names,charStart + "@For "->size,env))
       end
    end

    @Operation walkFunBinding(name:String,args:Seq(Pattern),type:OCL,body:OCL,env)
      let env0 = args->select(p | p.isKindOf(Varp))->iterate(v e = env | e.bind(v.name,VarDescriptor(null,v))) 
      in self.walk(body,env0)
      end
    end

    @Operation walkHeadUpdate(seq:Performable,value:Performable,env)
      self.walk(seq,env);
      self.walk(value,env)
    end
    
    @Operation walkIf(line:Integer,test:Performable,e1:Performable,e2:Performable,env)
      self.walk(test,env);
      self.walk(e1,env);
      self.walk(e2,env)
    end

    @Operation walkInstantiate(args:Seq(KeyArg),class:Performable,env)
      self.walk(class,env);
      @For arg in args do
        self.walk(arg,env)
      end
    end

    @Operation walkIntExp(line:Integer,value:Integer,env)
      null
    end

    @Operation walkIterExp(body:OCL,collection:OCL,iterOp:String,name:String,env)
       self.walk(collection,env);
       self.walk(body,env.bind(name,VarDescriptor()))
    end

    @Operation walkIterate(accumulator:String,body:OCL,collection:OCL,name:String,value:OCL,env)
      self.walk(collection,env);
      self.walk(value,env);
      self.walk(body,env.bind(accumulator,null).bind(name,VarDescriptor()))
    end

    @Operation walkLet(line:Integer,bindings:Seq(ValueBinding),body:OCL,env)
       @For b in bindings do self.walk(b,env) end;
       let env0 = bindings->iterate(b e=env | e.bind(b.name,VarDescriptor(b.type,b)))
       in self.walk(body,env0)
       end
    end 

    @Operation walkNamedType(charStart:Integer,charEnd:Integer,path:Seq(String),env)
       self.walkVar(0,charStart,charEnd,path->head.toString(),env)
    end

    @Operation walkNegate(exp:OCL,env)
      self.walk(exp,env)
    end

    @Operation walkOperation(doc:Performable,imports:Seq(Seq(String)),isMultiArgs:Boolean,name:String,args:Seq(Pattern),body:Performable,type:TypeExp,properties,env)
      let env0 = args->select(p | p.isKindOf(Varp))->iterate(v e = env | e.bind(v.name,VarDescriptor(null,v)))
      in @For arg in args do self.walk(arg,env) end;
         self.walk(body,env0);
         self.walk(type,env)
      end
    end

    @Operation walkOrder(first:OCL,second:OCL,env)
      self.walk(first,env);
      self.walk(second,env)
    end

    @Operation walkParametricType(charStart:Integer,charEnd:Integer,args:Seq(TypeExp),constructor:Seq(String),env)
      self.walkVar(0,charStart,charEnd,constructor->head,env);
      @For arg in args do
        self.walk(arg,env)
      end
    end

    @Operation walkPath(names:Seq(Element),root:OCL,env)
      null
    end

    @Operation walkPathUpdate(path:Path,value:Performable,env)
      self.walk(value,env)
    end

    @Operation walkSelf(line:Integer,env)
      null
    end

    @Operation walkSend(args:Seq(OCL),message:String,target:OCL,env)
      self.walk(target,env);
      @For arg in args do 
        self.walk(arg,env)
      end
    end

    @Operation walkSetExp(line:Integer,collType:String,elements:Seq(OCL),env)
      @For e in elements do
        self.walk(e,env)
      end
    end

    @Operation walkSlotUpdate(name:String,target:OCL,value:OCL,env)
      self.walk(target,env);
      self.walk(value,env)
    end

    @Operation walkStrExp(line:Integer,value:String,env)
      null
    end

    @Operation walkVar(line:Integer,charStart:Integer,charEnd:Integer,name:String,env)

      // Inform the editor of any unbound variables. The supplied
      // environment binds the names of the variables to information
      // bundles. Some name-spaces are implicitly imported everywhere
      // and those should be checked here...

      if env.binds(name)
      then 
        let d:VarDescriptor = env.lookup(name)
        in if d <> null 
           then d.sendEditor(editor,charStart,charEnd)
           end
        end
      elseif not(self.globalVar(name))
      then editor.unboundVar(name,charStart,charEnd)
      end
    end

    @Operation walkVarp(charStart:Integer,charEnd:Integer,name:String,pattern:Pattern,type:TypeExp,env)
      self.walk(type,env)
    end
  
  end