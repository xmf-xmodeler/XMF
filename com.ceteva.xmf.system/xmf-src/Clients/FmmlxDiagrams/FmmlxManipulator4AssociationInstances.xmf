parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxManipulator
  @Operation countOccurences(
    o : Object,
    p : FMMLxPackage,
    a : Association,
    countSourceOccurences : Boolean,
    countTargetOccurences : Boolean)
     
    let
      count = 0
    in
      if p.fmmlxAssociationInstances = null then 0 else
        @For link in p.fmmlxAssociationInstances do
          if countSourceOccurences andthen link.at(0) = o andthen link.at(2) = a then count := count + 1 end;
          if countTargetOccurences andthen link.at(1) = o andthen link.at(2) = a then count := count + 1 end
        end;
        count
      end
    end 
  end

context FmmlxManipulator
  @Operation countOccurencesForType(
    type        : Class,
    level       : int,
    package     : FmmlxPackage,
    association : Association,
    countSourceOccurences : Boolean,
    countTargetOccurences : Boolean)
   	  
    if not type.isKindOf(FMMLx::MetaClass) then null else
     
      let
        minCount = null;
        maxCount = null;
        count = null
      in
        @For instance in type.allMetaInstances() do
          if instance.level = level then
            count := self.countOccurences(instance, package, association, countSourceOccurences, countTargetOccurences);
            minCount := if minCount = null then count else if count < minCount then count else minCount end end;
            maxCount := if maxCount = null then count else if count > maxCount then count else maxCount end end
          end
        end;
      [minCount, maxCount]
      end
    end
  end
    
context FmmlxManipulator
  @Operation addAssociationInstance(
    p       : Package,
    objectS : Object,
    objectT : Object,
    a       : Association)
  
    let 
      typeS = a.source.type;
      typeT = a.target.type;
      instLevelS = a.target.instLevel;
      instLevelT = a.source.instLevel;
      typesOK = false;
      objTemp = null
    in 
     // First check if they aren't there already ->
     // might be unnecessary, as Sets ignore duplicates anyway
     // if not p.hasAssociationInstance(objectS, objectT, a)
     // then
        if self.isInstanceOf(objectS, typeS, instLevelS) andthen self.isInstanceOf(objectT, typeT, instLevelT)
        then typesOK := true 
        else if self.isInstanceOf(objectT, typeS, instLevelS) andthen self.isInstanceOf(objectS, typeT, instLevelT)
        then typesOK := true; objTemp:=objectT; objectT:=objectS; objectS:=objTemp end end;
  	    
        // Now it is checked if the objects fit the type (typesOK). If that is the case, objectS and objectT may have swapped to fit the type.

        if typesOK then 
          let
            slotS2T = objectS.get(a.target.name);
            slotT2S = if a.source.visible then objectT.get(a.source.name) else null end
          then 
            sCount = if slotS2T = null then 0 elseif slotS2T.isKindOf(Set(Element)) then slotS2T.size() else 1 end;
            tCount = if a.source.visible then
                       if slotT2S = null then 0 elseif slotT2S.isKindOf(Set(Element)) then slotT2S.size() else 1 end
                     else null end;
            // countOccurences likely does not work anymore and always returns 0 
            //sCount = self.countOccurences(objectS, p, a, true, false); // how many links to t go out of objectS
            //tCount = self.countOccurences(objectT, p, a, false, true); // how many links to s go out of objectT
            sMult = a.target.mult;  // how many links to t are allowed for objectS
            tMult = a.source.mult // how many links to s are allowed for objectT
          in
            if ((not sMult.hasUpperBound) orelse (sMult.upperBound > sCount)) andthen 
               ((not tMult.hasUpperBound) orelse (tMult.upperBound > tCount))  
            then
              //p.addAssociationInstance(objectS, objectT, a);
              // source->target
              //"trying to set link...".println();
              if 
                a.target.visible
              then
                if
                  (not a.target.mult.hasUpperBound) orelse a.target.mult.upperBound > 1
                then
                  //"target is Set(...)".println();
                  if objectS.get(a.target.name) = null then objectS.set(a.target.name, {}) end; // make empty list if initialized with null
                  objectS.set(a.target.name, objectS.get(a.target.name) + {objectT})
                else
                  //"target is not Set(...)".println();
                  objectS.set(a.target.name, objectT)
                end
              //else "target not visible".println()
              end;
              // target->source
              if 
                a.source.visible
              then
                if
                  (not a.source.mult.hasUpperBound) orelse a.source.mult.upperBound > 1
                then
                  //"source is Set(...)".println();
                  if objectT.get(a.source.name) = null then objectT.set(a.source.name, {}) end; // make empty list if initialized with null
                  objectT.set(a.source.name, objectT.get(a.source.name) + {objectS})
                else
                  //"source is not Set(...)".println();
                  objectT.set(a.source.name, objectS)
                end
              //else "source not visible".println()
              end;
              []
            else // multiplicity does not allow new link
              [" The multiplicity does not allow a new link."]
            end // if multiplicity ok
          end
        else // types not OK
          ["The objects do not fit the type."]
        end // if typesOK
      //else // p already has
      //  ["The link already exists."]
      //end // if not already there
    end
  end
    
  context FmmlxManipulator
    @Operation removeAllAssociationInstances(a)
      let
        p = a.owner();
        toBeRemoved = {}
      in
        @For link in p.fmmlxAssociationInstances do
          if link.at(2) = a then
            toBeRemoved := toBeRemoved + {link}
          end
        end;
        @For link in toBeRemoved do
          p.removeAssociationInstance(link.at(0), link.at(1), link.at(2)) 
        end
      end
    end
    
  context FmmlxManipulator
    @Operation removeAssociationInstance(a, o1, o2)
      let 
        slotTargetValue = o1.get(a.target.name)
      in
        if
          a.target.mult.hasUpperBound and a.target.mult.upperBound = 1
        then
          o1.set(a.target.name, null)
        else
          o1.set(a.target.name, slotTargetValue - {o2})
        end
      end;
      if a.source.visible then
        let 
          slotSourceValue = o2.get(a.source.name)
        in
          if
            a.source.mult.hasUpperBound and a.source.mult.upperBound = 1
          then
            o2.set(a.source.name, null)
          else
            o2.set(a.source.name, slotSourceValue - {o1})
          end
        end
      end;
      []
    end 
    