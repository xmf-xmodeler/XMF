parserImport XOCL;

import Root::FMMLx;

context Root::FMMLx

  @Class FmmlxObject extends NamedElement
  
  @Attribute level : Level end
  @Attribute lastUpdated : Element end

    @Operation setLevel(level)
      if self.of() <> FMMLx::MetaClass then
        self.error("This operation can only be executed on direct instances of FMMLx::MetaClass")
      else
        self.level := level;
        if level > 0 
        then self.addParent(FMMLx::MetaClass)
        else self.removeParent(FMMLx::MetaClass)
        end
      end
    end
    
    @Attribute cachedOpSendInstance : Operation end
    @Attribute cachedOpAllAttributes : Operation end
    
    /* This Operation should've been named send-TO-Instance. 
       It is invoked when an operation is invoked. 
       This operation tries to find out where the operation is defined.
    */
    @Operation sendInstance(element,message,args):XCore::Element
      if "sendInstance".equals(message.toString()) then 
        if self.cachedOpSendInstance = null then self.cachedOpSendInstance := FMMLx::MetaClass.getOperation("sendInstance") end;
        self.cachedOpSendInstance.invoke(element,args)
      elseif "allAttributes".equals(message.toString()) then 
        if self.cachedOpAllAttributes = null then self.cachedOpAllAttributes := FMMLx::MetaClass.getOperation("allAttributes") end;
        self.cachedOpAllAttributes.invoke(element,args)
      else
//       ("[sendInstance] " + element.name + ":" + self.name + ": Operation "+message).println();
      let
        // String to Symbol if necessary
        name = if message.isKindOf(Symbol) then message else Symbol(message) end; 
//        ownOperations = self.allOperations()->asSeq; 
        ownOperations = Kernel_operatorPrecedenceList(self)->asSeq; 
        allOperations = [];
        delToClassOps = [];
        found = false; op = null; foundDelToClass = false;
        index = 0; delToClassIndex = 0 // temporary counter
      in 
    /*  "self" is the class of "element" and therefore the most obvious place
        to look for an operation. "self.allOperations()" will check the class 
        and all its parents. I.e. where you would look in a two-level architecture.
        If you find something there, check the level if intrinsic and the operation 
        can be invoked  
    */    
        let  // let 1
          size = ownOperations->size;
          arity = args->size
        in 
          index := 0;
          @While index < size and not found do //loop until found through all operations 
            op := ownOperations->at(index);
            if op.name = name andthen (op.arity() = arity or (op.isVarArgs() and (arity >= (op.arity() - 1))))
            then found := true
            else index := index + 1
            end
          end; // while
          if found
          then
            /* Now, we found the operation.
               Before we can invoke it, we must check if the intrinsic 
               level forbids us to do so.
               We'll pretend we didn't find it if the intrinsic levels is too low */
            if 
              (op.isIntrinsic andthen op.instLevel < (self.level-1)) // wrong level
            then
              //("The level " + (self.level-1) + " object " + element 
              //+ " must not invoke the level " + op.instLevel + " operation " + name + ".").println();
              //element.noOperationFound(message,args)
              found := false
            end
          end // if 
        end; // let 1
        
        /* now we tried to find via the traditional way.
           If still not found, there are two options left: intrinsic operations and delegation.
           We can use allOperations2() to find all multilevel operations
           
           allOperations2() will find all operations in all parent and metaclasses
        */
        allOperations := ownOperations;
        //(name + " found? " + found).println();
        if not found then let  // if+let 2
          //size = operations->size;
          arity = args->size
        in
          index := 0;
          allOperations := self.allOperations2(); // TODO?: modify to avoid delegation here
          @While index < allOperations->size and not found do //loop until found through all operations 
            op := allOperations->at(index);
            if 
              op.name = name
            andthen 
              (op.arity() = arity or (op.isVarArgs() and (arity >= (op.arity() - 1))))
            andthen
              op.isIntrinsic
            andthen
              op.instLevel = (self.level-1)
            then found := true
            else index := index + 1
            end
          end
        end end; // if+let 2
        
        /*We have tried the traditional way and the multilevel way. 
          We try delegateToClass next if not found yet.
        */
        
        if not found then let // if+let 3
          delegateToClassOps = self.getOperationsAvailableThroughDelegateToClass()
        then
          arity = args->size
        in 
          delToClassIndex := 0;
          @While delToClassIndex < delegateToClassOps->size and not foundDelToClass do //loop until found through all operations 
            op := delegateToClassOps->at(delToClassIndex);
            if 
              op.name = name
            andthen 
              (op.arity() = arity or (op.isVarArgs() and (arity >= (op.arity() - 1))))
            andthen
              op.isIntrinsic
            andthen
              op.instLevel =  self.level // !! the level of the class (not the instance must match)
            then foundDelToClass := true
            else delToClassIndex := delToClassIndex + 1
            end // if
          end // while
        end end; // if+let 3
        
        if not found and not foundDelToClass then
          /* We have not found the operation yet.
             But maybe we are lucky with delegation.
             If we find a role filler, then forward to them. */
          if 
            element <> null andthen element.hasSlot("roleFiller") andthen element.roleFiller <> null 
          then
            //("Operation not found and forwarded to roleFiller " + element.roleFiller).println();
            element.roleFiller.send(message,args)
          else
            //"Operation not found, throwing Exception".println();
            element.noOperationFound(message,args)
          end
        elseif foundDelToClass then // at least found an operation available through delegation to class
          ("Delegate To Class: " + element.name + "->" + self.name).println();
          self.send(message, args)
        else /* we have indeed found the operation and invoke it */
          //(element + ": Operation "+op.name+" found and to be invoked").println();
          allOperations := allOperations->drop(index);
          op.setSupers(allOperations); /// WHAT?
          op.invoke(element,args)
        end        
      
      end // let
      end // test
    end // operation

    @Operation isDescendantOf(ancestor : MetaClass): XCore::Boolean
      if self = ancestor then false else
        let tmp = self
        in
          @While tmp <> FMMLx::MetaClass andthen (ancestor.level.maxLevel = null orelse tmp.level.minLevel < ancestor.level.maxLevel) do
            tmp := tmp.of()
          end;
          tmp = ancestor orelse tmp.inheritsFrom(ancestor)
        end
      end
    end
   
  @Operation getOperationsAvailableThroughDelegateToClass()
    if self.of().isKindOf(MetaClass) then 
     let 
       ops = {}
     in
       @For o in self.of().allOperations2() do
         if (let P = o.properties(); b = false in @For p in P do if p->head() = "delToClassAllowed" then b := p->tail() end end; b end) then
           ops := ops + {o}
         end
       end;
     ops.asSeq()
     end
    else [] end
  end
   
  @Operation allConstraints():Set(Constraint)
    let
      allC = constraints;
      allP = parents; // parents and classes
      result = {};
      alreadyChecked = {}
    in
      allP := allP->union({self.of()});
      @While not allP->isEmpty do
        let p = allP->sel
        in alreadyChecked := alreadyChecked->union({p});
          @For c2Bchecked in p.constraints do
            if c2Bchecked.body.isIntrinsic or self.allParents().contains(p) then 
              allC := allC->union({c2Bchecked})
          end end;
          if p.parents.contains(FMMLx::MetaClass)
            then allP := allP->union({p.of()}) end;
          allP := (allP->excluding(p)->union(p.parents)) - alreadyChecked
        end
      end;
      // remove all intrinsic, where level is too high
      @For c in allC do
         if (not c.body.isIntrinsic) or c.body.instLevel < self.level then
           result := result->union({c})
         end
       end;
       result
    end
  end
    
  @Operation checkConstraints(extended:Boolean):Seq(ConstraintReport)
    let
      constraints = self.of().allConstraints();
      reports = [];
      LEVEL = 1 // body and reason require a level, should be 1 for classic constraints
    in
      @For constraint in constraints
        ->select(c | (not c.body.isIntrinsic) orelse c.body.instLevel.minLevel = self.level.minLevel)
        ->select(c | extended orelse c.owner.isKindOf(FMMLx::FmmlxObject))
      do
        reports := [
          try 
            if constraint.body.invoke(self,Seq{self.of(), LEVEL})
              then ConstraintReport(self,constraint,true)
              else ConstraintReport(self,constraint,false,constraint.reason.invoke(self,Seq{self.of(), LEVEL}))
    	    end
          catch(exception)
            ConstraintReport(self,constraint,false,"Error while performing classification: " + exception.message)
          end] + reports
      end;
      ConstraintReport(self,null,reports->forAll(r | r.satisfied()),"",reports)
    end
  end
  
  @Operation getLevel() self.level.getLevel() end
  
  @Operation allAncestors():Set(Class)
    {self.of()} + self.of().allAncestors()
  end
  
  @Operation repairSlots()
    Clients::FmmlxDiagrams::FmmlxManipulator().repairSlots(self)
  end
  
  @Constraint objectInstanceOfClass
    self.of() = FMMLx::MetaClass orelse self.of().isKindOf(FMMLx::MetaClass)
  fail
    "This FMMLxObject is not a (recursive) instance of a MetaClass ."
  end
  
  @Constraint levelCorrectness
    (self.level.maxLevel = null orelse self.level.maxLevel >= self.level.minLevel)
    andthen
    (self.level.minLevel = 0 implies self.level.maxLevel = 0) // redundant
    andthen
    (self.level.minLevel = 1 implies self.level.maxLevel = 1)
    andthen
    let
      ofLevel = if self.of()=FMMLx::MetaClass 
        then Level(2,null) else self.of().level end
    in
      self.level.minLevel >= ofLevel.minLevel - 1 and (
        ofLevel.maxLevel = null orelse
        self.level.maxLevel <= ofLevel.maxLevel - 1)
    end
  fail
    "The level is not correct"
  end
  
  @Constraint noClassOnLevelZero
    self.isKindOf(FMMLx::MetaClass) implies self.level.minLevel > 0
  fail
    "An element on level 0 must not be a class "
  end

  @Constraint abstractClassNoInstance
    not self.of().isAbstract
  fail
    "This object is an instance of an abstract class."
  end
  
  @Constraint attributeSlotExistence
    self.allRelevantAttributes()
      ->forAll(a | self.hasSlot(a.name))
  fail
    "This element lacks a slot from the attributes " + 
    (self.allRelevantAttributes()->reject(a | self.hasSlot(a.name))).name
  end
  
  @Constraint attributeSlotStructure
    self.allRelevantAttributes()
      ->select(a | a.mult().isKindOf(Multiplicities::CollectionMult))
      ->forAll(a | 
        (a.mult().hasUpperBound andthen a.mult().upperBound=1)
          <>
        (self.get(a.name).isKindOf(Set(Element)) or
        self.get(a.name).isKindOf(Seq(Element))))
  fail
    "The slots " + (
      self.allRelevantAttributes()
      ->select(a | a.mult().isKindOf(Multiplicities::CollectionMult))
      ->reject(a | 
        (a.mult().hasUpperBound andthen a.mult().upperBound=1)  <>
        (self.get(a.name).isKindOf(Set(Element)) or
        self.get(a.name).isKindOf(Seq(Element))))
    ).name + " have the wrong structure"
  end
  
  @Constraint attributeSlotMultiplicity
    self.allRelevantAttributes()
      ->select(a | a.mult().isKindOf(Multiplicities::CollectionMult))
      ->forAll(a | let
        val = self.get(a.name)
      in
        if 
          a.mult().hasUpperBound andthen a.mult().upperBound = 1
        then        
          a.mult().lowerBound = 1 implies val <> null
        else 
          (a.mult().hasUpperBound implies
            val.size() <= a.mult().upperBound) andthen
          val.size() >= a.mult().lowerBound
        end end)
  fail
    "The slots " + (
    self.allRelevantAttributes()
      ->select(a | a.mult().isKindOf(Multiplicities::CollectionMult))
      ->reject(a | let
        val = self.get(a.name)
      in
        if 
          a.mult().hasUpperBound andthen a.mult().upperBound = 1
        then        
          a.mult().lowerBound = 1 implies val <> null
        else 
          (a.mult().hasUpperBound implies
            val.size() <= a.mult().upperBound) andthen
          val.size() >= a.mult().lowerBound
        end end)
    ).name + " do not conform to their multiplicity"
  end

  @Constraint attributeSlotConformity
  self.allRelevantAttributes()
    ->select(a | a.mult().isKindOf(Multiplicities::CollectionMult))
    ->forAll(a | let
        val = self.get(a.name);
        type = a.type
      in
        @While type.isKindOf(Set) orelse type.isKindOf(Seq) do type := type.elementType end; //legacy?
        if 
          a.mult().hasUpperBound andthen a.mult().upperBound=1
        then        
          val.isKindOf(type) 
        else 
          val->forAll(item | 
            item <> null andthen item.isKindOf(type))
        end end)
  fail
    "The slots " + (
    self.allRelevantAttributes()
    ->select(a | a.mult().isKindOf(Multiplicities::CollectionMult))
    ->reject(a | let
        val = self.get(a.name);
        type = a.type
      in
        @While type.isKindOf(Set) orelse type.isKindOf(Seq) do type := type.elementType end; //legacy?
        if 
          a.mult().hasUpperBound andthen a.mult().upperBound=1
        then        
          val.isKindOf(type) 
        else 
          val->forAll(item | 
            item <> null andthen item.isKindOf(type))
        end end)
    ).name + " contain values not conforming to the required type"
  end
  
  @Constraint associationWithPackage
    self.owner.classes.contains(self)
  fail
    "The owner of this object does not contain it."
  end
  
  /* Duplicates
  @Constraint linksStructure
    self.slots()
      ->select(s | s.type.isKindOf(Associations::End))
      ->select(s | s.type.visible)
      ->select(s | (not s.type.mult.hasUpperBound) orelse
                   s.type.mult.upperBound > 1)
      ->forAll(s | s.value.isKindOf(Set(Element)))
  fail
    let falseSlots = self.slots()
      ->select(s | s.type.isKindOf(Associations::End))
      ->select(s | s.type.visible)
      ->select(s | (not s.type.mult.hasUpperBound) orelse
                   s.type.mult.upperBound > 1)
      ->reject(s | s.value.isKindOf(Set(Element)))
    in 
    "Structural problem: The slots " + falseSlots.name + " must be lists."
    end
  end

  @Constraint linksMultiplicity
    self.slots()
      ->select(s | s.type.isKindOf(Associations::End))
      ->select(s | s.type.visible)
      ->forAll(s | if s.type.mult.hasUpperBound 
                 andthen s.type.mult.upperBound = 1
        then (if s.type.mult.lowerBound = 1 then s.value <> null else true end)
        else s.value.size() >= s.type.mult.lowerBound and
           (if s.type.mult.hasUpperBound then
            s.value.size() <= s.type.mult.upperBound
            else true end)
        end)
  fail
    let falseSlots = self.slots()
      ->select(s | s.type.isKindOf(Associations::End))
      ->select(s | s.type.visible)
      ->reject(s | if s.type.mult.hasUpperBound 
                 andthen s.type.mult.upperBound = 1
        then (if s.type.mult.lowerBound = 1 then s.value <> null else true end)
        else s.value.size() >= s.type.mult.lowerBound and
           (if s.type.mult.hasUpperBound then
            s.value.size() <= s.type.mult.upperBound
            else true end)
        end)
    in
    "The multiplicity does not allow the number of links specified for links in " + falseSlots.name
    end
  end */

  @Operation allRelevantAttributes()
    self.of().allAttributes()
      ->reject(a | a.isKindOf(Associations::End))
      ->select(a | (a.isIntrinsic andthen a.instLevel.minLevel = self.level.minLevel) 
        orelse ((not a.isIntrinsic) and self.isKindOf(a.owner)))
  end
   
  @Operation allRelevantAssociationEnds()
    self.of().allAttributes()
      ->select(a | a.isKindOf(Associations::End))
      ->select(a | a.instLevel.minLevel = self.level.minLevel)
      ->select(a | a.visible)
  end

  @Constraint associationSlotExistence
    self.allRelevantAssociationEnds()
      ->forAll(e | self.hasSlot(e.name))
  fail
    "This element lacks a slot from an association"
  end
  
  @Constraint associationSlotStructure
    self.allRelevantAssociationEnds()
      ->forAll(e | 
        (e.mult.hasUpperBound andthen e.mult.upperBound=1)
          <>
        self.get(e.name).isReallyKindOf(Set(Element)))
  fail
    "Some slots "+
    (self.allRelevantAssociationEnds()
      ->reject(e | 
        (e.mult.hasUpperBound andthen e.mult.upperBound=1)
          <>
        self.get(e.name).isReallyKindOf(Set(Element))).name)
    +" have the wrong structure"
  end
  
  @Constraint associationSlotMultiplicity
    self.allRelevantAssociationEnds()
      ->forAll(e | let
          val = self.get(e.name)
        in
          if 
            e.mult.hasUpperBound andthen e.mult.upperBound = 1
          then        
            e.mult.lowerBound = 1 implies val <> null
          else 
            (e.mult.hasUpperBound implies
              val.size() <= e.mult.upperBound) andthen
            val.size() >= e.mult.lowerBound
          end end)
  fail
    let fails = self.allRelevantAssociationEnds()
      ->reject(e | let
          val = self.get(e.name)
        in
          if 
            e.mult.hasUpperBound andthen e.mult.upperBound = 1
          then        
            e.mult.lowerBound = 1 implies val <> null
          else 
            (e.mult.hasUpperBound implies
              val.size() <= e.mult.upperBound) andthen
            val.size() >= e.mult.lowerBound
          end end)
    in
      "Some links ("+fails.name+") do not conform to their multiplicity"
    end
  end
  
  @Constraint associationDependency
    self.allRelevantAssociationEnds()
      ->select(e | e.association.dependsOn <> null)
      ->forAll(e | let
          val = self.get(e.name);
          dependsOn = e.association.dependsOn;
          reversed = e.association.source = e          
      then
        links = if val = null then {null} elseif val.isKindOf(Set(Element)) then val else {val} end
      in
        links->forAll(link | 
          // there must also be another link of dependsOn in the ancestors
          // so we check all ancestors for slots which belong to dependsOn
          // we also check all ancestors of the other side
          // the ancestors on both sides should be a manageable amount
          ({self}+self.allAncestors())->exists(anc1 |
            // not yet: link.allAncestors->exists(anc2 |
            // now we have two candidates
            // anc1 is ancestor of self, anc2 of the link target
            // we do not care whether anc1 or anc2 are able to have a link of depends on
            // we do care if they have one (which includes the former and saves a lot of additional checks)
            // we further assume that the navigability and direction of dependsOn is the same as that of the other association
            // so if self knows the link target, anc1 must know anc2, 
            // whether anc2 knows anc1 is irrelevant
            let 
              val2 = try anc1.get(if reversed then dependsOn.source else dependsOn.target end.name) catch (ex) null end
            then                    
              links2 = if val2 = null then {null} elseif val2.isKindOf(Set(Element)) then val2 else {val2} end
            in
              ({link}+link.allAncestors())->exists(anc2 | links2.contains(anc2))
            end))
      end)
  fail
    "Links to " + 
    (self.allRelevantAssociationEnds()
      ->select(e | e.association.dependsOn <> null)
      ->collect(e | let
          val = self.get(e.name);
          dependsOn = e.association.dependsOn;
          reversed = e.association.source = e          
      then
        links = if val = null then {null} elseif val.isKindOf(Set(Element)) then val else {val} end
      in
        links->reject(link | 
          ({self}+self.allAncestors())->exists(anc1 |
            let 
              val2 = try anc1.get(if reversed then dependsOn.source else dependsOn.target end.name) catch (ex) null end
            then                    
              links2 = if val2 = null then {null} elseif val.isKindOf(Set(Element)) then val2 else {val2} end
            in
              ({link}+link.allAncestors())->exists(anc2 | links2.contains(anc2))
            end))
      end))->flatten.name
      + 
      " are invalid. (Check 'dependsOn' in association)"
      
  end
  
  @Constraint associationSlotConformity
    self.allRelevantAssociationEnds()
      ->forAll(e | let
          val = self.get(e.name);
          otherEnd = if e.association.source = e 
                     then e.association.target
                     else e.association.source end
        in
          if 
            e.mult.hasUpperBound andthen e.mult.upperBound=1
          then
            val = null orelse (val.isDescendantOf(e.type) andthen
              val.level.matchesInstantiationLevel(otherEnd.instLevel))
          else 
            val->forAll(item | 
              item <> null andthen item.isDescendantOf(e.type) andthen
              item.level.matchesInstantiationLevel(otherEnd.instLevel))
          end end)
  fail
    let fails = self.allRelevantAssociationEnds()
      ->reject(e | let
          val = self.get(e.name);
          otherEnd = if e.association.source = e 
                     then e.association.target
                     else e.association.source end
        in
          if 
            e.mult.hasUpperBound andthen e.mult.upperBound=1
          then
            val = null orelse (val.isDescendantOf(e.type) andthen
              val.level.matchesInstantiationLevel(otherEnd.instLevel))
          else 
            val->forAll(item | 
              item <> null andthen item.isDescendantOf(e.type) andthen
              item.level.matchesInstantiationLevel(otherEnd.instLevel))
          end end)
    in 
      "Some slots ("+fails.name+") contain values not conforming to the required type"
    end 
  end

  @Constraint allElementNamesUnique
    self.owner.classes->forAll(otherClass|
      self.name.equals(otherClass.name) = (self = otherClass))
  fail
      "There is another element with the same name"
  end
  
  @Operation getRoleFillerClass()
    let 
      roleFillerDefs = //if self.of() = FMMLx::MetaClass then {} else
        self.allAncestors()
          ->select(a | a.delegatesTo <> null)
          ->select(a | a.delegatesToLevel.minLevel = self.level.minLevel) //end
    in
      if roleFillerDefs.size() = 0 then null
      elseif roleFillerDefs.size() = 1 then roleFillerDefs->sel 
      else throw Exception("More than two delegations found: " + roleFillerDefs)
      end
    end
  end
  
  @Constraint roleFillerPresent
    let 
      roleFillerClass = self.getRoleFillerClass()
    in
      roleFillerClass = null orelse (
      self.roleFiller <> null andthen 
      self.roleFiller.isDescendantOf(roleFillerClass.delegatesTo) andthen
      self.roleFiller.level.minLevel = self.level.minLevel)
    end
  fail
    "The role filler is not set or does not conform to the delegation definition"
  end  
  
end
