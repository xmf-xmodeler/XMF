parserImport XOCL;

//context Root
//
//  @Package FMML metapackage XCore extends XCore
//  end

context Root
  @Package Auxiliary end
  
context Root::Auxiliary
  @Class Complex
    @Attribute real:Number end
    @Attribute imaginary:Number end
    
    @Constructor(real,imaginary) end
        
    @Operation toString()  
      let 
        iText = 
          if     imaginary =  1 then  "i"
          elseif imaginary = -1 then "-i"
          else  (imaginary + "i") end
      in
        ""+
        if 
          imaginary = 0 
        then 
          real
        else
          if 
            real = 0
          then
            iText
          else
            real + if imaginary > 0 then "+" else "" end + iText
          end
        end
      end
    end
    
    @Operation magnitude() ((self.real*self.real)+(self.imaginary*self.imaginary)).sqrt() end
    @Operation argument() xmf.javaClass("java.lang.Math").atan2(self.imaginary+0.0,self.real+0.0) end
    
    @Operation add(other) Complex(self.real+other.real,self.imaginary+other.imaginary) end
    @Operation sub(other) Complex(self.real-other.real,self.imaginary-other.imaginary) end
    @Operation mul(other) Complex((self.real*other.real)-(self.imaginary*other.imaginary),(self.real*other.imaginary)+(other.real*self.imaginary)) end
    @Operation div(other) Complex(
        ((self.real*other.real)+(self.imaginary*other.imaginary))/((other.real*other.real)+(other.imaginary*other.imaginary)),
        ((self.real*other.imaginary)-(other.real*self.imaginary))/((other.real*other.real)+(other.imaginary*other.imaginary)))
    end
    
    @Operation createFromPolar(magnitude, argument) 
      Complex(magnitude * xmf.javaClass("java.lang.Math").cos(argument), magnitude * xmf.javaClass("java.lang.Math").sin(argument))
    end
    
    @Operation rotate(angle) 
      Complex::createFromPolar(self.magnitude(), self.argument() + angle)
    end
    
    @Operation exp(z:Complex)
      let 
        a = xmf.javaClass("java.lang.Math").exp(z.real) 
      in
      Complex(
        a * xmf.javaClass("java.lang.Math").cos(z.imaginary),
        a * xmf.javaClass("java.lang.Math").sin(z.imaginary)
        )
      end
    end
    
    @Operation pi() Complex(-1,0).argument() end
    
    @Operation toParseableString():String 
      "Auxiliary::Complex(" + self.real + ", " + self.imaginary + ")"
    end
    
  end
  
context Root::Auxiliary
  @Class AuxiliaryClass isabstract
    @Attribute symbol:String end
    @Attribute abbreviation:String end
    @Attribute refValue:Float end
    
    @AbstractOp getAsString():String end
    @AbstractOp setAsString(s:String) end
  end
  
context Root::Auxiliary
  @Class Currency
    @Attribute symbol:String end
    @Attribute abbreviation:String end
    @Attribute refValue:Float end
    
    @Constructor(symbol, abbreviation, refValue) end
    
    @Operation getRefValue() 
//      self.refValue := try 
//        if "EUR"=self.abbreviation then 1.0 else 1.0 / xmf.javaClass("tool.helper.CurrencyRates").getpriceOf1EUR(abbreviation) end 
//      catch(e)
//        "getRefValue failed".println();
//        1.0
//      end;
//      self.refValue
      self.refValue := if "EUR"=self.abbreviation then 1.0 else 1.0 / xmf.javaClass("tool.helper.CurrencyRates").getPriceOf1EUR(abbreviation) end;
      self.refValue
    end

    @Operation toParseableString():String 
      "Auxiliary::Currency(\"" + symbol + "\", \"" + abbreviation + "\", " + refValue + ")"
    end
    
    @Operation toString() 
      "Currency<" + self.abbreviation + ">" 
    end
  end

context Root::Auxiliary
  @Class MonetaryValue
    @Attribute amount:Float end
    @Attribute currency:Root::Auxiliary::Currency end
    
    @Constructor(amount, currency) end
    
    @Operation toString():String
      let 
        DecimalFormat = xmf.javaClass("java.text.DecimalFormat")
      then
        df2 = DecimalFormat("0.00")
      in 
        df2.format(self.amount + 0.0) + " " + self.currency.symbol 
      end
    end
    
    @Operation getAmountIn(otherCurrency:Root::Auxiliary::Currency):Float self.amount * self.currency.getRefValue() / otherCurrency.getRefValue() end
    @Operation getAmount():Float self.amount end
    @Operation getCurrency():Root::Auxiliary::Currency self.currency end
    
    @Operation mul(factor:Float):Root::Auxiliary::Currency MonetaryValue(self.amount*factor, self.currency) end
    @Operation add(other:MonetaryValue):MonetaryValue MonetaryValue(self.amount + other.getAmountIn(self.currency), self.currency) end
    @Operation sub(other:MonetaryValue):MonetaryValue self.add(other.mul(-1)) end
    @Operation round2Digits():MonetaryValue MonetaryValue((self.amount * 100).round()/100 , self.currency) end
    
    @Operation toParseableString():String 
      "Auxiliary::MonetaryValue(" + self.amount + ", " + self.currency.toParseableString() + ")"
    end
    
  end
  
context Root::Auxiliary
  @Class Date
    @Attribute time : String end
    @Attribute showTimeOfDay : Boolean end
  	
    @Constructor() 
      let 
        dateClass = xmf.javaClass("tool.helper.XDate")
      in 
        self.time := dateClass().getNow();
        self.showTimeOfDay := true
      end
    end
    
    @Constructor(year, month, day) 
      let 
        dateClass = xmf.javaClass("tool.helper.XDate")
      in 
        self.time := dateClass().getYearMonthDayHourMinuteSecond(year, month, day, 12, 0, 0);
        self.showTimeOfDay := false
      end
    end    
    
    @Constructor(year, month, day, hour, minute, second) 
      let 
        dateClass = xmf.javaClass("tool.helper.XDate")
      in 
        self.time := dateClass().getYearMonthDayHourMinuteSecond(year, month, day, hour, minute, second);
        self.showTimeOfDay := true
      end
    end
  	
    @Operation createDate(year, month, day):Date
      let
        d = Date();
        dateClass = xmf.javaClass("tool.helper.XDate")
      in
        d.time := dateClass().getYearMonthDayHourMinuteSecond(year, month, day, 12, 0, 0);
        d.showTimeOfDay := false;
        d
      end
    end
  	
    @Operation createDateAndTime(year, month, day, hour, minute, second):Date
      let
        d = Date();
        dateClass = xmf.javaClass("tool.helper.XDate")
      in
        d.time := dateClass().getYearMonthDayHourMinuteSecond(year, month, day, hour, minute, second);
        d.showTimeOfDay := true;
        d
      end
    end
    
    @Operation random(startYearInclusive:Integer, endYearExclusive:Integer):Date
      let 
        d = Date();
        dateClass = xmf.javaClass("tool.helper.XDate");
        years = endYearExclusive - startYearInclusive
      in
        d.time := dateClass().getYearMonthDayHourMinuteSecond(startYearInclusive, 1, 1, 12, 0, 0);
        d.showTimeOfDay := false;
        d.time := (d.time.asInt() + (Integer::random(365.2425*years) * 1000 * 24 * 60 * 60)).toString();
        d
      end
    end

    @Operation diff(other):String
      let 
        dateClass = xmf.javaClass("tool.helper.XDate")
      in 
        dateClass().getDifference(self.time, other.time)
      end
    end

    @Operation toString():String
      let 
        dateClass = xmf.javaClass("tool.helper.XDate")
      in
        if 
          self.showTimeOfDay
        then
          dateClass().printDate(self.time, "dd MMM yyyy HH:mm:ss")
        else
          dateClass().printDate(self.time, "dd MMM yyyy")
        end
      end
    end
    
    @Operation toParseableString():String
      let 
        dateHelper = (xmf.javaClass("tool.helper.XDate"))()
      then
        year   = dateHelper.getYear(self.time);
        month  = dateHelper.getMonth(self.time) + 1;
        day    = dateHelper.getDay(self.time);
        hour   = dateHelper.getHour(self.time);
        minute = dateHelper.getMinute(self.time);
        second = dateHelper.getSecond(self.time)
      in 
         if 
          self.showTimeOfDay
        then
          "Auxiliary::Date::createDateAndTime(" + year + ", " + month + ", " + day + ", " + hour + ", " + minute + ", " + second +")"
        else
          "Auxiliary::Date::createDate(" + year + ", " + month + ", " + day +")"
        end
      end
    end
    
    @Operation age():Integer
      let 
        dateClass = xmf.javaClass("tool.helper.XDate")
      in 
        dateClass().age(self.time)
      end
    end
  end
  
context Root
  @Operation testPath(max, o)
    let s = 0 in
      @For i in 0.to(max) do
        s := s + o.pathSeq().size()
      end;
      s
    end
  end
  
context Root
  @Operation test13()
    let
      p = FMMLx::FMMLxPackage("Test13");
      m = Clients::FmmlxDiagrams::FmmlxManipulator()
    then
      project = Projects::Project(p, "Test13Project", null)
    in
      p.addParent(FMML);
      p.fmmlxAssociationInstances:={};
      Root.add(p);
      
      m.addMetaClass(p,  "A", 13, [], false);
      m.addInstance(p, p::A, "B", [], false, []);
      m.addInstance(p, p::B, "C", [], false, []);
      m.addInstance(p, p::C, "D", [], false, []);
      m.addInstance(p, p::D, "E", [], false, []);
      m.addInstance(p, p::E, "F", [], false, []);
      m.addInstance(p, p::F, "G", [], false, []);
      m.addInstance(p, p::G, "H", [], false, []);
      m.addInstance(p, p::H, "I", [], false, []);
      m.addInstance(p, p::I, "J", [], false, []);
      m.addInstance(p, p::J, "K", [], false, []);/*
      m.addInstance(p, p::K, "L", [], false, []);
      m.addInstance(p, p::L, "M", [], false, []);
      m.addInstance(p, p::M, "N", [], false, []);*/

      "done"
    end
  end
    
Root::Auxiliary::eur := Root::Auxiliary::Currency("EUR", "EUR", 1.0);
Root::Auxiliary::usd := Root::Auxiliary::Currency("USD", "USD", 1.0);
Root::Auxiliary::aud := Root::Auxiliary::Currency("AUD", "AUD", 1.0);
Root::Auxiliary::nzd := Root::Auxiliary::Currency("NZD", "NZD", 1.0);
Root::Auxiliary::gbp := Root::Auxiliary::Currency("GBP", "GBP", 1.0);
Root::Auxiliary::sek := Root::Auxiliary::Currency("SEK", "SEK", 1.0);

Root::Auxiliary::maleNames := ["James","Robert","John","Michael","David","William","Richard","Joseph","Thomas","Christopher",
"Charles","Daniel","Matthew","Anthony","Mark","Donald","Steven","Andrew","Paul","Joshua","Kenneth","Kevin","Brian","George",
"Timothy","Ronald","Jason","Edward","Jeffrey","Ryan","Jacob","Gary","Nicholas","Eric","Jonathan","Stephen","Larry","Justin",
"Scott","Brandon","Benjamin","Samuel","Gregory","Alexander","Patrick","Frank","Raymond","Jack","Dennis","Jerry","Tyler","Aaron",
"Jose","Adam","Nathan","Henry","Zachary","Douglas","Peter","Kyle","Noah","Ethan","Jeremy","Walter","Christian","Keith","Roger",
"Terry","Austin","Sean","Gerald","Carl","Harold","Dylan","Arthur","Lawrence","Jordan","Jesse","Bryan","Billy","Bruce","Gabriel","Joe",
"Logan","Alan","Juan","Albert","Willie","Elijah","Wayne","Randy","Vincent","Mason","Roy","Ralph","Bobby","Russell","Bradley","Philip","Eugene"];

Root::Auxiliary::femaleNames := ["Mary","Patricia","Jennifer","Linda","Elizabeth","Barbara","Susan","Jessica","Sarah","Karen",
"Lisa","Nancy","Betty","Sandra","Margaret","Ashley","Kimberly","Emily","Donna","Michelle","Carol","Amanda","Melissa","Deborah",
"Stephanie","Dorothy","Rebecca","Sharon","Laura","Cynthia","Amy","Kathleen","Angela","Shirley","Brenda","Emma","Anna","Pamela",
"Nicole","Samantha","Katherine","Christine","Helen","Debra","Rachel","Carolyn","Janet","Maria","Catherine","Heather","Diane",
"Olivia","Julie","Joyce","Victoria","Ruth","Virginia","Lauren","Kelly","Christina","Joan","Evelyn","Judith","Andrea","Hannah",
"Megan","Cheryl","Jacqueline","Martha","Madison","Teresa","Gloria","Sara","Janice","Ann","Kathryn","Abigail","Sophia","Frances",
"Jean","Alice","Judy","Isabella","Julia","Grace","Amber","Denise","Danielle","Marilyn","Beverly","Charlotte","Natalie","Theresa",
"Diana","Brittany","Doris","Kayla","Alexis","Lori","Marie"];

Root::Auxiliary::surnames :=  ["Smith","Jones","Williams","Taylor","Brown","Davies","Evans","Wilson","Thomas","Johnson","Roberts",
"Robinson","Thompson","Wright","Walker","White","Edwards","Hughes","Green","Hall","Lewis","Harris","Clarke","Patel","Jackson","Wood",
"Turner","Martin","Cooper","Hill","Ward","Morris","Moore","Clark","Lee","King","Baker","Harrison","Morgan","Allen","James","Scott",
"Phillips","Watson","Davis","Parker","Price","Bennett","Young","Griffiths","Mitchell","Kelly","Cook","Carter","Richardson","Bailey",
"Collins","Bell","Shaw","Murphy","Miller","Cox","Richards","Khan","Marshall","Anderson","Simpson","Ellis","Adams","Singh","Begum",
"Wilkinson","Foster","Chapman","Powell","Webb","Rogers","Gray","Mason","Ali","Hunt","Hussain","Campbell","Matthews","Owen","Palmer",
"Holmes","Mills","Barnes","Knight","Lloyd","Butler","Russell","Barker","Fisher","Stevens","Jenkins","Murray","Dixon","Harvey"];


    
    