parserImport XOCL;
import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams
@Class Testing

@Attribute currentDiagram : Element end		//The Package for the diagram
@Attribute currentProject : Element end
@Attribute classes : Element end
@Attribute m : Clients::FmmlxDiagrams::FmmlxManipulator end
//@Attribute testDiagrams : Element end

//context Testing		//changend to be defined in operation as a bug fix
//@Attribute scenarios : Element end


//context Testing
@Operation setScenarios():XCore::Element
"Set Scenarios".println();

[
scenario1,
scenario2,
scenario3
]
end

@Operation startTest[monitor=false,delToClassAllowed=false]():XCore::Element
"Start Testing:".println();
	let
	scenarios = self.setScenarios();
      testDiagrams = [];
      dataTypes = Seq{Integer,String,Boolean,Float /*,MonetaryValue,Currency,Date*/};
      intValues = Seq{0,1,0 - 100,9999999999};
      stringValues = Seq{"","A","A1","#","A1#"};
      booleanValues = Seq{true,false};
      floatValues = Seq{1,0.1,1000000.0,0 - 100,0 - 111.111};
      dateValues = Seq{};
      assocSpecs =[];	//for testing only later replaced by manual entry via console or by reading a text file
      attrSpecs = [];
      consSpecs = [];
      classSpecs = [];
      deleSpecs = [];
      opSpecs = [];
      instSpecs = [];
      i = 0;
      i2 = 0
       in
	scenarios.println();
	
       @While i < scenarios.size() do
       "While scenarios".println();
        classSpecs:= scenarios.at(i).at(0);
	assocSpecs:= scenarios.at(i).at(1);
	attrSpecs:= scenarios.at(i).at(2);
	consSpecs:= scenarios.at(i).at(3);
	opSpecs:= scenarios.at(i).at(4);
	deleSpecs:= scenarios.at(i).at(5);
	instSpecs:= scenarios.at(i).at(6);
	self.setup(assocSpecs,attrSpecs,consSpecs,classSpecs,deleSpecs,opSpecs,instSpecs,dataTypes,intValues,stringValues,booleanValues,floatValues,dateValues);		
	testDiagrams := testDiagrams + Seq{self.currentDiagram}	;
	i:=i+1
	end;
	
	testDiagrams.println();
			@While i2 < testDiagrams.size() do
			self.currentDiagram := testDiagrams.at(i2);
			self.classes := currentDiagram.classes.asSeq()->select(c|c.isKindOf(FMMLx::MetaClass));			//Instanzen muessen hnzugefugt werden
			self.testOperations();
			i2:=i2+1
			end
			
	end	;
	"Ende".println()
end


@Operation setup[monitor=false,delToClassAllowed=false](assocSpecs,attrSpecs,consSpecs,classSpecs,deleSpecs,opSpecs,instSpecs,dataTypes,intValues,stringValues,booleanValues,floatValues,dateValues):XCore::Element

  self.currentDiagram := FMMLx::FmmlxPackage("Test"+1);	//naming should be done with index later on/Actually it will be hardcoded in the tests themselves
  self.currentDiagram.addParent(FMMLx);
  Root.add(currentDiagram);
  self.currentProject := Projects::Project(currentDiagram,"Test" + 1 + "Project",null);
  xmf.projectManager("MyProjects").add(currentProject);
  self.m := Clients::FmmlxDiagrams::FmmlxManipulator();
     self.classSetup(classSpecs);
     self.currentDiagram.classes.println();	//only for debug
       self.classes := currentDiagram.classes.asSeq()->select(c|c.isKindOf(FMMLx::MetaClass));		//Classes have to be created beforehand
     "=========".println();	//debug
 //    self.classes.println();		//only for debug
     self.attributeSetup(dataTypes,attrSpecs);
     self.associationSetup(assocSpecs);
     self.delegationSetup(deleSpecs);
     self.operationSetup(opSpecs);
     self.constraintSetup(consSpecs);
     self.instanceSetup(instSpecs);	//[[name,classLvl,aLvl,skipNumberOfClasses,numberOfClasses,numInstances,valueList,abstract,singleton]]
     self.classes := currentDiagram.classes.asSeq()->select(c|c.isKindOf(FMMLx::MetaClass))			//Instaces are added but not those on level 0 because those are not classes
     
end


@Operation getClassesAndObjects(c):XCore::Element	//Returns every class and instance of a package including those on level 0
let currentObjects = c.asSeq(); result=c.asSeq(); i=0 in
	@While currentObjects.size()>i do
	if currentObjects.at(i).level.minLevel > 0 then
	result := result.asSeq() + self.getClassesAndObjects(currentObjects.at(i).allInstances()).asSeq()
	end;
	i:=i+1
	end;
	result.asSet()
end
end


@Operation validateModel[monitor=false,delToClassAllowed=false]():XCore::Element		//check if any constrains are broken with Daniels method
"Validate Test:".println();
	let i = 0; checkOutput = null in
		@While i < classes.size()  do
		checkOutput := classes.at(i).checkConstraints().edit();
		checkOutput.println();
		i:=i+1
		end
	end
end


@Operation testOperations[monitor=false,delToClassAllowed=false]():XCore::Element		//After the creation of the test Diagram these operations are tested

	try
	"Class Creation Test1".println();
	m.addMetaClass(currentDiagram,"ClassCreationTestClass",FMMLx::Level(1,1),Set{},false,false)
	catch(e) 
	"Exception caught:".println();
	e.println()
	end;

	try
	"Class Name Change Test 1".println();
	self.nameChangeClassTest()
	catch(e) 
	"Exception caught:".println();
	e.println()
	end;
	
	try
	"Create Instance Test 1 (Singleton)".println();
	self.createInstanceTest1()
	catch(e) 
	"Exception caught:".println();
	e.println()
	end;
	
		try
	"Create Instance Test 2 (Singleton Forced)".println();
	self.createInstanceTest1()
	catch(e) 
	"Exception caught:".println();
	e.println()
	end;
	
		try
	"Create Instance Test 3".println();
	self.createInstanceTest3()
	catch(e) 
	"Exception caught:".println();
	e.println()
	end;
	
	try
	"Class removal Test 1".println();
	self.removeClassTest()
	catch(e) 
	"Exception caught:".println();
	e.println()
	end
end


@Operation nameChangeClassTest[monitor=false,delToClassAllowed=false]():XCore::Element	//for now simple but can be extenden in the future
	let diagramCopy = currentDiagram in
		self.m.changeClassName(classes.at(0),classes.at(1).name);		//tries to assign a duplicate name, should trigger an exception
		validateModel();
		currentDiagram = diagramCopy		//reset Diagram to previous state
	end
end


@Operation createInstanceTest1[monitor=false,delToClassAllowed=false]():XCore::Element	//for now simple but can be extenden in the future
	let diagramCopy = currentDiagram; ofClass = classes->select(c|c.level.minLevel>1 and c.singleton <> false) in	//ofClass has to be changend between tests depending on what has to be tested
		if classes->select(c|c.level.minLevel>0) then	//creates two instances of a singleton, should trigger exception
		self.m.addInstance(self.currentDiagram,ofClass,"singletonTest1",FMMLx::Level(ofClass.level.minLevel-1),Set{},false,false,[]);
		self.m.addInstance(self.currentDiagram,ofClass,"singletonTest2",FMMLx::Level(ofClass.level.minLevel-1),Set{},false,false,[]);	
		validateModel();
		currentDiagram = diagramCopy		//reset Diagram to previous state
		end
	end
end


@Operation createInstanceTest1[monitor=false,delToClassAllowed=false]():XCore::Element	//for now simple but can be extenden in the future
	let diagramCopy = currentDiagram; ofClass = classes->select(c|c.level.minLevel>1 and c.singleton <> false) in	//ofClass has to be changend between tests depending on what has to be tested
		if classes->select(c|c.level.minLevel>0) then	//creates two instances of a singleton, should trigger exception
		self.m.addInstance(self.currentDiagram,ofClass,"singletonTest1",FMMLx::Level(ofClass.level.minLevel-1),Set{},false,false,[]);
		try
		self.m.addInstance(self.currentDiagram,ofClass,"singletonTest2",FMMLx::Level(ofClass.level.minLevel-1),Set{},false,false,[])	
		catch(e)
				self.m.addInstance(self.currentDiagram,ofClass,"singletonTest2",FMMLx::Level(ofClass.level.minLevel-1),Set{},false,false,[])
		end;
		validateModel();
		currentDiagram = diagramCopy		//reset Diagram to previous state
		end
	end
end


@Operation createInstanceTest3[monitor=false,delToClassAllowed=false]():XCore::Element	//for now simple but can be extenden in the future
	let diagramCopy = currentDiagram; ofClass = classes->select(c|c.level.minLevel>1 and c.singleton <> true) in	//ofClass has to be changend between tests depending on what has to be tested
		if classes->select(c|c.level.minLevel>0) then	//creates one instance of a class (min. level 1) which is not a singleton, should not trigger exception
		self.m.addInstance(self.currentDiagram,ofClass,"simpleInstanceTest",FMMLx::Level(ofClass.level.minLevel-1),Set{},false,false,[]);
		validateModel();
		currentDiagram = diagramCopy		//reset Diagram to previous state
		end
	end
end


@Operation removeClassTest[monitor=false,delToClassAllowed=false]():XCore::Element	//for now simple but can be extenden in the future
	let diagramCopy = currentDiagram in
		self.m.removeClass(classes.at(0),null);	//strategy parameter never used
		validateModel();
		currentDiagram = diagramCopy		//reset Diagram to previous state
	end
end


@Operation classSetup[monitor=false,delToClassAllowed=false](classSpecs : XCore::Element):XCore::Element
@Doc
creates the Classes for the Diagram. Specs are formated as follows:
[[name,lvlMin,lvlMax,abstract,numberOfClasses,singleton]]
end
	let i=0;i2=0
	in
		@While i < classSpecs.size() do
		i2:=0;
			@While i2<classSpecs.at(i).at(4) do
			let lvl = FMMLx::Level(classSpecs.at(i).at(1),classSpecs.at(i).at(2)) in
			self.createClass(classSpecs.at(i).at(0)+i+"_"+i2, lvl, classSpecs.at(i).at(3),classSpecs.at(i).at(5));
			i2:=i2+1
			end
			end;
		i:=i+1
		end
	end
end


@Operation createClass[monitor=false,delToClassAllowed=false](name : XCore::Element,lvl : XCore::Element,abstract, singleton):XCore::Element
m.addMetaClass(currentDiagram,name,lvl,Set{},abstract,singleton)
end


@Operation constraintSetup[monitor=false,delToClassAllowed=false](consSpecs):XCore::Element
@Doc
consSpecs is formated as follows:
[[name,code,reason,lvl,numberOfConstraints,skipClasses]]
end
	let i=0;i2=0
	in
		@While i < consSpecs.size() do
		i2:=consSpecs.at(i).at(5);
			@While i2<consSpecs.at(i).at(4) do
			self.addConstraint(classes.at(i2),consSpecs.at(i).at(0)+i+"_"+i2,consSpecs.at(i).at(1),consSpecs.at(i).at(2),FMMLx::Level(consSpecs.at(i).at(3)));
			i2:=i2+1
			end;
		i:=i+1
		end
	end
end


@Operation addConstraint[monitor=false,delToClassAllowed=false](class,name,code,reason,lvl):XCore::Element
m.addConstraint(class,name,code,reason,lvl,null,"solutionKey")
end

 
@Operation associationSetup[monitor=false,delToClassAllowed=false](assocSpecs):XCore::Element
@Doc
This method creates the associations according to the specs from assocSpecs.
assocSpecs is a seq which contains seq with the specs for the different Associations. It is formatted like this:
 [[name,multSource,multTarget,instLvlS,instLvlT,visibleFromS,visibleFromT,symmetric,transitive,createItBetweenThisManyClasses,skipTheFirstThisManyClasses]]
end
	let i=0;i2=0
	in
		@While i<assocSpecs.size() do 
		i2:=assocSpecs.at(i).at(10);
			@While i2<assocSpecs.at(i).at(9) and i2<classes.size()-1 do	//-1 because one class is not enough to create another association
			self.addAssociation(classes.at(i2),classes.at(i2+1),assocSpecs.at(i).at(1),assocSpecs.at(i).at(2),assocSpecs.at(i).at(0)+i+"_"+i2,assocSpecs.at(i).at(3),assocSpecs.at(i).at(4),assocSpecs.at(i).at(5),assocSpecs.at(i).at(6),assocSpecs.at(i).at(7),assocSpecs.at(i).at(8));
			i2:=i2+2
			end;
		i:=i+1
		end
	end
end


@Operation addAssociation[monitor=false,delToClassAllowed=false](
	source,
	target,
	multS,
	multT,
	name,
	instLvlS,
	instLvlT,
	visibleFromS,
	visibleFromT,
	symmetric,
	transitive
	):XCore::Element
		m.addAssociation(currentDiagram,source,target,name+source.name,name+target.name,name,Associations::DefaultAssociation,multS,multT,FMMLx::Level(instLvlS),FMMLx::Level(instLvlT),visibleFromT,visibleFromS,symmetric,transitive)
end


@Operation delegationSetup[monitor=false,delToClassAllowed=false](deleSpecs):XCore::Element
@Doc
This function creates Delegations between two classes. The selection is for now random and only filter out classes of a different level from the role filler.
deleSpecs is formated as follows:
[[minLevel,maxLevel,skipThisNumberOfClasses,numberOfDelegations]]
end
	let i = 0
	in
		@While i < deleSpecs.size() do
			let classesD = self.classes->reject(c | c.level.minLevel <> deleSpecs.at(i).at(0) and c.level.maxLevel <> deleSpecs.at(i).at(1));i2=deleSpecs.at(i).at(2) in	
				@While i2 < deleSpecs.at(i).at(3)+deleSpecs.at(i).at(2) and i2 < classesD.size()-1 do		//-1 cause at least two classes are always needed (see Associations as well)
				self.addDelegation(classesD.at(i2),classesD.at(i2 + 1),FMMLx::Level(deleSpecs.at(i).at(0)-1));	//-1 on level because 
				i2 := i2 + 2
				end
			end;
		i := i + 1
		end
	end
end 


@Operation addDelegation[monitor=false,delToClassAllowed=false](filler : XCore::Element,role : XCore::Element,lvl : XCore::Element):XCore::Element
  m.setDelegation(filler,role,lvl)
end


@Operation attributeSetup[monitor=false,delToClassAllowed=false](dataTypes : XCore::Element,attrSpecs : XCore::Element):XCore::Element
@Doc
attrSpecs define what attributes to add and is formed as follows:
[[name,createItBetweenThisManyClasses,skipTheFirstThisManyClasses,type,lvl,mult,isIncomplete,isOptional]]
type is Integer and refers to an  index of the dataTypes Sequence
end
	let mult = Multiplicities::SingleMult(false); i = 0; i2 = 0
	in
		@While i < attrSpecs.size() do
		i2:=attrSpecs.at(i).at(2);
			@While i2 < attrSpecs.at(i).at(1)+attrSpecs.at(i).at(2) and i2<classes.size() do
			self.addAttribute(classes.at(i2),attrSpecs.at(i).at(0)+i+"_"+i2, attrSpecs.at(i).at(4),dataTypes.at(attrSpecs.at(i).at(3)),attrSpecs.at(i).at(5),attrSpecs.at(i).at(6),attrSpecs.at(i).at(7));
			i2 := i2 + 1
			end;	
		i := i + 1
		end
	end
end


@Operation addAttribute[monitor=false,delToClassAllowed=false](class : XCore::Element,name : XCore::Element,lvl : XCore::Element,type : XCore::Element,mult : XCore::Element,isIncomplete,isOptional):XCore::Element
m.addAttribute(class,name,FMMLx::Level(lvl),type,mult, isIncomplete, isOptional)
end


@Operation operationSetup[monitor=false,delToClassAllowed=false](opSpecs):XCore::Element
@Doc
Generates operations according to parameters in opSpecs which is formated as follows:
[[lvlOfClass,lvlOfOperation,body1,body2,skipNumberOfClasses,numberOfOperations]]
Parameter body is seperated into two parts so that names can be assigned dynamically to the different operations.
end
	let i = 0
	in
		@While i < opSpecs.size() do
			let i2 = opSpecs.at(i).at(4); classesOp = classes -> reject(c | c.level.minLevel <> opSpecs.at(i).at(0)) in
				@While i2 < opSpecs.at(i).at(5) + opSpecs.at(i).at(4) and i2 < classesOp.size() do
				self.addOperation(classesOp.at(i2),FMMLx::Level(opSpecs.at(i).at(1)),opSpecs.at(i).at(2)+i+"_"+i2+opSpecs.at(i).at(3));	//body gets merged again with the numbers added to the name
				i2:=i2+1
				end
			end;
		i:=i+1
		end
	end
end


@Operation addOperation[monitor=false,delToClassAllowed=false](class : XCore::Element,lvl : XCore::Element,opString : XCore::Element):XCore::Element
m.addOperation(class,lvl,opString)
end 


@Operation instanceSetup[monitor=false,delToClassAllowed=false](instSpecs):XCore::Element
@Doc
instSpecs are formated as follows:
[[name,classLvl,aLvl,skipNumberOfClasses,numberOfClasses,numberOfINstances,valueList,abstract,singleton]]
numberOfClasses is of how many classes instances will be generated and numberOfInstances is the number of Instance which will be created per class.
end
	let i = 0
	in
		@While i < instSpecs.size() do
			let i2=instSpecs.at(i).at(3); instClasses = self.classes->reject(c | c.level.minLevel <> instSpecs.at(i).at(1)) in
				@While i2 < instSpecs.at(i).at(4)+instSpecs.at(i).at(3) and i2 < instClasses.size() do
				self.addInstance1(instClasses.at(i2),instSpecs.at(i).at(0) + i + "_" + i2,instSpecs.at(i).at(2),instSpecs.at(i).at(7),instSpecs.at(i).at(8),instSpecs.at(i).at(6));				//slot value list ist immer [name,wert] wobei name der name einer variable ist
			//	"Instanz Erstellt".println();
				i2 := i2 + 1
				end
			end;
		i := i + 1
		end
	end
end 


@Operation addInstance1[monitor=false,delToClassAllowed=false](class : XCore::Element,name : XCore::Element,aLevel : XCore::Element,abstract,singleton,values : XCore::Element):XCore::Element
m.addInstance(self.currentDiagram,class,name,FMMLx::Level(aLevel),Set{},abstract,singleton,values)
end

/*
@Operation associationInstanceSetup(assocInstSpecs)XCore::Element
@Doc
assocInstSpecs specifies how to instantiate an association as follows:
[[assocNumber,skipNumberOfClasses,createThisMany]]	AssocNumber is the index of the association in currentDiagram.associations
end
	let i = 0;i2 = 0; associations = currentDiagram.classes->select(c|c.isKindOf(FMMLxMetaClass)->collect(c|c.attributes)->flatten->select(a|a.isKindOf(Associations::End))->collect(e|e.associations).asSeq()
	 in
		@While i < assocInstSpecs.size() do
		i2 := 0;
				let availableClasses = classes->select(c|c.kindOf(FMMLx::MetaClass)<>) in		//Klassen mit falschem level muessen rausgefiltert werden JEWEILS f√ºr start und end inst lvl
			@While i2 < assocInstSpecs.at(2) and i2 < assocInstClasses.size()	//alle Associations per package.classes->select(c|c.isKindOf(FMMLxMetaClass)->collect(c|c.attributes)->flatten->select(a|a.isKindOf(Associations::End))->collect(e|e.associations);
			
			self.addAssociationInstance()
			end
		end
	end
end */


@Operation addAssociationInstance(obj1,obj2,assocName):XCore::Element
m.addAssociationInstance(currentDiagram,obj1,obj2,assocName)
end


end