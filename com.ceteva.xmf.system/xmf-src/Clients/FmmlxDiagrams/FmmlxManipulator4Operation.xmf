parserImport XOCL;

import Clients;
import FmmlxDiagrams;
      
  context FmmlxManipulator
    @Operation checkAddOperation(class, opName, level, body)
      []
    end
    
  context FmmlxManipulator 
    @Operation addOperation(class, opName, level, returnType, opString)
      let
        problems = [];
        opAS = null;
        opASfun = null;
        operation = null
      in 
        // first parse
        opAS := try [OCL::OCL.grammar.parseString(opString,"Exp1",Seq{XOCL}),null] catch(exception) [null,[exception.message]] end;

        // then compile
        if 
          opAS.at(0) <> null 
        then 
          opASfun := try [Compiler::compileToFun("",opAS.at(0),Seq{},Seq{Seq{2|Root.contents},Seq{2|XCore.contents}},true),null] catch(exception) [null,[exception.message]] end
        else
          opASfun := opAS
        end;

        // create an instance of the operation
        if 
          opASfun.at(0) <> null
        then 
          operation := try [(opASfun.at(0))(),null] catch(exception) [null,[exception.message]] end
        else
          operation := opASfun
        end;
        
        // check if the operation is allowed to be added
        if
          operation.at(0) <> null
        then 
          operation.at(0).isIntrinsic := true;
          operation.at(0).instLevel := level;
          problems := self.checkOperationAllowed(
                           class, 
                           operation.at(0).name.toString(), 
                           operation.at(0).arity, 
                           operation.at(0).isIntrinsic, 
                           level, 
                           FmmlxDiagramClient::isOperationMonitored(operation.at(0)), 
                           [])
        else
          problems := operation.at(1) 
        end;

        // if no problem, then add now
        if 
          problems.isEmpty() andthen operation.at(0) <> null
        then 
          class.addOperation(operation.at(0))
        end;
        
        // return any problem that occurred
        problems
      end 
    end
    
  context FmmlxManipulator        
    @Operation changeOperationName(class, oldName, newName)
      // for now assume that changeOperationName did not return any trouble
      let
        operation = self.findOperation(class, oldName)
      in        
        operation.name := newName.asSymbol();
        null
      end
    end
    
  context FmmlxManipulator 
    @Operation findOperation(class, name) 
      let
        operation = null
      in
        @For o in class.operations do
          if o.name.toString() = name then
            operation := o
          end
        end;
        operation
      end
    end
    
  context FmmlxManipulator
    @Operation changeOperationLevel(class, operation, newLevel, isMonitored)
      let 
//        operation = self.findOperation(class, name)
//      then
        problems = self.checkOperationAllowed(class, operation.name.toString(), operation.arity, operation.isIntrinsic, newLevel, isMonitored, [operation])
      in 
        if
          problems.isEmpty() and operation.isIntrinsic 
        then 
          operation.instLevel := newLevel; []
        else
          problems
        end
      end
    end
       
  context FmmlxManipulator
    @Operation checkOperationAllowed(class, name, arity, isIntrinsic, instLevel, monitor, ignoreList)
       
      let
        problems = [];
        operations = class.allOperations().asSet() + class.allOperations2().asSet()
      in
        if not isIntrinsic 
          then problems := problems + ["Operation must be intrinsic to change the level."] end;
        if arity <> 0 and monitor = true 
          then problems := problems + ["Monitored Operation must have an arity of zero."] end;
        // First: Check whether the new operation would interfere with an existing one.
        @For operation in operations do
          if operation.name.toString() = name.toString() and not ignoreList.contains(operation) then
            // and arity equal and level equal...
            // But for now no duplicate names at all
            problems := problems + ["Operation " + name + " already exists in " + class.name + "."]
          end
        end; // done with conflicts from classes from above.
        @For instance in class.allMetaInstances() do  // check all instances which could be affected
          let theirOperations = instance.allOperations().asSet() + instance.allOperations2().asSet()
          in
            @For operation in theirOperations do
              if operation.name.toString() = name.toString() and not ignoreList.contains(operation) then
                // and arity equal and level equal...
                // But for now no duplicate names at all
                problems := problems + ["Operation " + name + " already exists in " + class.name + "."]
              end // if
            end // for
          end // let
        end; // for
        problems
      end // let
    end
    
  context FmmlxManipulator        
    @Operation checkChangeOperationName(class, oldName, newName)
      let
        operation = null;
        problems = []
      in
		@For o in class.operations do
		  if o.name.toString() = oldName then
		    operation := o
		  end;
		  if o.name.toString() = newName then
		    problems := problems + ["Operation " + newName + " already exists in " + class.name + "."]
		  end
		end;
		if operation = null then problems := problems + ["Operation " + oldName + " not found in " + class.name + "."] 
		end
		// add further tests here...
		// todo: check parent and of classes...
      ;problems
      end
    end