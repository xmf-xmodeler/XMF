parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramMapping

    @Attribute mapping : Set = {} end
    @Attribute labelMapping : Set = {} end
    @Attribute nextID : Integer = 0 end
    
    @Operation addOrGetObjectMapping(oid : String)
      if not oid.of() = String then throw Exception("id not String") end;
      let 
        foundMapping = null 
      in 
        @For mappingInfo in mapping do
          if mappingInfo.id = oid
          then foundMapping := mappingInfo
          end // if
        end; // for
        if foundMapping <> null
        then 
          foundMapping
        else
          let 
            newMappingInfo = MappingInfo()
          in
            //newMappingInfo.object := o;
            newMappingInfo.id := oid;//if o.isKindOf(Symbol) then o.toString() else o.path() end;
            newMappingInfo.lastKnownDiagramX := 0;
            newMappingInfo.lastKnownDiagramY := 0;
            newMappingInfo.hidden := true;
            newMappingInfo.points := null;
            self.mapping := self.mapping + {newMappingInfo};
            newMappingInfo
          end // let
        end // if 
      end // let 
    end
    
    /*@Operation getMappingId(oid)
      let 
        foundMapping = null 
      in 
        @For mappingInfo in mapping do
          if mappingInfo.id = oid
          then foundMapping := mappingInfo
          end // if
        end; // for
        if foundMapping <> null
        then 
          foundMapping.id
        else
          null
        end // if 
      end // let 
    end*/
    
    @Operation setNewPosition(objectID, x, y, hidden)
      //("mapping.size:" + mapping.size()).println();
      //("mapping.id:" + mapping.id).println();
      let 
        mappingInfo = self.addOrGetObjectMapping(objectID) //if mapping.id.contains(objectID)
          //then mapping->select(m | m.id = objectID).asSeq().at(0)
          //else self.addOrGetObjectMapping(objectID) end
      in    
      //if not mapping.id.contains
      //@For mappingInfo in mapping do
        //("Compare " + objectID + " to " + mappingInfo.id).println();
        //if mappingInfo.id = objectID
        //then
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y;
          mappingInfo.hidden := hidden;
          mappingInfo.points := null
        //end // if
      //end // for
      end
    end
    
    @Operation setNewPositions(objectID, listOfPoints)
      let 
        mappingInfo = self.addOrGetObjectMapping(objectID)
      in   
          mappingInfo.points := listOfPoints.asSeq();
          
          mappingInfo.lastKnownDiagramX := null;
          mappingInfo.lastKnownDiagramY := null;
          mappingInfo.hidden := null;
          
          @For i in 0.to(mappingInfo.points.size()-1) do mappingInfo.points := mappingInfo.points.replaceAt(i, mappingInfo.points.at(i).asSeq()) end          
      end
    end
    
    @Operation getMapping(objectID) 
      let result = null in 
        @For mappingInfo in mapping do
          if mappingInfo.id = objectID.toString()
          then 
            result := mappingInfo
          end // if
        end; // for
        result
      end //let
    end
    
    //self.getMapping(requestID).updateKey(oldPath, class.path());
    @Operation updateKey(oldKey, newKey)
      let 
        item = self.getMapping(oldKey.toString());
        testForNewKey = self.getMapping(newKey.toString())
      in
        if 
          item <> null andthen testForNewKey = null
        then 
          item.id := newKey//if o.isKindOf(Symbol) then o.toString() else o.path() end
        else
          null//throw(Exception("Cannot change key. Either oldKey does not exist or newKey already exists."))
        end
      end
          
    end
    
    @Operation cleanUpMapping() null end
    
    @Operation storeLabelInfo(edgeID, localID, x, y)
      let 
        foundMapping = null 
      in 
        @For mappingInfo in labelMapping do
          if mappingInfo.at(0) = edgeID andthen mappingInfo.at(1) = localID
          then foundMapping := mappingInfo
          end // if
        end; // for
        
        if foundMapping = null orelse foundMapping.at(2) <> x orelse foundMapping.at(3) <> y then // new or changed 
          if foundMapping <> null then // if changed, remove old
            self.labelMapping := self.labelMapping.excluding(foundMapping)
          end;
          
          // create a new mapping
          foundMapping := [edgeID, localID, x, y];
          self.labelMapping := self.labelMapping.including(foundMapping)
        end // done updating
      end // let 
    end
    
    @Operation getAllLabels(edgeID)
      let 
        result = []
      in
        @For mappingInfo in labelMapping do
          if mappingInfo.at(0) = edgeID
          then result := result + [mappingInfo]
          end // if
        end; // for
        result
      end 
    end
    
    @Operation createDelegationKey(delegatesFrom, delegatesTo) ("DelegationMapping: "+delegatesFrom+"/"+delegatesTo) end
    @Operation createInheritanceKey(child, parent)             ("InheritanceMapping: "+child+"/"+parent) end
    @Operation createAssociationKey(assoc)                     assoc.getID() end
    @Operation createAssociationLinkKey(end1, end2, assoc)     ("AssociationLinkMapping: "+end1+"/"+end2+"/"+assoc) end
    @Operation createRoleKey(role, roleFiller)                 ("RoleFillerMapping: "+role+"/"+roleFiller) end
    
end // Class
