parserImport XOCL;

import Clients;
import FmmlxDiagrams;

  context FmmlxManipulator
    @Operation addMetaClass(package, name, level, parents, abstract, singleton)
      let singletonParents = parents->select(c | c.isSingleton) in 
        if singletonParents.size() > 0 then self.error(singletonParents.name + " cannot be superclasses as they are singletons.") end end;
      let 
        newClass = FMMLx::MetaClass(name, level)
      in
        package.add(newClass);
        newClass.isAbstract := abstract;
        newClass.isSingleton := singleton; 
        if parents.size() > 0 then newClass.parents := parents.asSet() end;

        @For parent in newClass.parents do
          if parent.isKindOf(FMMLx::MetaClass) then
            parent.subclasses := parent.subclasses + {newClass}
          end
        end;

        newClass
      end    
    end
  
    /* This operation creates a new instance. According to the attributes from its classes & parents & etc, 
     all slots need to be created. If the multiplicity of the slot mandates, a value needs to be acquired, either default or otherwise.
     For Associations, multiplicity must be checked as well.
     
     The following operation assumes the former to have been checked. 
     Until proving the mandatory slots has been taken care of, all slots will be simply initiated with null.
     */
         
  context FmmlxManipulator
    @Operation addInstance(
      package : Package, 
      ofClass : MetaClass, 
      name, 
      myLevel,
      parents, 
      abstract : Boolean,
      singleton : Boolean,
      slotValueList: Seq(Seq(String))):Object
      
      //("Trying to instantiate " + ofClass.name + " on level " + ofClass.level.toString() + " to level " + myLevel.toString()).println();
      if ofClass.isSingleton andthen ofClass.allInstances().size() > 0 then self.error("Class " + ofClass.name + " is a Singleton") end;
      let singletonParents = parents->select(c | c.isSingleton) in 
        if singletonParents.size() > 0 then self.error(singletonParents.name + " cannot be superclasses as they are singletons.") end end;

      // The following seems to be trivial, but better check once more
      if not ofClass.isKindOf(FMMLx::MetaClass) then self.error("Class " + ofClass.name + " is not an Fmmlx Class") end;
      if (ofClass.level.minLevel < 1/* andthen ofClass.level <> -1*/) then self.error("Level " + ofClass.level + " does not allow instantiation.") end;
      if not Symbol(name).isValidName()  then self.error("name " + name + " not legal.") end;
      
	  // We instantiate a new object "obj", whereas the class is "ofClass". Therefore: obj.of() is equal to ofClass
      let 
          // create new Object
        obj = Kernel_mkObj(); 
          // We prepare a set of all Attributes from the class and (NO) a set of all Operations
          // !!! This needs to be changed to fit its purpose here.
          // !!! We need a list of all Attributes which are to be instantiated here.
        A = ofClass.allAttributes()
      in
        Kernel_setOf(obj,ofClass); // Now we set obj.of():=ofClass
      
         // Then we loop through the Attributes
        @While not A->isEmpty do
          let a = A->sel // pick any one Attribute
          in if a.isIntrinsic andthen a.instLevel.minLevel < myLevel.minLevel
             then // 
               null//intrinsicA := intrinsicA.including(a)
             else // otherwise it becomes a slot and is initialised
               if a.init <> null
               then
                 Kernel_addAtt(obj,a.name,a.init.invoke(obj,Seq{}))
               else
                 Kernel_addAtt(obj,a.name,a.type.default())
               end;
               if a.hasProperty("visibility") then Kernel_setSlotVisibility(obj,a.name,a.visibility) end
             end;
             A := A->excluding(a) // we remove that attribute from the list as it has been handled
          end
        end;
           
        obj.level := myLevel;
        obj.setName(Symbol(name)); // todo: test name
        
        // copying the default super-classes and setting the initial superclasses.
        // skip for level = 0
        
        if obj.level.minLevel > 0 then 
          if ofClass.inheritsFrom(Classifier) then
            obj.parents := obj.defaultParents()
          else
            false
          end;

	      if parents.size() > 0 then obj.parents := parents.asSet() end;

	      @For p in obj.parents do
	        if p.isKindOf(FMMLx::MetaClass) then
	          p.subclasses := p.subclasses + {obj}
	        end
  	      end

        end;
                
        obj.init();
        
        ofClass.instances := ofClass.instances.including(obj);
        
        // todo: name, parents, abstract ...
        
        if obj.level.minLevel > 1 then // it's a metaclass, therefore its instances are classes
          package.add(obj);
          obj.isSingleton := singleton; 
          obj.isAbstract := abstract; 
          obj.addParent(FMMLx::MetaClass)
        end;
        if obj.level.minLevel = 1 then // it's a simple class, therefore its instances are not classes
          package.add(obj);
          obj.isSingleton := singleton; 
          obj.isAbstract := abstract;
          obj.addParent(FMMLx::FmmlxObject)
        end; 
        if obj.level.minLevel = 0 then //  it's not a class at all, and parent and abstract do not apply
          // However, package.add does not add the object to the list of classes and it has to be done manually
          // Hopefully that has no side effects as the list of classes will contain non-classes
          // Alternatively, a second list for non-classes would be needed.
          package.addClass(obj);
          package.add(obj)
        end;        
        
        // set initial slot values where supplied

        @For pair in slotValueList do
          let
            pairSeq = FmmlxDiagramClient::vector2Seq(pair)
          then
            slotName = pairSeq.at(0);
            slotValueExpr = pairSeq.at(1)
          then
            foundAtt = self.findAttributeForSlot(obj, slotName)
          then
            requiredType = if foundAtt <> null then foundAtt.type else Element end;
            parseResult = self.evalString(slotValueExpr, package)
          in
            if parseResult.at(1) = null andthen foundAtt <> null then
              if obj.hasSlot(slotName) then
                self.changeSlotValue(obj, slotName, parseResult.at(0), requiredType, package)
              end
            end
          end
        end;       
        obj
      end
    end
    
  context FmmlxManipulator
    @Operation changeClassName(class, newName)
      let 
        package = class.owner;
        oldName = class.name
      in
        if
          package.hasElement(newName)
        then
          xmf.error(newName + " already in use in " + package)
        else
          if
            newName.isValidName() 
          then
            class.name := newName.asSymbol();
            package.nameChanged(class,class.name,oldName)
          else
            xmf.error(newName + " is not a valid name")
          end
        end
      end;
      null
    end
    
    
  context FmmlxManipulator
    @Operation changeClassLevel(class, newLevel)
      if not class.isKindOf(FMMLx::MetaClass) then throw Exception("Only instances of FMMLx::MetaClass can have their level changed.") end;
      if class.level.minLevel < 2 then throw Exception("Objects lower than level 2 cannot have their level changed.") end;
      if not class.allInstances()->forAll(inst | newLevel.canBeInstantiatatedTo(inst.level)) then throw Exception("One of the instances does not match the new level") end;
      if not newLevel.isValidForObject() then throw Exception("The new level is not valid") end;
      class.level := newLevel;
      null
    end
    
  context FmmlxManipulator
    @Operation removeClass(class, strategy)
      //("before let").println(); keine Ahnung wofuer das ist aber das stoert beim testen
      let 
        package = class.owner;
        associations = [];
        heirs = [];
        instances = [];
        links = [];
        ofClass = class.of()
      in
        ("remove Class "+class.name+" start").println();
        if class.name.toString().equals("foo") then foo() end;

      // remove the instances
        @For instance in package.classes do
          if instance.of() = class then
            instances := instances + [instance] end end;
        //("found "+instances.size()+" instances").println();
        @For instance in instances do
          self.removeClass(instance, strategy) end;
          
                // remove the associations first
        @For association in package.associations do
          if association.end1.type = class or association.end2.type = class then
            associations := associations + [association] end end;
//        ("found "+associations.size()+" associations").println();
        @For association in associations do
            self.removeAssociation(association) end;
            
//        ("associations removed").println();

      // remove all links
        @For link in package.fmmlxAssociationInstances do
          if link.at(0) = class then links := links + [link] end;
          if link.at(1) = class then links := links + [link] end
        end;
        @For link in links do
          package.removeAssociationInstance(link.at(0), link.at(1), link.at(2)) 
        end;        
if class.isKindOf(FMMLx::MetaClass) then 
      // remove all inheritance in the subclasses
        @For heir in package.classes->select(h | h.isKindOf(FMMLx::MetaClass)) do
          if heir.parents.contains(class) then
            heirs := heirs + [heir] end end;
//        ("found "+heirs.size()+" heirs").println();
        @For heir in heirs do
          self.removeParent(heir, class) end;
//        ("inheritance removed").println();

      // remove all inheritance in the superclasses
        let parents = {} + class.parents in // avoid concurrent modification
          @For parent in parents do
            self.removeParent(class, parent)
          end
        end;
          

          
          
        @For delegator in package.classes
          ->select(d | d.isKindOf(FMMLx::MetaClass))
          ->select(d | d.delegatesTo = class) do 
          self.removeDelegation(delegator) end
end; // only if class

        @For role in package.classes
        ->select(r | r.isKindOf(FMMLx::FmmlxObject))
        ->select(r | r.roleFiller = class) do
        r.roleFiller := null end;

      // remove class
"removing Start".println();
        if 
          class.isKindOf(Class) 
        then 

"of Class".println();
          package.remove(class)
        else // As package.removeClass(...) is meant for classes, it does not work properly for non-classes
             // instead it's done manually.

"not of Class".println();
          package.remove(class);          
          package.removeClass(class)
        end;
        
        ofClass.instances := ofClass.instances.excluding(class)
        ;("class removed").println()
      end
    end
  
  context FmmlxManipulator  
    @Operation addParent(heir, parent)
      if parent.level.minLevel <> heir.level.minLevel orelse parent.level.maxLevel <> heir.level.maxLevel then ["Only classes from the same level may inherit from each other."]
      // Check for circular inheritance
      elseif 
        parent.isDescendantOf(heir) then [parent.name + " is already descendant of " + heir.name + ". Circular inheritance not allowed."] 
      elseif
        parent.isSingleton then ["Singleton class " + parent.name + " cannot be superclass."] 
      else
        let 
          problems = []
        in
          @For pAtt in parent.allAttributes() do
            @For hAtt in heir.allAttributes() do
              if 
                pAtt.name = hAtt.name andthen pAtt.owner <> hAtt.owner andthen pAtt.owner.isKindOf(FMMLx::MetaClass)
              then 
                problems := problems + ["Attribute collision. The name \"" + pAtt.name + "\" is present in both "+pAtt.owner.name+" and "+hAtt.owner.name +"."]
              end end end;
          @For pOp in parent.allOperations2() do
            @For hOp in heir.allOperations2() do
              if 
                pOp.name = hOp.name andthen pOp.owner <> hOp.owner andthen pOp.owner.isKindOf(FMMLx::MetaClass) 
              then 
                problems := problems + ["Operation collision. The name \"" + pOp.name + "\" is present in both "+pOp.owner.name+" and "+hOp.owner.name +"."]
              end end end;
          @For assocHeir in heir.owner.associations do // using two loops over the same list -> saves some trouble later
            @For assocParent in parent.owner.associations do
              if assocHeir <> assocParent
                andthen
                  (assocHeir.end2.name = assocParent.end2.name 
                    andthen (parent.isDescendantOf(assocParent.end1.type) or parent = assocParent.end1)
                    andthen (  heir.isDescendantOf(assocHeir.end1.type) or   heir = assocHeir.end1))
                  orelse
                  (assocHeir.end2.name = assocParent.end1.name 
                    andthen (parent.isDescendantOf(assocParent.end2.type) or parent = assocParent.end2)
                    andthen (  heir.isDescendantOf(assocHeir.end1.type) or   heir = assocHeir.end1))
                  orelse
                  (assocHeir.end1.name = assocParent.end2.name 
                    andthen (parent.isDescendantOf(assocParent.end1.type) or parent = assocParent.end1)
                    andthen (  heir.isDescendantOf(assocHeir.end2.type) or   heir = assocHeir.end2))
                  orelse
                  (assocHeir.end1.name = assocParent.end1.name 
                    andthen (parent.isDescendantOf(assocParent.end2.type) or parent = assocParent.end2)
                    andthen (  heir.isDescendantOf(assocHeir.end2.type) or   heir = assocHeir.end2))
              then
                problems := problems + ["Association collision. The associations \"" + assocParent.name + "\" and \""+assocHeir.name+"\" overlap."]
              end end end;
          if 
            problems.size() = 0
          then
            // set Parent
            heir.parents := heir.parents + {parent};
            // don't forget to add the subclass in the parent for performance purposes
            parent.subclasses := parent.subclasses + {heir};
            // add new slots
            @For instance in heir.allMetaInstances() do
              @For att in instance.of().allAttributes() do
                if 
                  att.instLevel = instance.level andthen not instance.hasSlot(att.name)
                then
                  Kernel_addAtt(instance,att.name,att.type.default())
                end
              end
            end;[]
          else
            problems
          end
        end
      end
    end
     
  context FmmlxManipulator  
    @Operation removeParent(heir, parent)
      heir.parents := heir.parents - {parent};
      // don't forget to remove the subclass from the parent we earlier added for performance purposes
      if parent.isKindOf(FMMLx::MetaClass) then 
        parent.subclasses := parent.subclasses - {heir} end;
      
      @For instance in heir.allMetaInstances() do
        let
          allAtts = instance.of().allAttributes()
        in
          @For slot in instance.slots() do 
            if 
              not allAtts.name.contains(slot.name)
              //att.instLevel = instance.level andthen not instance.hasSlot(att.name)
            then
              instance.removeStructuralFeature(slot.name)
            end
          end
        end
      end;
      
      []
    end  
    
  context FmmlxManipulator  
    @Operation moveParent(heir, oldParent, newParent)
      ["The operation \"moveParent\" has not been implemented yet."]
    end
    
  context FmmlxManipulator  
    @Operation orphanInstance(instance)
      self.migrateInstance(instance, null)
    end
    
  context FmmlxManipulator  
    @Operation migrateInstance(instance, newClass)
      ["The operation \"migrateInstance\" has not been implemented yet. Try to remove instance instead."]
    end
    
  context FmmlxManipulator  
    @Operation changeClassAbstract(class, abstractNew)
      if abstractNew 
      then 
        if class.level.minLevel > 0 
        then 
          if class.allInstances()->select(i | i.of() = class).size() = 0 
          then class.isAbstract := true; []
          else ["Classes with instances cannot be made abstract"] end
        else ["Objects on level 0 cannot be made abstract"] end
      else
        class.isAbstract := false; []
      end
    end
    
  context FmmlxManipulator  
    @Operation changeClassSingleton(class, singletonNew)
      if singletonNew 
      then 
        if class.level.minLevel > 0 
        then 
          if class.allInstances()->select(i | i.of() = class).size() <= 1 
          then 
            if // TODO replace with something more efficient
            // there is no class, which inherits from this class
            class.owner.classes
              ->select(c | c.isKindOf(Class))
              ->forAll(subClass | not (subClass.parents.contains(class)))
            then class.isSingleton := true; []
            else ["Classes with subclasses cannot be made Singletons"] end
          else ["Classes with more than one instance cannot be made Singletons"] end
        else ["Objects on level 0 cannot be made Singletons"] end
      else
        class.isSingleton := false; []
      end
    end
    
  context  FmmlxManipulator  
    @Operation levelRaiseAll(package, amount:Integer)
      let
        levelHighEnough = true;
        oneRandomReason = null
      in 
        if amount < 0 then
          @For obj in package.classes do 
            if obj.isKindOf(FMMLx::MetaClass) then 
              if obj.level + amount < 0 then 
                levelHighEnough := false; oneRandomReason:= "object " + obj.name
              end;
              @For att in obj.attributes do
                if att.instLevel + amount < 0 then 
                  levelHighEnough := false; oneRandomReason:= "attribute " + att.name + " in " + obj.name
                end
              end;
              @For o in obj.operations do
                if o.instLevel + amount < 0 then 
                  levelHighEnough := false; oneRandomReason:= "operation " + o.name + " in " + obj.name
                end
              end
            end
          end;
          @For assoc in package.associations do
            if assoc.end1.instLevel + amount < 0 orelse assoc.end2.instLevel + amount < 0 then
              levelHighEnough := false; 
              oneRandomReason:= "association " + assoc.name 
                + " between " + assoc.end1.type.name 
                + " and "     + assoc.end2.type.name
            end            
          end
        end;

        // if one object or attribute is too low the objects cannot be lowered. Raising is always allowed.
        if 
          levelHighEnough 
        then
          @For obj in package.classes do
            if obj.isKindOf(FMMLx::MetaClass) then 
              obj.level := obj.level + amount;
              @For att in obj.attributes do
                att.instLevel := att.instLevel + amount
              end;
              @For o in obj.operations do
                o.instLevel := o.instLevel + amount
              end
            end
          end;
          @For assoc in package.associations do
            assoc.end1.instLevel := assoc.end1.instLevel + amount;
            assoc.end2.instLevel := assoc.end2.instLevel + amount        
          end;
          []
        else
          ["Levels cannot be lowered. Some property (e.g. "+ oneRandomReason +") would be on a level below 0. "]
        end
      end
    end