parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramClient extends Client//, DiagramListener

	@Attribute package : Package end
	@Attribute communicator : Element end
	@Attribute protocol : String = "" end
	@Attribute name : String = "no name set yet" end
        @Attribute diagrams : Table = Table(10) end
    /* TEMP */ @Attribute diagram : FmmlxDiagram end
    
    @Constructor(name)
//      self.setCommandInterpreter(DiagramCommandInterpreter());
//      self.setEventHandler(DiagramEventHandler())
        null
    end
    
    @Operation createDiagram(package,name)
        self.package := package;
        
        ///////////FIND ALTERNATIVE TO THIS///////////////////
        if 
          package.of() <> FMML::FMMLxPackage
        then 
          package.setOf(FMML::FMMLxPackage);
          Kernel_addAtt(package,"fmmlxAssociationInstances",{})
        end;
        //////////////////////////////////////////////////////
        
        let 
          FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self);
//          diagram = FmmlxDiagram();
          newID = 0
        in
        
          if diagram = null then self.diagram := FmmlxDiagram() end;
          /* FUTURE: @While diagrams.hasKey(newID) do newID := newID + 1 end;
          
          self.diagrams.put(newID, self.diagram);
          
          if self.communicator = null then 
            self.communicator := FmmlxDiagramCommunicator();
            self.communicator.setHandle(handle)
          end;*/
          
          // TEMP
          self.diagrams.put(newID, self.diagram);
          self.communicator := FmmlxDiagramCommunicator();
          self.communicator.setHandle(handle);          
          self.communicator.newDiagram(newID, name.toString(), self.package.path());
          
          diagram // vestigial return value for diagram manager
        end
        
    end
    
    @Operation getMapping(requestID : Seq(Integer))
      self.diagrams.get(self.vector2Seq(requestID).at(0)).mapping
    end
    
    //////////////////////// Queries ///////////////////////////////
    
    @Operation getAllObjects(requestID : Seq(Integer))
        let 
          result = [] 
        in 
    	  @For c in self.package.getChildren() do
    	    if c.isKindOf(FMML::MetaClass) 
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(c)
    	      in
    	        result := result.append([[
    	        mappingInfo.id, 
    	        c.name.toString(), 
    	        c.level, // level
    	        if c.of().isKindOf(FMML::MetaClass) then self.getMapping(requestID).addOrGetObjectMapping(c.of()).id else -1 end,// of-ID
    	        self.getParentIdList(requestID, c),//[],// parents-ID
    	        c.isAbstract,
    	        mappingInfo.lastKnownDiagramX, 
    	        mappingInfo.lastKnownDiagramY]])
    	      end
    	    end
    	  end;
    	  // clean up mapping ?
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end
    
    @Operation getAllInheritanceEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.package.getChildren() do
          @For parent in object.parents do
            if parent.isKindOf(FMML::MetaClass) then
              let 
                childID = self.getMapping(requestID).addOrGetObjectMapping(object).id;
                parentID = self.getMapping(requestID).addOrGetObjectMapping(parent).id
              then 
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(("InheritanceMapping"+childID+"/"+parentID).asSymbol())
              in 
                result := result.append([[
  	            mappingInfo.id, // 0 ID
  	            childID, // 1 start ID
  	            parentID, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end
          end
        end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllAssociations(requestID : Seq(Integer))
        let 
          result = [] 
        in 
    	  @For a in self.package.associations do
    	    if a.isKindOf(Associations::Association) 
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(a)
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          self.getMapping(requestID).addOrGetObjectMapping(a.end1.type).id, // 1 start ID
    	          self.getMapping(requestID).addOrGetObjectMapping(a.end2.type).id, // 2 end ID
    	          -1, // 3 parent ID
    	          mappingInfo.points, // 4 points
    	          a.name.toString(), // 5 name 1
    	          null, // 6 name 2
    	          a.end2.name.toString(), // 7 name start->end slot name
    	          a.end1.name.toString(), // 8 name end->start slot name
    	          a.end2.instLevel, // 9 level s->e
    	          a.end1.instLevel, // 10 level e->s
    	          FmmlxManipulator::multiplicity2ValueList(a.end2.mult), // 11 mul s->e
    	          FmmlxManipulator::multiplicity2ValueList(a.end1.mult),  // 12 mul e->s
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id) // 13 labels
    	        ]])
    	      end // let
    	    else ("a is of " + a.of()).println()
    	    end // if
    	  end;
    	  // clean up mapping ? 
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end
    
    @Operation getAllAssociationInstances(requestID : Seq(Integer))
        let 
          result = [] 
        in 
    	  @For i in (if self.package.fmmlxAssociationInstances = null then {} else self.package.fmmlxAssociationInstances end) do 

    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(i)
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          self.getMapping(requestID).addOrGetObjectMapping(i.at(0)).id, // 1 start ID
    	          self.getMapping(requestID).addOrGetObjectMapping(i.at(1)).id, // 2 end ID
    	          self.getMapping(requestID).addOrGetObjectMapping(i.at(2)).id, // 3 assoc ID
    	          mappingInfo.points, // 4 points
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id) // 5 labels
    	        ]])
    	      end // let
    	  end;
    	  // clean up mapping ? 
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end
    
    @Operation getOwnAttributes(requestID : Seq(Integer), className) 
        let 
          result = [] 
        in 
          @For c in self.package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For a in c.attributes do 
                result := result.append([[a.name.toString(), a.type.name.toString(), a.instLevel, a.mult()]])
              end
            end
          end;
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end
     
    @Operation getAllAttributes(requestID : Seq(Integer), className) 
        let 
          resultOwn   = [];
          resultOther = [];
          result = []
        in 
          @For c in self.package.getChildren() do
            //("att:"+c.name).println();
            if c.isKindOf(FMML::MetaClass) and c.name.toString() = className
            then 
              @For a in c.attributes do 
                resultOwn   :=   resultOwn.append([[
                    a.name.toString(), 
                    a.type.name.toString(), 
                    a.instLevel, 
                    a.mult(),
                    self.getMapping(requestID).getMappingId(c)
                    ]])
              end;
              @For a in (c.allAttributes() - c.attributes) do 
                if a.isIntrinsic then
                  resultOther := resultOther.append([[
                    a.name.toString(), 
                    a.type.name.toString(), 
                    a.instLevel, 
                    a.mult(),
                    self.getMapping(requestID).getMappingId(a.owner)
                    ]])
                end
              end            
            end
          end;
          result := [resultOwn, resultOther];
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end
    
    @Operation getSlots(requestID : Seq(Integer), objectName, slotList) 
      let 
        result = [] 
      in 
        @For o in self.package.getChildren() do 
          if o.isKindOf(FMML::MetaClass) and o.name.toString() = objectName
          then 
            @For name in slotList do
              if o.hasSlot(name)
              then 
                let 
                  value = o.get(name)
                then
                  text = if value.of().isKindOf(Enum) then value.name().toString() else value.toString() end 
                in
                  result := result.append([[name, text]])
                end
              end
            end
          end
        end;
    	self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
      
    @Operation getOperationValues(requestID : Seq(Integer), objectName, opNames) 
      let 
        result = [] 
      in 
        @For obj in self.package.getChildren() do 
          if obj.isKindOf(FMML::MetaClass) and obj.name.toString() = objectName and opNames.size() > 0
          then 
            @For o in obj.of().allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
              if o.instLevel = obj.level then
                @For name in opNames do
                  if name = o.name.toString() then
                    result := result.append([[
                      o.name.toString(), 
                      o.invoke(obj,{})]])
                end end // if contains // for
              end // if level
            end end // if // for
          end
        end;
    	self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getOwnOperations(requestID : Seq(Integer), className) 
        let 
          result = [] 
        in 
          @For c in self.package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For o in c.allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
                let
                  paramNames = o.paramNames();
                  paramTypesRaw = o.paramTypes();
                  paramTypes = []
                in
                  @For type in paramTypesRaw do
                    paramTypes := paramTypes.append([type.path()])
                  end;       
                  result := result.append([[
                  o.name.toString(),
                  paramNames,
                  paramTypes,
                  o.instLevel, 
                  o.type().path(),
                  o.source(),
                  if o.owner.isKindOf(FMML::MetaClass) then self.getMapping(requestID).getMappingId(o.owner) else -1 end,
                   [0,1,false,true], // to-do: multiplicity
                  self.isOperationMonitored(o)
                  ]])
                end
              end end
            end
          end;
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end  
    
    @Operation getAllEnums(requestID : Seq(Integer))
        let 
          result = [] 
        in 
    	  @For e in self.package.getChildren() do
    	    if e.isKindOf(Enum) 
    	    then
    	      let
    	        enumItems = e.getChildren();
    	        itemList = []
    	      in
    	        @For item in enumItems do
    	          itemList := itemList + [item.name.toString()]
    	        end;
    	        result := result.append([[
    	        e.name.toString(),
    	        itemList]])
    	      end
    	    end
    	  end;
    	  // clean up mapping ?
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end
    
    ///////////////////// Updates to the View ////////////////////
    
    @Operation sendNewPosition(requestID : Seq(Integer), objectID, x, y)
        self.getMapping(requestID).setNewPosition(objectID, x, y);
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), []]) 
    end
    
    @Operation sendNewPositions(requestID : Seq(Integer), edgeID, listOfpoints)
        self.getMapping(requestID).setNewPositions(edgeID, listOfpoints);
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), []]) 
    end
  
    @Operation storeLabelInfo(requestID : Seq(Integer), edgeID, localID, x, y)
        self.getMapping(requestID).storeLabelInfo(edgeID, localID, x, y);
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), []]) 
    end
    
    ////////////////// Class Manipulations ///////////////////
    
    @Operation addMetaClass(requestID : Seq(Integer), name, level, parents, abstract, x, y)
        self.protocol := self.protocol + "\nE      addMetaClass: " + name + " | " + level + " | " + parents + " | " + abstract;
        let 
          m = FmmlxDiagrams::FmmlxManipulator() 
        then 
          parentsList = self.getParentsList(requestID, parents)
        then 
          newClass = m.addMetaClass(self.package, name, level, parentsList, abstract)
        then
          mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newClass)
        in 
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y
        end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), []]) // temporary empty result 
    end 
    
    @Operation addInstance(requestID : Seq(Integer), ofId, name, parents, abstract, x, y)
      self.protocol := self.protocol + "\nE      addInstance: " + ofId + " | " + name + " | " + parents + " | " + abstract;
        try
          let 
            m = FmmlxDiagrams::FmmlxManipulator() 
          then 
            ofClass = self.getMapping(requestID).getMapping(ofId).object
          then
            parentsList = self.getParentsList(requestID, parents)
          then 
            newInstance = m.addInstance(self.package, ofClass, name, parentsList, abstract)
          then
            mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newInstance)
          in 
            mappingInfo.lastKnownDiagramX := x;
            mappingInfo.lastKnownDiagramY := y
          end;
          self.communicator.sendMessageToJava([self.vector2Seq(requestID), []]) 
        catch (exception)
          self.communicator.sendMessageToJava([self.vector2Seq(requestID), [exception.message]])
        end
    end 
    
    @Operation removeClass(requestID : Seq(Integer), classId, strategy) 
      self.protocol := self.protocol + "\nE      removeClass: " + classId;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      in
        m.removeClass(class, strategy)
      end;
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result 
    end
    
    @Operation changeClassName(requestID : Seq(Integer), classId, newName) 
      self.protocol := self.protocol + "\nE      changeClassName: " + classId + " | " + newName;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      in
        m.changeClassName(class, newName)
      end;
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), []])
    end
      
    @Operation setClassAbstract(requestID : Seq(Integer), classId, isAbstract) 
      self.protocol := self.protocol + "\nE      setClassAbstract: " + classId + " | " + isAbstract;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.changeClassAbstract(class, isAbstract)])
      end      
    end 
    
    @Operation levelRaiseAll(requestID : Seq(Integer), amount)
      self.protocol := self.protocol + "\nE      levelRaiseAll: " + amount;
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.levelRaiseAll(self.package, amount)])
      end  
    end
    
    //////////////////////// Attribute Manipulations /////////////////////
    
    @Operation addAttribute(requestID : Seq(Integer), classId, name, level, typeName, multiplicityV)
      self.protocol := self.protocol + "\n A     addAttribute: " + classId + " | " + name + " | " + level + " | " + typeName;
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then 
        class = self.getMapping(requestID).getMapping(classId).object;
        type = m.getTypeForName(typeName, self.package)
        // multiplicity = m.valueList2Multiplicity(self.vector2Seq(multiplicityV))
      then 
        problems = m.checkAddAttribute(class, name, level, typeName)
      in           
        if 
          problems.isEmpty() 
        then
          problems := try 
            m.addAttribute(class, name, level, type); null
          catch(e)
            [("addAttribute failed during transaction: " + e.message)]
          end // try
        end; // if
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end // in       
    end 
    
    @Operation removeAttribute(requestID : Seq(Integer), classId, attName, strategy) 
      self.protocol := self.protocol + "\n A     addAttribute: " + classId + " | " + attName;
     // for now: ignore strategy and simply delete 
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      in
        m.removeAttribute(class, attName, strategy)
      end;
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result 
    end
    
    @Operation changeAttributeName(requestID : Seq(Integer), classId, oldName, newName)
      self.protocol := self.protocol + "\n A     changeAttributeName: " + classId + " | " + oldName + " | " + newName;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then 
        problems = m.checkChangeAttributeName(class, oldName, newName)
      in
        if problems.isEmpty() then m.changeAttributeName(class, oldName, newName) end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeAttributeLevel(requestID : Seq(Integer), classId, attName, oldLevel, newLevel)
      self.protocol := self.protocol + "\n A     changeAttributeLevel: " + classId + " | " + attName + " | " + newLevel;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then         
        problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
      in
        if problems.isEmpty() then m.changeAttributeLevel(class, attName, oldLevel, newLevel) end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
      
    @Operation changeAttributeType(requestID : Seq(Integer), classId, attName, oldTypeName, newTypeName)
      self.protocol := self.protocol + "\n A     changeAttributeType: " + classId + " | " + attName + " | " + newTypeName;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then         
        problems = m.checkChangeAttributeType(class, attName, oldTypeName, newTypeName, self.package)
      in
        if problems.isEmpty() then m.changeAttributeType(class, attName, oldTypeName, newTypeName, self.package) end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end   
      
    //////////////////////// Slot Manipulations /////////////////////

    @Operation changeSlotValue(requestID : Seq(Integer), objId, slotName, valueToBeParsed)
      self.protocol := self.protocol + "\n  S    changeSlotValue: " + objId + " | " + slotName + " | " + valueToBeParsed;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        obj = self.getMapping(requestID).getMapping(objId).object;
        error = null
      then
        class = obj.of()
      then
        atts = class.allAttributesForLevel(obj.level);
        foundAtt = null
      in
        @For att in atts do
          if att.name.toString() = slotName.toString() then
            foundAtt := att
          end
        end;
        if 
          foundAtt <> null 
        then
          let
            parseResult = m.evalString(valueToBeParsed, self.package)
          in
            if parseResult.at(1) = null then 
              error := m.changeSlotValue(obj, slotName, parseResult.at(0), foundAtt.type, self.package)
            else
              error := parseResult.at(1) // error as message or as return value? maybe try exceptions...
            end
          end
          
        else
          error := "no Slot Found"
        end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), if error = null then null else [error] end]) // temporary empty result 
      end
    end
    
    //////////////// Local Operations ///////////////////
    
    @Operation vector2Seq(vec) // for local use
      let list = [] in
        @For id in vec do
          list := list.append([id])
        end; // for
        list
      end// let  
    end
      
    @Operation getParentsList(requestID, parentIds) // for local use
      let list = [] in
        @For id in parentIds do
          if not id = -1 then list := list.append([self.getMapping(requestID).getMapping(id).object]) end
        end; // for
        list
      end// let      
    end
         
    @Operation getParentIdList(requestID, c : FMML::MetaClass) // for local use
      let list = [] in
        @For p in c.parents do
          if p.isKindOf(FMML::MetaClass) then list := list.append([self.getMapping(requestID).addOrGetObjectMapping(p).id]) end
        end; // for
        list
      end// let      
    end
    
    @Operation isOperationMonitored(o)
      if o.hasProperty("monitor") then FmmlxDiagramClient::getOpProp(o, "monitor") else false end
    end
    
    ////////////////// Operations for editing associations ///////////////////
    
  @Operation addAssociation(requestID : Seq(Integer), 
      class1Id : Integer,
      class2Id : Integer,
      accessSourceFromTargetName : String,
      accessTargetFromSourceName : String,
      fwName : String,
      reverseName : String,
      mult1S : String,
      mult2S : String,
      instLevel1 : Integer,
      instLevel2 : Integer,
      sourceVisible : boolean, 
      targetVisible : boolean,
	  isSymmetric : boolean,
	  isTransitive : boolean):XCore::Element
  	  
      self.protocol := self.protocol + "\n   Z   addAssociation: " + class1Id + " | " + class2Id + " | " + fwName;
      
  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    class1 = self.getMapping(requestID).getMapping(class1Id).object;
  	    class2 = self.getMapping(requestID).getMapping(class2Id).object
  	  then
        mult1 = m.valueList2Multiplicity(self.vector2Seq(mult1S));
        mult2 = m.valueList2Multiplicity(self.vector2Seq(mult2S))
      then 
        problems = [] /*m.checkAddAssociation(self.package,
  	      class1, class2,
  	      accessSourceFromTargetName, accessTargetFromSourceName,
  	      fwName, reverseName,
  	      mult1, mult2,
  	      instLevel1, instLevel2) */
      in
        if problems.isEmpty() then 
  	      problems := m.addAssociation(self.package,
  	        class1, class2,
  	        accessSourceFromTargetName, accessTargetFromSourceName,
  	        fwName, reverseName,
  	        mult1, mult2,
  	        instLevel1, instLevel2)
  	    end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end  	  
  	end    
    
    @Operation removeAssociation(
      requestID  : Seq(Integer), 
      assocId    : Integer)
      
      self.protocol := self.protocol + "\n   Z   removeAssociation: " + assocId;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = self.getMapping(requestID).getMapping(assocId).object
      then 
        problems = m.removeAssociation(assoc)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeAssociationForwardName(
      requestID  : Seq(Integer), 
      assocId    : Integer, 
      newName    : String)
      
      self.protocol := self.protocol + "\n   Z   changeAssociationForwardName: " + assocId + " | " + newName;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = self.getMapping(requestID).getMapping(assocId).object
      then 
        problems = m.changeAssociationForwardName(assoc, newName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
   @Operation changeAssociationEnd2StartMultiplicity(requestID : Seq(Integer), associationID, multV)

      self.protocol := self.protocol + "\n   Z   changeAssociationEnd2StartMultiplicity: " + associationID + " | " + multV;
      let 
        m = FmmlxDiagrams::FmmlxManipulator();
        a = self.getMapping(requestID).getMapping(associationID).object
      then 
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      in 
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.changeAssociationMultiplicity(a, newMult, null)])
      end
    end
      
    @Operation changeAssociationStart2EndMultiplicity(requestID : Seq(Integer), associationID, multV) 
      self.protocol := self.protocol + "\n   Z   changeAssociationStart2EndMultiplicity: " + associationID + " | " + multV;
      let 
        m = FmmlxDiagrams::FmmlxManipulator();
        a = self.getMapping(requestID).getMapping(associationID).object
      then 
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      in 
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.changeAssociationMultiplicity(a, null, newMult)])
      end
    end

    //////////////////////////////////////////////////////////
  	
  	@Operation addAssociationInstance(requestID : Seq(Integer), 
      obj1Id  : Integer,
      obj2Id  : Integer,
      assocId : Integer)
      
      self.protocol := self.protocol + "\n    L  addAssociationInstance: " + assocId + " | " + obj1Id + " | " + obj2Id;
  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    obj1 = self.getMapping(requestID).getMapping(obj1Id).object;
  	    obj2 = self.getMapping(requestID).getMapping(obj2Id).object;
  	    association = self.getMapping(requestID).getMapping(assocId).object
  	  then 
        problems = m.addAssociationInstance(self.package, obj1, obj2, association)
  	  in
  	    self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
  	  end
    end
    
    @Operation removeAssociationInstance(
      requestID   : Seq(Integer), 
      assocInstId    : Integer)
      
      self.protocol := self.protocol + "\n    L  removeAssociationInstance: " + assocInstId;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assocInstSeq = self.getMapping(requestID).getMapping(assocInstId).object
      then 
        problems = m.removeAssociationInstance(assocInstSeq)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    ////////////////// Operations for editing operations ///////////////////

    @Operation changeOperationName(requestID : Seq(Integer), classId, oldName, newName) 
    
      self.protocol := self.protocol + "\n     O changeOperationName: " + classId + " | " + oldName + " | " + newName;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then 
        problems = m.checkChangeOperationName(class, oldName, newName)
      in
        if problems.isEmpty() then m.changeOperationName(class, oldName, newName) end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeOperationLevel(requestID : Seq(Integer), classId, name, oldLevel, newLevel) 
    
      self.protocol := self.protocol + "\n     O changeOperationLevel: " + classId + " | " + name + " | " + newLevel;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then
        o = m.findOperation(class,name)
      then 
        problems = m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o))
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation addOperation(
      requestID  : Seq(Integer), 
      classId    : Integer,
      opName     : String, 
      level      : Integer, 
      returnType : String,
      body       : String)
      
      self.protocol := self.protocol + "\n     O addOperation: " + classId + " | " + opName + " | " + level;
      
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then 
        type = m.getTypeForName(returnType, self.package);
        problems = m.addOperation(class, opName, level, type, body)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation addOperation2(
      requestID  : Seq(Integer), 
      classId    : Integer,
      level      : Integer, 
      body       : String)
      
      self.protocol := self.protocol + "\n     O addOperation2: " + classId + " | ??? | " + level;
      
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then 
        problems = m.addOperation2(class, level, body)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation removeOperation(
      requestID  : Seq(Integer), 
      classId    : Integer,
      opName     : String)
      
      self.protocol := self.protocol + "\n     O removeOperation: " + classId + " | " + opName;
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then 
        problems = m.removeOperation(class, opName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation getOpProp(operation, name) // for local use
      let
        properties = operation.properties();
        tagFound = null
      in 
        @For property in properties do  
          if property->head() = name
            then tagFound := property->tail()
          end
        end;
        tagFound
      end      
    end
    
    @Operation changeOperationOwner(requestID : Seq(Integer), idO_old, name, idO_new) 
      
      self.protocol := self.protocol + "\n     O changeOperationOwner: " + classId + " | " + name + " | " + idO_new;
      let 
        m = FmmlxDiagrams::FmmlxManipulator();
        oldOwner = self.getMapping(requestID).getMapping(idO_old).object;
        newOwner = self.getMapping(requestID).getMapping(idO_new).object
      then
        operation = oldOwner.getOperation(name)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.changeOperationOwner(oldOwner, operation, newOwner)])
      end      
    end
          
    @Operation checkOperationNameLegal(op, name):Boolean // todo: check for duplicates, consider arity
      let nameSymbol = Symbol(name) in
        if nameSymbol = op.name()
        then
          true
        else
          op.legalNameChangeCheck(nameSymbol,op.name())
        end
      end
    end
        
    @Operation changeOperationBody(requestID : Seq(Integer), classId:Integer, oldName:String, body:String)
      
      self.protocol := self.protocol + "\n     O changeOperationBody: " + classId + " | " + oldName;
      let 
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object;
        problems = []
      then
        op = class.getOperation(oldName)
      then
        newName = body.splitBy("()[]",0,0)->head.subst("","@Operation ",false)
      in
        if oldName.toString() <> newName.toString() then 
          problems := ["name change not allowed here"]
        elseif
          op = null then 
          problems := ["operation not found"]
        else // let the manipulator try
          problems := m.changeOperationBody(class, op, newName, body)
        end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    // Not yet implemented
    
    @Operation respondNotYetImplemented(requestID : Seq(Integer))
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), ["This feature is temporarily unavailable. Please try again later."]])
    end
      
    @Operation changeAssociationStart2EndAccessName(requestID : Seq(Integer), associationID, name) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeAssociationEnd2StartAccessName(requestID : Seq(Integer), associationID, name) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeAssociationStart2EndLevel(requestID : Seq(Integer), associationID, level) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeAssociationEnd2StartLevel(requestID : Seq(Integer), associationID,level) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation updateAssociationInstance(requestID : Seq(Integer), id1, id2) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
//    @Operation editAssociation(requestID, idA, isS, idT, levT2S, levS2T, fwN, reN, accT2S, accS2T, mulT2S, mulS2T) 
//      self.respondNotYetImplemented(self.vector2Seq(requestID))
//    end
      
    @Operation changeAssociationTarget(inA : Seq(Integer), idT_o, idT_n) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeAssociationSource(inA : Seq(Integer), idS_o, idS_n) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation checkOperationBody(requestID : Seq(Integer), operationBodyToBeChecked) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeOperationType(requestID : Seq(Integer), idO, opName, newType) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeParent(requestID : Seq(Integer), idO, oldList, newList) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeAttributeOwner(requestID : Seq(Integer), idO_old, name, idO_new) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeOf(requestID : Seq(Integer), idO, idC_old, idC_new) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end
      
    @Operation changeClassLevel(requestID : Seq(Integer), idO, newLevel) 
      self.respondNotYetImplemented(self.vector2Seq(requestID))
    end   
       
    @Operation addEnumeration(requestID : Seq(Integer), newEnumName:String)
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumeration(self.package, newEnumName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeEnumerationName(requestID : Seq(Integer), oldEnumName:String, newEnumName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationName(self.package, oldEnumName, newEnumName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation removeEnumeration(requestID : Seq(Integer), enumName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumeration(self.package, enumName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation addEnumerationValue(requestID : Seq(Integer), enumName:String, newEnumValueName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumerationValue(self.package, enumName, newEnumValueName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation changeEnumerationValueName(requestID : Seq(Integer), enumName:String, oldEnumValueName:String, newEnumValueName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationValueName(self.package, enumName, oldEnumValueName, newEnumValueName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation removeEnumerationValue(requestID : Seq(Integer), enumName:String, enumValueName:String) 
      "removeEnumerationValueStart".println();
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumerationValue(self.package, enumName, enumValueName)
      in
        ("removeEnumerationValue problems: " + problems).println();
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation printProtocol(requestID : Seq(Integer))
      self.protocol.println()
    end
    
    
end