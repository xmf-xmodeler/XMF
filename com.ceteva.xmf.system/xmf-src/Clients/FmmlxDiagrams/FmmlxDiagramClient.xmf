parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramClient extends Client//, DiagramListener

	@Attribute package : Package end
	@Attribute mapping : FmmlxDiagramMapping = FmmlxDiagramMapping() end
	@Attribute communicator : Element end

    @Constructor(name)
//      self.setCommandInterpreter(DiagramCommandInterpreter());
//      self.setEventHandler(DiagramEventHandler())
        null
    end
    
    @Operation createDiagram(package,name)
        self.package := package;
        let 
          FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self)
        in
          self.communicator := FmmlxDiagramCommunicator();
          self.communicator.setHandle(handle);
          self.communicator.newDiagram()
        end;
//        let x = FmmlxDiagram()
//        in 
//          ("x: "+x).println();
//          x.newDiagram();
//          ("name: "+name).println();
//          ("self.newDiagram("+self.name+")").println();
//          x
//        end
        FmmlxDiagram() // vestigial return value for diagram manager
    end
    
    @Operation getAllObjects(idRequest)
        let 
          result = [] 
        in 
    	  @For c in package.getChildren() do
    	    if c.isKindOf(FMML::MetaClass) 
    	    then
    	      let
    	        mappingInfo = mapping.addOrGetObjectMapping(c)
    	      in
    	        result := result.append([[
    	        mappingInfo.id, 
    	        c.name.toString(), 
    	        c.level, // level
    	        if c.of().isKindOf(FMML::MetaClass) then mapping.addOrGetObjectMapping(c.of()).id else -1 end,// of-ID
    	        self.getParentIdList(c),//[],// parents-ID
    	        c.isAbstract,
    	        mappingInfo.lastKnownDiagramX, 
    	        mappingInfo.lastKnownDiagramY]])
    	      end
    	      //("mapping of " + c + " is " + mapping.addOrGetObjectMapping(c)).println();
    	      /*
    	      if c is not in mapping
    	        add c to mapping
    	      return c with mapping info
    	      */
    	      //result := result.append([c.name.toString()])
    	    end
    	  end;
    	  // clean up mapping ? 
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
    
    @Operation getAllAssociations(idRequest)
        let 
          result = [] 
        in 
    	  @For a in package.associations do 
    	    if a.isKindOf(Associations::Association) 
    	    then
    	      let
    	        mappingInfo = mapping.addOrGetObjectMapping(a)
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          mapping.addOrGetObjectMapping(a.end1.type).id, // 1 start ID
    	          mapping.addOrGetObjectMapping(a.end2.type).id, // 2 end ID
    	          -1, // 3 parent ID
    	          mappingInfo.points, // 4 points
    	          a.name.toString(), // 5 name 1
    	          null, // 6 name 2
    	          a.end2.name.toString(), // 7 name start->end slot name
    	          a.end1.name.toString(), // 8 name end->start slot name
    	          a.end2.instLevel, // 9 level s->e
    	          a.end1.instLevel, // 10 level e->s
    	          null, // 11 mul s->e
    	          null // 12 mul e->s
    	        ]])
    	      end // let
    	    else ("a is of " + a.of()).println()
    	    end // if
    	  end;
    	  // clean up mapping ? 
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
    
    @Operation getOwnAttributes(idRequest, className) 
        let 
          result = [] 
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For a in c.attributes do 
                result := result.append([[a.name.toString(), a.type.name.toString(), a.instLevel, a.mult()]])
              end
            end
          end;
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
     
    @Operation getAllAttributes(idRequest, className) 
        let 
          resultOwn   = [];
          resultOther = [];
          result = []
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For a in c.attributes do 
                resultOwn   :=   resultOwn.append([[
                    a.name.toString(), 
                    a.type.name.toString(), 
                    a.instLevel, 
                    a.mult(),
                    mapping.getMappingId(c)
                    ]])
              end;
              @For a in (c.allAttributes() - c.attributes) do 
                if a.isIntrinsic then
                  resultOther := resultOther.append([[
                    a.name.toString(), 
                    a.type.name.toString(), 
                    a.instLevel, 
                    a.mult(),
                    mapping.getMappingId(a.owner)
                    ]])
                end
              end            
            end
          end;
          result := [resultOwn, resultOther];
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
    
    @Operation getSlots(idRequest, objectName, slotList) 
      let 
        result = [] 
      in 
        @For o in package.getChildren() do 
          if o.isKindOf(FMML::MetaClass) and o.name.toString() = objectName
          then 
            @For name in slotList do
              if o.hasSlot(name)
                then result := result.append([[name, o.get(name).toString()]])
              end
            end
          end
        end;
    	self.communicator.sendMessageToJava([idRequest, result])
      end
    end
      
    @Operation getOperationValues(idRequest, objectName, opNames) 
      let 
        result = [] 
      in 
        @For obj in package.getChildren() do 
          if obj.isKindOf(FMML::MetaClass) and obj.name.toString() = objectName and opNames.size() > 0
          then 
            @For o in obj.of().allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
              if o.instLevel = obj.level then
                @For name in opNames do
                  if name = o.name.toString() then                    
                    result := result.append([[
                      o.name.toString(), 
                      o.invoke(obj,{})]]) 
                end end // if contains // for
              end // if level
            end end // if // for
          end
        end;
    	self.communicator.sendMessageToJava([idRequest, result])
      end
    end
    
    @Operation getOwnOperations(idRequest, className) 
        let 
          result = [] 
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For o in c.allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
                result := result.append([[
                o.name.toString(), 
                o.instLevel, 
                o.type.name.toString(),
                if o.owner.isKindOf(FMML::MetaClass) then mapping.getMappingId(o.owner) else -1 end,
                "to-do: multiplicity",
                self.getOpProp(o, "monitor")
                ]])
              end end
            end
          end;
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end  
    
    @Operation sendNewPosition(idRequest, objectID, x, y)
        mapping.setNewPosition(objectID, x, y);
        self.communicator.sendMessageToJava([idRequest, []]) // empty result for compatibility
    end
    
    @Operation sendNewPositions(idRequest, objectID, listOfpoints)
        mapping.setNewPositions(objectID, listOfpoints);
        self.communicator.sendMessageToJava([idRequest, []]) // empty result for compatibility
    end
    
    @Operation addMetaClass(idRequest, name, level, parents, abstract, x, y)
//        ("addMetaClass " + name 
//        + " on level " + level 
//        + " with parents " + parents 
//        + (if abstract then " and abstract " else " " end)
//        + "at position " + x + "/" + y).println(); 
        
        let 
          m = FmmlxDiagrams::FmmlxManipulator() 
        then 
          parentsList = self.getParentsList(parents)
        then 
          newClass = m.addMetaClass(package, name, level, parentsList, abstract)
        then
          mappingInfo = mapping.addOrGetObjectMapping(newClass)
        in 
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y
        end;
        self.communicator.sendMessageToJava([idRequest, []]) // temporary empty result 
    end 
    
    @Operation addInstance(idRequest, ofId, name, parents, abstract, x, y)
        //("addInstance " + name 
        //+ " of id " + ofId 
        //+ " with parents " + parents 
        //+ (if abstract then " and abstract " else " " end)
        //+ "at position " + x + "/" + y).println(); 
       
        let 
          m = FmmlxDiagrams::FmmlxManipulator() 
        then 
          ofClass = mapping.getMapping(ofId).object
        then
          parentsList = self.getParentsList(parents)
        then 
          newInstance = m.addInstance(package, ofClass, name, parentsList, abstract)
        then
          mappingInfo = mapping.addOrGetObjectMapping(newInstance)
        in 
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y
        end;
        self.communicator.sendMessageToJava([idRequest, []]) // temporary empty result 
    end 
    
    @Operation addAttribute(idRequest, classId, name, level, type, multiplicity)
//        ("addAttribute " + name 
//        + " to id " + classId 
//        + " level " + level 
//        + " type " + type).println(); 
        
        let 
          m = FmmlxDiagrams::FmmlxManipulator() 
        then 
          class = mapping.getMapping(classId).object
        then 
          problems = m.checkAddAttribute(class, name, level, type, multiplicity)
        in           
          if problems.isEmpty() then m.addAttribute(class, name, level, type, multiplicity) end;
          self.communicator.sendMessageToJava([idRequest, problems]) // temporary empty result 
        end        
    end 
    
    @Operation changeSlotValue(idRequest, objId, slotName, valueToBeParsed)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        obj = mapping.getMapping(objId).object
      in
        m.changeSlotValue(obj, slotName, valueToBeParsed)
      end;
      self.communicator.sendMessageToJava([idRequest, null]) // temporary empty result 
    end
    
    @Operation removeAttribute(idRequest, classId, attName, strategy) 
     // for now: ignore strategy and simply delete 
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = mapping.getMapping(classId).object
      in
        m.removeAttribute(class, attName, strategy)
      end
    end
    
    @Operation getParentsList(parentIds) // for local use
      let list = [] in
        @For id in parentIds do
          if not id = -1 then list := list.append([mapping.getMapping(id).object]) end
        end; // for
        list
      end// let      
    end
    
        
    @Operation getParentIdList(c : FMML::MetaClass) // for local use
      let list = [] in
        @For p in c.parents do
          if p.isKindOf(FMML::MetaClass) then list := list.append([mapping.addOrGetObjectMapping(p).id]) end
        end; // for
        list
      end// let      
    end
    
    @Operation getOpProp(operation, name) // for local use
      let
        properties = operation.properties();
        tagFound = null
      in 
        @For property in properties do  
          if property->head() = name
            then tagFound := property->tail()
          end
        end;
        tagFound
      end      
    end
end