parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramClient extends Client//, DiagramListener

	@Attribute package : Package end
	@Attribute mapping : FmmlxDiagramMapping = FmmlxDiagramMapping() end
	@Attribute communicator : Element end

    @Constructor(name)
//      self.setCommandInterpreter(DiagramCommandInterpreter());
//      self.setEventHandler(DiagramEventHandler())
        null
    end
    
    @Operation createDiagram(package,name)
        self.package := package;
        let 
          FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self)
        in
          self.communicator := FmmlxDiagramCommunicator();
          self.communicator.setHandle(handle);
          self.communicator.newDiagram()
        end;
//        let x = FmmlxDiagram()
//        in 
//          ("x: "+x).println();
//          x.newDiagram();
//          ("name: "+name).println();
//          ("self.newDiagram("+self.name+")").println();
//          x
//        end
        FmmlxDiagram() // vestigial return value for diagram manager
    end
    
    //////////////////////// Queries ///////////////////////////////
    
    @Operation getAllObjects(idRequest)
        let 
          result = [] 
        in 
    	  @For c in self.package.getChildren() do
    	    if c.isKindOf(FMML::MetaClass) 
    	    then
    	      let
    	        mappingInfo = self.mapping.addOrGetObjectMapping(c)
    	      in
    	        result := result.append([[
    	        mappingInfo.id, 
    	        c.name.toString(), 
    	        c.level, // level
    	        if c.of().isKindOf(FMML::MetaClass) then self.mapping.addOrGetObjectMapping(c.of()).id else -1 end,// of-ID
    	        self.getParentIdList(c),//[],// parents-ID
    	        c.isAbstract,
    	        mappingInfo.lastKnownDiagramX, 
    	        mappingInfo.lastKnownDiagramY]])
    	      end
    	      //("mapping of " + c + " is " + self.mapping.addOrGetObjectMapping(c)).println();
    	      /*
    	      if c is not in mapping
    	        add c to mapping
    	      return c with mapping info
    	      */
    	      //result := result.append([c.name.toString()])
    	    end
    	  end;
    	  // clean up mapping ? 
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
    
    @Operation getAllAssociations(idRequest)
        let 
          result = [] 
        in 
    	  @For a in package.associations do 
    	    if a.isKindOf(Associations::Association) 
    	    then
    	      let
    	        mappingInfo = self.mapping.addOrGetObjectMapping(a)
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          self.mapping.addOrGetObjectMapping(a.end1.type).id, // 1 start ID
    	          self.mapping.addOrGetObjectMapping(a.end2.type).id, // 2 end ID
    	          -1, // 3 parent ID
    	          mappingInfo.points, // 4 points
    	          a.name.toString(), // 5 name 1
    	          null, // 6 name 2
    	          a.end2.name.toString(), // 7 name start->end slot name
    	          a.end1.name.toString(), // 8 name end->start slot name
    	          a.end2.instLevel, // 9 level s->e
    	          a.end1.instLevel, // 10 level e->s
    	          null, // 11 mul s->e
    	          null // 12 mul e->s
    	        ]])
    	      end // let
    	    else ("a is of " + a.of()).println()
    	    end // if
    	  end;
    	  // clean up mapping ? 
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
    
    @Operation getOwnAttributes(idRequest, className) 
        let 
          result = [] 
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For a in c.attributes do 
                result := result.append([[a.name.toString(), a.type.name.toString(), a.instLevel, a.mult()]])
              end
            end
          end;
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
     
    @Operation getAllAttributes(idRequest, className) 
        let 
          resultOwn   = [];
          resultOther = [];
          result = []
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For a in c.attributes do 
                resultOwn   :=   resultOwn.append([[
                    a.name.toString(), 
                    a.type.name.toString(), 
                    a.instLevel, 
                    a.mult(),
                    self.mapping.getMappingId(c)
                    ]])
              end;
              @For a in (c.allAttributes() - c.attributes) do 
                if a.isIntrinsic then
                  resultOther := resultOther.append([[
                    a.name.toString(), 
                    a.type.name.toString(), 
                    a.instLevel, 
                    a.mult(),
                    self.mapping.getMappingId(a.owner)
                    ]])
                end
              end            
            end
          end;
          result := [resultOwn, resultOther];
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
    
    @Operation getSlots(idRequest, objectName, slotList) 
      let 
        result = [] 
      in 
        @For o in package.getChildren() do 
          if o.isKindOf(FMML::MetaClass) and o.name.toString() = objectName
          then 
            @For name in slotList do
              if o.hasSlot(name)
                then result := result.append([[name, o.get(name).toString()]])
              end
            end
          end
        end;
    	self.communicator.sendMessageToJava([idRequest, result])
      end
    end
      
    @Operation getOperationValues(idRequest, objectName, opNames) 
      let 
        result = [] 
      in 
        @For obj in package.getChildren() do 
          if obj.isKindOf(FMML::MetaClass) and obj.name.toString() = objectName and opNames.size() > 0
          then 
            @For o in obj.of().allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
              if o.instLevel = obj.level then
                @For name in opNames do
                  if name = o.name.toString() then                    
                    result := result.append([[
                      o.name.toString(), 
                      o.invoke(obj,{})]]) 
                end end // if contains // for
              end // if level
            end end // if // for
          end
        end;
    	self.communicator.sendMessageToJava([idRequest, result])
      end
    end
    
    @Operation getOwnOperations(idRequest, className) 
        let 
          result = [] 
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For o in c.allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
                result := result.append([[
                o.name.toString(), 
                o.instLevel, 
                o.type.name.toString(),
                if o.owner.isKindOf(FMML::MetaClass) then self.mapping.getMappingId(o.owner) else -1 end,
                "to-do: multiplicity",
                self.isOperationMonitored(o)
                ]])
              end end
            end
          end;
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end  
    
    ///////////////////// Updates to the View ////////////////////
    
    @Operation sendNewPosition(idRequest, objectID, x, y)
        self.mapping.setNewPosition(objectID, x, y);
        self.communicator.sendMessageToJava([idRequest, []]) // empty result for compatibility
    end
    
    @Operation sendNewPositions(idRequest, objectID, listOfpoints)
        self.mapping.setNewPositions(objectID, listOfpoints);
        self.communicator.sendMessageToJava([idRequest, []]) // empty result for compatibility
    end
    
    ////////////////// Class Manipulations ///////////////////
    
    @Operation addMetaClass(idRequest, name, level, parents, abstract, x, y)
//        ("addMetaClass " + name 
//        + " on level " + level 
//        + " with parents " + parents 
//        + (if abstract then " and abstract " else " " end)
//        + "at position " + x + "/" + y).println(); 
        
        let 
          m = FmmlxDiagrams::FmmlxManipulator() 
        then 
          parentsList = self.getParentsList(parents)
        then 
          newClass = m.addMetaClass(package, name, level, parentsList, abstract)
        then
          mappingInfo = self.mapping.addOrGetObjectMapping(newClass)
        in 
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y
        end;
        self.communicator.sendMessageToJava([idRequest, []]) // temporary empty result 
    end 
    
    @Operation addInstance(idRequest, ofId, name, parents, abstract, x, y)
        //("addInstance " + name 
        //+ " of id " + ofId 
        //+ " with parents " + parents 
        //+ (if abstract then " and abstract " else " " end)
        //+ "at position " + x + "/" + y).println(); 
       
        let 
          m = FmmlxDiagrams::FmmlxManipulator() 
        then 
          ofClass = self.mapping.getMapping(ofId).object
        then
          parentsList = self.getParentsList(parents)
        then 
          newInstance = m.addInstance(package, ofClass, name, parentsList, abstract)
        then
          mappingInfo = self.mapping.addOrGetObjectMapping(newInstance)
        in 
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y
        end;
        self.communicator.sendMessageToJava([idRequest, []]) // temporary empty result 
    end 
    
    @Operation changeClassName(idRequest, classId, newName) 
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.mapping.getMapping(classId).object
      in
        m.changeClassName(class, newName)
      end;
      self.communicator.sendMessageToJava([idRequest, null]) // temporary empty result 
    end
    
    //////////////////////// Attribute Manipulations /////////////////////
    
    @Operation addAttribute(idRequest, classId, name, level, typeName, multiplicity)
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then 
        class = self.mapping.getMapping(classId).object;
        type = m.getTypeForName(typeName)
      then 
        problems = m.checkAddAttribute(class, name, level, typeName, multiplicity)
      in           
        if 
          problems.isEmpty() 
        then
          //problems := [0];
          problems := try 
            //problems := [1];
            m.addAttribute(class, name, level, type, multiplicity); null
            //;problems := [2]
            //;"addAttribute done".println()
          catch(e)
            //("caught " + e).println();
            //problems := 
            [("addAttribute failed during transaction: " + e.message)]
            //;problems.println()
          end // try
          //;problems.println()
        end; // if
        //problems.println();
        self.communicator.sendMessageToJava([idRequest, problems]) // return null or problems
      end // in       
    end 
    
    @Operation removeAttribute(idRequest, classId, attName, strategy) 
     // for now: ignore strategy and simply delete 
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.mapping.getMapping(classId).object
      in
        m.removeAttribute(class, attName, strategy)
      end;
      self.communicator.sendMessageToJava([idRequest, null]) // temporary empty result 
    end
    
    @Operation changeAttributeName(idRequest, classId, oldName, newName) 
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.mapping.getMapping(classId).object
      then 
        problems = m.checkChangeAttributeName(class, oldName, newName)
      in
        if problems.isEmpty() then m.changeAttributeName(class, oldName, newName) end;
        self.communicator.sendMessageToJava([idRequest, problems]) // return null or problems
      end
    end
    
    @Operation changeAttributeLevel(idRequest, classId, attName, oldLevel, newLevel)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.mapping.getMapping(classId).object
      then         
        problems = m.changeAttributeLevel(class, attName, oldLevel, newLevel)
      in
        if problems.isEmpty() then m.changeAttributeLevel(class, attName, oldLevel, newLevel) end;
        self.communicator.sendMessageToJava([idRequest, problems]) // return null or problems
      end
    end
      
      
      
      
    //////////////////////// Slot Manipulations /////////////////////

    @Operation changeSlotValue(idRequest, objId, slotName, valueToBeParsed)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        obj = self.mapping.getMapping(objId).object;
        error = null
      then
        class = obj.of()
      then
        atts = class.allAttributesForLevel(obj.level);
        foundAtt = null
      in
        @For att in atts do
          if att.name.toString() = slotName.toString() then
            foundAtt := att
          end
        end;
        if 
          foundAtt <> null 
        then
          m.changeSlotValue(obj, slotName, valueToBeParsed, foundAtt.type)
        else
          error := "no Slot Found"
        end;
        self.communicator.sendMessageToJava([idRequest, if error = null then null else [error] end]) // temporary empty result 
      end
    end
    
    //////////////// Local Operations ///////////////////
    
    @Operation getParentsList(parentIds) // for local use
      let list = [] in
        @For id in parentIds do
          if not id = -1 then list := list.append([mapping.getMapping(id).object]) end
        end; // for
        list
      end// let      
    end
         
    @Operation getParentIdList(c : FMML::MetaClass) // for local use
      let list = [] in
        @For p in c.parents do
          if p.isKindOf(FMML::MetaClass) then list := list.append([mapping.addOrGetObjectMapping(p).id]) end
        end; // for
        list
      end// let      
    end
    
    @Operation isOperationMonitored(o)
      if o.hasProperty("monitor") then self.getOpProp(o, "monitor") else false end
    end
    
    ////////////////// Operations for editing associations ///////////////////
    
  @Operation addAssociation(idRequest, 
      class1Id : Integer,
      class2Id : Integer,
      ref1 : String,
      ref2 : String,
      fwName : String,
      reverseName : String,
      mult1S : String,
      mult2S : String,
      instLevel1 : Integer,
      instLevel2 : Integer):XCore::Element
  	  
  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    class1 = self.mapping.getMapping(class1Id).object;
  	    class2 = self.mapping.getMapping(class2Id).object;
  	    mult1 = null;
  	    mult2 = null
      then 
        problems = [] /*m.checkAddAssociation(self.package,
  	      class1, class2,
  	      ref1, ref2,
  	      fwName, reverseName,
  	      mult1, mult2,
  	      instLevel1, instLevel2) */
      in
        if problems.isEmpty() then 
  	      problems := m.addAssociation(self.package,
  	        class1, class2,
  	        ref1, ref2,
  	        fwName, reverseName,
  	        mult1, mult2,
  	        instLevel1, instLevel2)
  	    end;
        self.communicator.sendMessageToJava([idRequest, problems]) // return null or problems
      end  	  
  	end    
  	
  	@Operation addAssociationInstance(idRequest, 
      obj1Id  : Integer,
      obj2Id  : Integer,
      assocId : Integer) 
  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    obj1 = self.mapping.getMapping(obj1Id).object;
  	    obj2 = self.mapping.getMapping(obj2Id).object;
  	    association = self.mapping.getMapping(assocId).object
  	  then 
        problems = m.addAssociationInstance(self.package, obj1, obj2, association)
  	  in
  	    self.communicator.sendMessageToJava([idRequest, problems]) // return null or problems
  	  end
    end
    
    ////////////////// Operations for editing operations ///////////////////

    @Operation changeOperationName(idRequest, classId, oldName, newName) 
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.mapping.getMapping(classId).object
      then 
        problems = m.checkChangeOperationName(class, oldName, newName)
      in
        if problems.isEmpty() then m.changeOperationName(class, oldName, newName) end;
        self.communicator.sendMessageToJava([idRequest, problems]) // return null or problems
      end
    end
    
    @Operation changeOperationLevel(idRequest, classId, name, oldLevel, newLevel) 
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.mapping.getMapping(classId).object
      then
        o = m.findOperation(class,name)
      then 
        problems = m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o))
      in
        self.communicator.sendMessageToJava([idRequest, problems]) // return null or problems
      end
    end
    
    @Operation addOperation(
      idRequest  : Integer, 
      classId    : Integer,
      opName     : String, 
      level      : Integer, 
      returnType : String, // ignore for now...
      body       : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.mapping.getMapping(classId).object
      then 
        problems = m.addOperation(class, opName, level, returnType, body)
      in
        self.communicator.sendMessageToJava([idRequest, problems]) // return null or problems
      end
    end
    
    @Operation getOpProp(operation, name) // for local use
      let
        properties = operation.properties();
        tagFound = null
      in 
        @For property in properties do  
          if property->head() = name
            then tagFound := property->tail()
          end
        end;
        tagFound
      end      
    end
    
    @Operation checkOperationNameLegal(op, name):Boolean // todo: check for duplicates, consider arity
      let nameSymbol = Symbol(name) in
        if nameSymbol = op.name()
        then
          true
        else
          op.legalNameChangeCheck(nameSymbol,op.name())
        end
      end
    end
    
    @Operation setOperationBody(idRequest, classId:Integer, opName:Operation, text:String)
      let 
        class = self.mapping.getMapping(classId).object
      then
        op = class.getOperation(opName)
      then
        newName = text.splitBy("()[]",0,0)->head.subst("","@Operation ",false)
      in
        if self.legalCheck(newName)
        then
          if Clients::checkParsable(contex,text)
          then
            Clients::setSource(contex,text)
          end
        end
      end;
      self.communicator.sendMessageToJava([idRequest, null]) // temporary empty result 
    end
    
end