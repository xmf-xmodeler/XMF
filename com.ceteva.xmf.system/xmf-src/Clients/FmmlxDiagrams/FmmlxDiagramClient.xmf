parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramClient extends Client//, DiagramListener

	@Attribute package : Package end
	@Attribute mapping : FmmlxDiagramMapping = FmmlxDiagramMapping() end
	@Attribute communicator : Element end

    @Constructor(name)
//      self.setCommandInterpreter(DiagramCommandInterpreter());
//      self.setEventHandler(DiagramEventHandler())
        null
    end
    
    @Operation createDiagram(package,name)
        self.package := package;
        let 
          FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self)
        in
          self.communicator := FmmlxDiagramCommunicator();
          self.communicator.setHandle(handle);
          self.communicator.newDiagram()
        end;
//        let x = FmmlxDiagram()
//        in 
//          ("x: "+x).println();
//          x.newDiagram();
//          ("name: "+name).println();
//          ("self.newDiagram("+self.name+")").println();
//          x
//        end
        FmmlxDiagram() // vestigial return value for diagram manager
    end
    
    @Operation getAllObjects(idRequest)
        let 
          result = [] 
        in 
    	  @For c in package.getChildren() do
    	    if c.isKindOf(FMML::MetaClass) 
    	    then
    	      let
    	        mapping = mapping.addOrGetObjectMapping(c)
    	      in
    	        result := result.append([[
    	        mapping.id, 
    	        c.name.toString(), 
    	        c.level, // level
    	        -1,// of-ID
    	        [],// parents-ID
    	        mapping.lastKnownDiagramX, 
    	        mapping.lastKnownDiagramY]])
    	      end
    	      //("mapping of " + c + " is " + mapping.addOrGetObjectMapping(c)).println();
    	      /*
    	      if c is not in mapping
    	        add c to mapping
    	      return c with mapping info
    	      */
    	      //result := result.append([c.name.toString()])
    	    end
    	  end;
    	  // clean up mapping ? 
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
    
    @Operation getOwnAttributes(idRequest, className) 
        let 
          result = [] 
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For a in c.attributes do 
                result := result.append([[a.name.toString(), a.type.name.toString(), a.instLevel, a.mult()]])
              end
            end
          end;
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
     
    @Operation getAllAttributes(idRequest, className) 
        let 
          resultOwn   = [];
          resultOther = [];
          result = []
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For a in c.attributes do 
                resultOwn   :=   resultOwn.append([[a.name.toString(), a.type.name.toString(), a.instLevel, a.mult()]])
              end;
              @For a in (c.allAttributes() - c.attributes) do 
                if a.isIntrinsic then
                  resultOther := resultOther.append([[a.name.toString(), a.type.name.toString(), a.instLevel, a.mult()]])
                end
              end            
            end
          end;
          result := [resultOwn, resultOther];
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
    
    @Operation getSlots(idRequest, objectName) 
        let 
          result = [] 
        in 
          @For o in package.getChildren() do 
            if o.isKindOf(FMML::MetaClass) and o.name.toString() = objectName
            then 
              @For s in o.slots() do 
                result := result.append([[s.name.toString(), s.value.toString()]])
              end
            end
          end;
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end
      
    @Operation getOwnOperations(idRequest, className) 
        let 
          result = [] 
        in 
          @For c in package.getChildren() do 
            if c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then 
              @For o in c.operations do 
                result := result.append([[o.name.toString(), o.type.name.toString(), o.instLevel]])
              end
            end
          end;
    	  self.communicator.sendMessageToJava([idRequest, result])
        end
    end  
    
    @Operation sendNewPosition(idRequest, objectID, x, y)
        mapping.setNewPosition(objectID, x, y);
        self.communicator.sendMessageToJava([idRequest, []]) // empty result for compatibility
    end
    
    @Operation addMetaClass(idRequest, name, level, parents, abstract, x, y)
        ("addMetaClass " + name 
        + " on level " + level 
        + " with parents " + parents 
        + (if abstract then " and abstract " else " " end)
        + "at position " + x + "/" + y).println(); 
        
        let 
          m = FmmlxDiagrams::FmmlxManipulator() 
        then 
          newClass = m.addMetaClass(package, name, level, parents, abstract)
        then
          mappingInfo = mapping.addOrGetObjectMapping(newClass)
        in 
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y
        end;
        "addNewMetaClass done".println();
        self.communicator.sendMessageToJava([idRequest, [null]]) // temporary empty result 
    end 
    
    @Operation addInstance(idRequest, ofId, name, parents, abstract, x, y)
        ("addInstance " + name 
        + " of id " + ofId 
        + " with parents " + parents 
        + (if abstract then " and abstract " else " " end)
        + "at position " + x + "/" + y).println(); 
        
        let 
          m = FmmlxDiagrams::FmmlxManipulator() 
        then 
          ofClass = mapping.getMapping(ofId).object
        then 
          newInstance = m.addInstance(package, ofClass, name, parents, abstract)
        then
          mappingInfo = mapping.addOrGetObjectMapping(newInstance)
        in 
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y
        end;
        "addInstance done".println();
        self.communicator.sendMessageToJava([idRequest, [null]]) // temporary empty result 
    end 
end