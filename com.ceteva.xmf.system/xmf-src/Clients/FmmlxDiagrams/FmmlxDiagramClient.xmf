parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramClient extends Client

    @Attribute communicator : Element end
    @Attribute log : Seq(Element) = [] end
    @Attribute diagrams : Table = Table(10) end
    
    @Constructor(name)
      ("invoking FmmlxDiagramClient: " +  name).println();
//      self.setCommandInterpreter(DiagramCommandInterpreter());
//      self.setEventHandler(DiagramEventHandler())
        null
    end
    
    /* This operation returns an instance of 
      the java class "FmmlxDiagramCommunicator",
    For the only instance of FmmlxDiagramClient,
      there is only one instance of the communicator, 
      which is created once, if not yet present.
    */
    @Operation getCommunicator()
      if self.communicator = null then
        let
          FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self)
        in
          self.communicator := FmmlxDiagramCommunicator();
          self.communicator.setHandle(handle)
        end
      end;
      self.communicator
    end

    /* this (3) operation(s) is invoked when "show in diagram" 
       in the menu of the package is invoked.
       
       It allows the user to pick an existing one or to create a new one. */
       
    @Operation showDiagram(package,name)
      let 
        key = self.findDiagram(package,name)
      in
        self.showDiagramInView(key)
      end
    end
    
    @Operation showDiagramInView(key)
      if 
        key <> null
      then
        self.getCommunicator().newDiagram( // <-- from the java's point of view a NEW diagram is created
          key, 
          self.diagrams.get(key).diagramName.toString(), 
          self.diagrams.get(key).package.path(),
          self.diagrams.get(key).file.toString())
      end
    end    
    
    @Operation findDiagram(package,name)    
      let
        selectedNames = xmf.selects("Select Diagram",
          "select existing diagram - or none for new", 
          diagrams.values()->select(d | d.diagramType = FmmlxDiagramType::ClassDiagram).diagramName,
          {},
          null)
      in
        if selectedNames = -1 then selectedNames := [] end;
        if
          selectedNames.size() = 0
        then
          self.createNewDiagram(package,name, "", FmmlxDiagramType::ClassDiagram) // <-- create a new diagram (always a class diagram)
        elseif
          selectedNames.size() = 1
        then // if one name supplied: find it!
          let
            selectedName = selectedNames.at(0);
            keys = self.diagrams.keys();
            key = null;
            keyCount = 0
          in
            @While key = null and keyCount < keys.size() do
              if diagrams.get(keys.at(keyCount)).diagramName.toString() = selectedName.toString() then key := keys.at(keyCount) end;
              keyCount := keyCount + 1
            end;
            if key <> null then // <-- found an old diagram with that name
              //self.communicator.reopenDiagram(key, selectedName.toString(), diagrams.get(key).package.path())
              key
              //self.communicator.newDiagram(key, diagrams.get(key).diagramName.toString(), diagrams.get(key).package.path()) // <-- from the java's point of view a NEW diagram is created
            else
              null
              //"diagram not found".println()
            end
          end
        end
      end
    end

    @Operation createDiagramFromJava(packagePath, diagramName, file, typeAsString)
      let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    type = FmmlxDiagramType.getElement(typeAsString)
      then
        package = m.evalString(packagePath, Root).at(0)
      then
        newID = self.createNewDiagram(package, diagramName, file, type)
      in
        self.communicator.setNewDiagramId(newID)
      end      
    end

    /* This Operation creates a new diagram, 
       and returns its key!!! ... */
    @Operation createNewDiagram(package:Package, name:String, file:String, type:FmmlxDiagramType)
      //null.foo;
      //self.package := package;
       ///////////FIND ALTERNATIVE TO THIS///////////////////
      if
        package.of() <> FMML::FMMLxPackage
      then
        package.setOf(FMML::FMMLxPackage);
        Kernel_addAtt(package,"fmmlxAssociationInstances",{})
      end;
        //self.addDefaultEnums(package);
      //////////////////////////////////////////////////////
        
      let 
        handle = xmf.getHandle(self);
        diagram = FmmlxDiagram();
        newID = 0
      in
        @While diagrams.hasKey(newID) do newID := newID + 1 end;
        diagram.diagramName := ("Diagram " + package.name + " (id " + newID + ")");
        diagram.package := package;
        diagram.file := file;
        diagram.diagramType := type;
        self.diagrams.put(newID, diagram);
        
        //diagram
        newID
      end
    end
    
    // This operation is invoked by the java side while the window is closing
    @Operation closeDiagram(requestID, keepDiagram : Boolean) 
      let
        diagramID = self.vector2Seq(requestID).at(0)
      in
        if not keepDiagram then self.diagrams.remove(diagramID) end
      end
    end

    @Operation getMapping(requestID : Seq(Integer))
      self.diagrams.get(self.vector2Seq(requestID).at(0)).mapping
    end
    
    @Operation getPackage(requestID : Seq(Integer))
      self.diagrams.get(self.vector2Seq(requestID).at(0)).package
    end

    //////////////////////// Queries ///////////////////////////////
    
    @Operation getAllObjectPositions(requestID : Seq(Integer), diagramID)
      let 
        result = [];
        diagram = self.diagrams.get(diagramID)
      then
        package = diagram.package;
        mapping = diagram.mapping
      in
        @For c in package.classes->select(x | x.isKindOf(FMML::MetaClass)) do
          let
    	    mappingInfo = mapping.addOrGetObjectMapping(c)	        
    	  in
    	    result := result.append([[
			  c.path(), // ownPath
    	      mappingInfo.lastKnownDiagramX,
    	      mappingInfo.lastKnownDiagramY,
			  mappingInfo.hidden,
			  diagram.toString()
			  ]])
	      end
	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllEdgePositions(requestID : Seq(Integer), diagramID)
      let 
        result = [];
        diagram = self.diagrams.get(diagramID)
      then
        package = diagram.package;
        mapping = diagram.mapping
      in
        @For mappingItem in mapping.mapping do
          let
    	    obj = mappingItem.object
    	  then
    	    key = if obj.isKindOf(Associations::Association) then obj.name else obj end
    	  in
    	    if not obj.isKindOf(FMML::MetaClass) then 
    	      result := result.append([[
                key.toString(),
                mappingItem.points]])
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllLabelPositions(requestID : Seq(Integer), diagramID)
      self.getCommunicator()
          .sendMessageToJava([self.vector2Seq(requestID), 
               self
                  .diagrams
                  .get(diagramID)
                  .mapping
                  .labelMapping
                  .asSeq()])
    end

    @Operation getAllObjects(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For c in self.getPackage(requestID).classes do
    	    if c <> null andthen c.isKindOf(FMML::MetaClass) andthen c.level > -1 // TODO: find out how a null can possibly end up there
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(c)	        
    	      in
    	        result := result.append([[
    	        					-1, //mappingInfo.id, // 0: id*
    	        c.name.toString(), // 1: name
    	        c.level, // level  // 2: level
    	        					-1, //if c.of().isKindOf(FMML::MetaClass) then self.getMapping(requestID).addOrGetObjectMapping(c.of()).id else -1 end,// 3: of-ID
    	        					-1, // self.getParentIdList(requestID, c),//[],// 4: parents-ID
    	        c.isAbstract, // 5
    	        mappingInfo.lastKnownDiagramX, // 6
    	        mappingInfo.lastKnownDiagramY, // 7
    	        mappingInfo.hidden, // 8: visibility in this diagram
    	        					-1, // 9: reserved for delegation
    	        c.path(), // 10: ownPath
    	        c.of().path(), // 11: ofPath
    	        self.getParentsPathsList(requestID, c)// 12: parentsPaths
    	        ]])
    	      end
    	    /*else
    	      result := result + [[
    	      -2, // fake
    	      c.name.toString(),
    	      -1, // non-intrinsic
    	      -2, [],
    	      c.isAbstract,
    	      0,0,false,0,
              c.path(), // 10: ownPath
              c.of().path(), // 11: ofPath
              self.getParentsPathsList(requestID, c)// 12: parentsPaths
    	      ]]*/
    	    end
    	  end;
    	  // clean up mapping ?
    	  if requestID <> -3 then self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result]) end
        end
    end

    @Operation getAllDelegationEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object <> null andthen object.delegatesTo <> null then
            if object.delegatesTo.isKindOf(FMML::MetaClass) then
              let
                //delegatesFromPath = self.getMapping(requestID).addOrGetObjectMapping(object).object.path();
                //delegatesToPath = self.getMapping(requestID).addOrGetObjectMapping(object.delegatesTo).object.path();
                //delegatesToLevel = self.getMapping(requestID).addOrGetObjectMapping(object.delegatesToLevel).object.path()
                delegatesFromPath = object.path();
                delegatesToPath = object.delegatesTo.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createDelegationKey(delegatesFromPath, delegatesToPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            delegatesFromPath, // 1 start Path
  	            delegatesToPath, // 2 end Path
  	            object.delegatesToLevel, // 3 level
  	            mappingInfo.points // 4 points
  	          ]])
              end
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllRoleFillerEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object <> null then if object.roleFiller <> null then
            if object.roleFiller.isKindOf(FMML::MetaClass) then
              let
                childPath = self.getMapping(requestID).addOrGetObjectMapping(object).object.path();
                parentPath = self.getMapping(requestID).addOrGetObjectMapping(object.roleFiller).object.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createRoleKey(childPath, parentPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            childPath, // 1 start ID
  	            parentPath, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllInheritanceEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object <> null then @For parent in object.parents do
            if parent.isKindOf(FMML::MetaClass) then
              let
                childPath = self.getMapping(requestID).addOrGetObjectMapping(object).object.path();
                parentPath = self.getMapping(requestID).addOrGetObjectMapping(parent).object.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createInheritanceKey(childPath, parentPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            childPath, // 1 start ID
  	            parentPath, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllAssociations(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For a in self.getPackage(requestID).associations do
    	    if a.isKindOf(Associations::Association)
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(a)
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          a.end1.type.path(), // 1 source ID
    	          a.end2.type.path(), // 2 target ID
    	          -1, // 3 parent ID
    	          mappingInfo.points, // 4 points
    	          a.name.toString(), // 5 name 1
    	          null, // 6 name 2
    	          a.end2.name.toString(), // 7 name start->end slot name
    	          a.end1.name.toString(), // 8 name end->start slot name
    	          a.end2.instLevel, // 9 level of source
    	          a.end1.instLevel, // 10 level of target
    	          FmmlxManipulator::multiplicity2ValueList(a.end2.mult()), // 11 mul s->t
    	          FmmlxManipulator::multiplicity2ValueList(a.end1.mult()),  // 12 mul t->s
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id), // 13 labels
    	          a.end1.visible, // 14 visibility t->s
    	          a.end2.visible, // 15 visibility s->t
    	          a.symmetric, // 16
    	          a.transitive // 17
    	        ]])
    	      end // let
    	    else ("a is of " + a.of()).println()
    	    end // if
    	  end;
    	  // clean up mapping ?
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAssociationInstances(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For i in (if self.getPackage(requestID).fmmlxAssociationInstances = null then {} else self.getPackage(requestID).fmmlxAssociationInstances end) do

    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createAssociationLinkKey(i.at(0).path(), i.at(1).path(), i.at(2).path()))
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          i.at(0).path(), // 1 start ID
    	          i.at(1).path(), // 2 end ID
    	          i.at(2).path(), // 3 assoc ID
    	          mappingInfo.points, // 4 points
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id) // 5 labels
    	        ]])
    	      end // let
    	  end;
    	  // clean up mapping ?
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAttributes(requestID : Seq(Integer))
        let
          result = []
        in
          @For c in self.getPackage(requestID).classes->select(x | x.level > 0) do
            let
              resultOwn   = [];
              resultOther = []
            in
              if c <> null
              then
                @For a in c.attributes do
                  resultOwn   :=   resultOwn.append([[
                      a.name.toString(),
                      a.type.name.toString(),
                      if a.isIntrinsic then a.instLevel else -1 end,
                      FmmlxManipulator::multiplicity2ValueList(a.mult()),
                      c.path()
                      ]])
                end; // for own
                @For a in (c.allAttributes() - c.attributes) do
                  if a.isIntrinsic orelse self.attIsInList(a) then
                    resultOther := resultOther.append([[
                      a.name.toString(),
                      a.type.name.toString(),
                      if a.isIntrinsic then a.instLevel else -1 end,
                      FmmlxManipulator::multiplicity2ValueList(a.mult()),
                      a.owner.path()
                      ]])
                  end
                end; // for other
                result := result + [[c.path(), resultOwn, resultOther]]
              end // let
            end // if <> null
          end; // for
          //result := [resultOwn, resultOther];
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end // let
    end
    
    @Operation getAllOperations(requestID : Seq(Integer))
      let
        result = []
      in
        @For c in self.getPackage(requestID).classes->select(x | x.level > 0) do
          let 
            resultLocal = []
          in            
            if c <> null 
              andthen c.isKindOf(FMML::MetaClass)
            then
              @For o in c.allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
                let
                  paramNames = o.paramNames();
                  paramTypesRaw = o.paramTypes();
                  paramTypes = []
                in
                  @For type in paramTypesRaw do
                    paramTypes := paramTypes.append([self.getPathAsString(type)])
                  end;
                  resultLocal := resultLocal.append([[
                  o.name.toString(),
                  paramNames,
                  paramTypes,
                  o.instLevel,
                  self.getReturnPathAsString(o),
                  o.source(),
                  o.owner.path(),
                  //if o.owner.isKindOf(FMML::MetaClass) then self.getMapping(requestID).getMappingId(o.owner) else -1 end,
                  [0,1,false,true], // to-do: multiplicity
                  self.isOperationMonitored(o),
                  let P = o.properties(); b = false in @For p in P do if p->head() = "delToClassAllowed" then b := p->tail() end end; b end
                  ]])
                end
              end end
            end;
            
            if c <> null 
              andthen (not c.isKindOf(FMML::MetaClass))
            then
              @For o in c.operations do if (not o.owner = null) then
                let
                  paramNames = o.paramNames();
                  paramTypesRaw = o.paramTypes();
                  paramTypes = []
                in
                  @For type in paramTypesRaw do
                    paramTypes := paramTypes.append([self.getPathAsString(type)])
                  end;
                  resultLocal := resultLocal.append([[
                  o.name.toString(),
                  paramNames,
                  paramTypes,
                  -1,
                  self.getReturnPathAsString(o),
                  o.source(),
                  o.owner.path(),
                  //if o.owner.isKindOf(FMML::MetaClass) then self.getMapping(requestID).getMappingId(o.owner) else -1 end,
                  [0,1,false,true], // to-do: multiplicity
                  self.isOperationMonitored(o),
                  false
                  ]])
                end
              end end
            end; // if <> null
            result := result + [[c.path(), resultLocal]]
          end // let
        end; // for
  	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end // let
    end
    
    @Operation getAllConstraints(requestID : Seq(Integer))
      let
        result = []
      in
        @For c in self.getPackage(requestID).classes->select(x | x.level > 0) do
          let
            localResult = []
          in
            if c <> null 
              andthen c.isKindOf(FMML::MetaClass) 
            then
              @For con in c.constraints do if (not con.owner = null) then
                localResult := localResult.append([[
                  con.name.toString(),
                  con.body.instLevel,
                  con.body.getProperty("raw", "Error: raw source not found"),
                  con.body.source(),
                  con.reason.getProperty("raw", "Error: raw source not found"),
                  con.reason.source()]])
              end end; // for+if
              result := result + [[c.path(), localResult]]
            end // if <> null
          end // let local
        end; // for
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end  // let
    end // O
    
    
    @Operation attIsInList(a) false end
//      if a.owner = NamedElement andthen a.name.toString() = "name" then true
//      elseif a.owner = Class  andthen a.name.toString() = "level" then true
//      else false end
//    end

    @Operation getSlots(requestID : Seq(Integer), objectName, slotList)
      let
        result = []
      in
        @For o in self.getPackage(requestID).classes do
          if o <> null andthen o.isKindOf(FMML::MetaClass) andthen o.name.toString() = objectName
          then
            @For name in slotList do
              if o.hasSlot(name)
              then
                let
                  value = o.get(name)
                then
                  text = if value.of().isKindOf(Enum) then value.name().toString() else value.toString() end
                in
                  result := result.append([[name, text]])
                end
              end
            end
          end
        end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getOperationValues(requestID : Seq(Integer), objectName, opNames)
      let
        result = [];
        p = self.getPackage(requestID)        
      in
        @For n in opNames do
          let
            opResult = FmmlxDiagrams::FmmlxManipulator().evalString(objectName + "." + n + "()", p)
          then
            value = opResult.at(0);
            error = opResult.at(1);
            monMin = false;//o.hasProperty("monitorMin");
            monMax = false//o.hasProperty("monitorMax")
          then
            minVal = null;//if monMin then FmmlxDiagramClient::getOpProp(o, "monitorMin") else null end;
            maxVal = null//if monMax then FmmlxDiagramClient::getOpProp(o, "monitorMax") else null end
          then
            hasRange = monMin or monMax or error <> null;
            isInRange = (error = null) andthen
                        if monMin then minVal <= value else true end andthen
                        if monMax then maxVal >= value else true end
          in
            result := result.append([[
              n,
              if error = null then value.toString() else error.toString() end, // error should be of type String
              hasRange,
              isInRange]])
          end // let
        end; // for names
//          end // if obj <> null
//        end; // for obj
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getPathAsString(type:Class)
      try type.path() catch(e) Element.path() end
    end

    @Operation getReturnPathAsString(o) //:Operation
      try o.type().path() catch(e) Element.path() end
    end
    
    @Operation getAllEnums(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For e in self.getPackage(requestID).classes do
    	    if e  <> null andthen e.isKindOf(Enum)
    	    then
    	      let
    	        enumItems = e.getChildren();
    	        itemList = []
    	      in
    	        @For item in enumItems do
    	          itemList := itemList + [item.name.toString()]
    	        end;
    	        result := result.append([[
    	        e.name.toString(),
    	        itemList]])
    	      end
    	    end
    	  end;
    	  // clean up mapping ?
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAuxTypes(requestID : Seq(Integer))
      let
        result = []
      in
        if Root.hasElement("Auxiliary") then
    	  @For ac in Root::Auxiliary.getChildren() do
    	    if
    	      ac.isKindOf(Class)
    	    then
    	      result := result.append([[ac.name.toString()]])
    	    end
    	  end
    	end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllDiagrams(requestID : Seq(Integer), packagePath : String) 
      let 
        result = []      
      in
        @For key in diagrams.keys() do
          if 
            diagrams.get(key).package.path().equals(packagePath)
          andthen
            diagrams.get(key).diagramType = FmmlxDiagramType::ClassDiagram
          then
            result := result + [key]
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllIssues(requestID : Seq(Integer))
      let
        result = []
      in
        @For obj in self.getPackage(requestID).classes do if obj <> null andthen obj.isKindOf(FMML::MetaClass) then
		  @For slot in obj.slots() do
		    if self.getPackage(requestID).classes.contains(slot.type.owner) then
		      if slot.type.mult().lowerBound > 0 andthen slot.value = null then
		        result := result + [[
		        "SLOT_NULL",
		        "The slot " + slot.name + " must not be empty.",
		        [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		        ["setSlotValue", self.getMapping(requestID).addOrGetObjectMapping(obj).id, slot.name.toString()]]]
		      end // if null and mandatory
		    end // if slot fmmlx
		  end; // for slots
		  if obj.delegatesTo <> null then @For otherObj in self.getPackage(requestID).classes do // if for (check delegation)
		    if FmmlxManipulator::isInstanceOf(otherObj, obj, obj.delegatesToLevel) andthen 
		     ( otherObj.roleFiller = null orelse not FmmlxManipulator::isInstanceOf(otherObj.roleFiller, obj.delegatesTo, obj.delegatesToLevel))
			then result := result + [[
			    "NO_ROLE_FILLER",
			    "A role filler is required",
			    [self.getMapping(requestID).addOrGetObjectMapping(otherObj).id],
			    ["addRoleFiller",
			      self.getMapping(requestID).addOrGetObjectMapping(otherObj).id,
			      self.getMapping(requestID).addOrGetObjectMapping(obj.delegatesTo).id]]]
			end
		  end end; // for/if delegation
/*		  if obj.of().isKindOf(FMML::MetaClass) andthen obj.of().delegatesTo <> null and obj.roleFiller = null
		  then result := result + [[
		    "NO_ROLE_FILLER",
		    "A role filler is required",
		    [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		    ["addRoleFiller",
		      self.getMapping(requestID).addOrGetObjectMapping(obj).id,
		      self.getMapping(requestID).addOrGetObjectMapping(obj.of().delegatesTo).id]]]
		  end;
*/		  @For assoc in self.getPackage(requestID).associations do
		    if FmmlxManipulator::isInstanceOf(obj, assoc.end1.type, assoc.end1.instLevel) // if obj fits sourceDef
		    then
		      let
		        count = FmmlxManipulator::countOccurences(obj, self.getPackage(requestID), assoc, true, false) // how many links go out of obj as source
		      in
		        if
		          count < assoc.end2.mult().lowerBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_LOW",
		            "The association " + assoc.name + " requires more links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["addMissingLink", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end;
		        if
		          assoc.end2.mult().hasUpperBound() andthen count > assoc.end2.mult().upperBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_HIGH",
		            "The association " + assoc.name + " requires fewer links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["removeTooManyLinks", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end
		      end // let
		    end; // if instance of
		    if FmmlxManipulator::isInstanceOf(obj, assoc.end2.type, assoc.end2.instLevel) // if obj fits targetDef
		    then
		      let
		        count = FmmlxManipulator::countOccurences(obj, self.getPackage(requestID), assoc, false, true)
		      in
		        if
		          count < assoc.end1.mult().lowerBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_LOW",
		            "The association " + assoc.name + " requires more links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["addMissingLink", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end;
		        if
		          assoc.end1.mult().hasUpperBound() andthen count > assoc.end1.mult().upperBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_HIGH",
		            "The association " + assoc.name + " requires fewer links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["removeTooManyLinks", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end
		      end // let
		    end // if instance of
		  end; // for assoc
		  
		  let 
		    constraintReport = obj.checkConstraints()
		  in
		    @For crItem in constraintReport.failures() do //constraintReport.children() do
		      // crItem.reason
		      result := result + [[
		        "CONSTRAINT_FAILURE",
		        crItem.reason,
		        [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		        ["no solution available"]]]
		    end
		  end		    

		end end; // for/if obj
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    ///////////////////// Updates to the View ////////////////////

    @Operation sendNewPosition(requestID : Seq(Integer), objectPath, x:Integer, y:Integer, hidden:Boolean)
        self.getMapping(requestID).setNewPosition(objectPath, x, y, hidden);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation sendNewPositions(requestID : Seq(Integer), edgeID, listOfpoints)
        self.getMapping(requestID).setNewPositions(edgeID, listOfpoints);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation storeLabelInfo(requestID : Seq(Integer), edgeID, localID, x, y)
        self.getMapping(requestID).storeLabelInfo(edgeID, localID, x, y);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    ////////////////// Class Manipulations ///////////////////

    @Operation addMetaClass(requestID : Seq(Integer), name, level, parents, abstract, x, y)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        parentsList = self.getParentsList(requestID, parents);
        problems = []
      in
        problems := problems + if not Symbol(name).isValidName() then ["name " + name + " not legal."] else [] end;
        problems := problems + if self.getPackage(requestID).hasElement(name) then ["name " + name + " already in use."] else [] end;
        if problems.isEmpty() then
          let 
            newClass = m.addMetaClass(self.getPackage(requestID), name, level, parentsList, abstract)
          then
            mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newClass)
          in
            mappingInfo.lastKnownDiagramX := x;
            mappingInfo.lastKnownDiagramY := y;
            self.log := self.log + [["addMetaClass", 
              ["package", newClass.owner.path()], 
              ["name",name], 
              ["level",level+""], 
              ["parents",self.getParentsPaths(requestID, parentsList)], 
              ["abstract",abstract+""]]]
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end  
    end

    @Operation addInstance(
            requestID : Seq(Integer),
            ofName,
            name,
            parents,
            abstract,
            x, y,
            slotValueList: Seq(Seq(String)) )
        try
          let
            m = FmmlxDiagrams::FmmlxManipulator()
          then
            ofClass = if self.getPackage(requestID).hasElement(ofName) then self.getPackage(requestID).getElement(ofName) else null end;
            parentsList = self.getParentsList(requestID, parents)
          in
            if 
              ofClass.isAbstract 
            then 
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["Abstract class " + ofClass.name.toString() + " cannot be instantiated."]])
            elseif 
              not Symbol(name).isValidName() 
            then 
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["name " + name + " not legal."]])
            elseif 
              self.getPackage(requestID).hasElement(name)
            then 
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["name " + name + " already in use."]])
            else
              let
                newInstance = m.addInstance(self.getPackage(requestID), ofClass, name, parentsList, abstract, slotValueList)
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newInstance)
              in
                mappingInfo.lastKnownDiagramX := x;
                mappingInfo.lastKnownDiagramY := y;
                self.log := self.log + [["addInstance", ["package", newInstance.owner.path()], ["of", ofClass.path()] , ["name",name] , ["parents",self.getParentsPaths(requestID, parentsList)] , ["abstract",abstract+""]]];
                self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
              end
            end
          end          
        catch (exception)
          self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), [exception.message]])
        end
    end

    @Operation removeClass(requestID : Seq(Integer), className, strategy)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        classPath4Log = class.path()
      in
        m.removeClass(class, strategy);
        self.log := self.log + 	[["removeClass", ["package", self.getPackage(requestID).path()], ["class", classPath4Log]]]
      end;
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result 
    end

    @Operation changeClassName(requestID : Seq(Integer), className, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        oldPath = class.path()
      in
        m.changeClassName(class, newName);
        self.getMapping(requestID).updateKey(oldPath, class.path());
        self.log := self.log + [["changeClassName", ["package", class.owner.path()], ["class", className] , ["newName",newName]]]
      end;
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation setClassAbstract(requestID : Seq(Integer), className, isAbstract)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.changeClassAbstract(class, isAbstract) else ["Class not found"] end
      in
        if problems.isEmpty() then
          self.log := self.log + [["setClassAbstract", ["package", class.owner.path()], ["class", class.path()] , ["abstract",isAbstract+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation levelRaiseAll(requestID : Seq(Integer), amount)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.levelRaiseAll(self.getPackage(requestID), amount)
      in
        if problems.isEmpty() then
           self.log := self.log + [["levelRaiseAll", ["package", self.getPackage(requestID).path()], ["amount", amount+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeParent(requestID : Seq(Integer), className, oldList, newList)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        oldSet = self.vector2Seq(oldList).asSet();
        newSet = self.vector2Seq(newList).asSet();
        problems = [];
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        oldParentList = class.parents->select(c | c.owner = class.owner); // for Log
        addSet = newSet - oldSet;
        removeSet = oldSet - newSet
      in
//        if
//          removeSet = {}
//        then
          @For parentName in addSet do
            let
              pr = m.evalString(parentName, self.getPackage(requestID))
            then
              parentToBeAdded = if pr.at(1) = null then pr.at(0) else null end
            in
              problems := problems + if parentToBeAdded = null then ["Cannot find new parent " + parentName] else m.addParent(class, parentToBeAdded) end
            end
          end
;//        elseif
//          addSet = {}
//        then
          @For parentName in removeSet do
            let
              pr = m.evalString(parentName, self.getPackage(requestID))
            then
              parentToBeRemoved = if pr.at(1) = null then pr.at(0) else null end
            in
              problems := problems + if parentToBeRemoved = null then ["Cannot find old parent " + parentName] else m.removeParent(class, parentToBeRemoved) end
            end
          end
;//        elseif
//          removeSet.size() = 1 and addSet.size() = 1 // move exactly one parent
//        then
//          let
//            parentToBeAdded = self.getMapping(requestID).getMapping(addSet.asSeq().at(0)).object;
//            parentToBeRemoved = self.getMapping(requestID).getMapping(removeSet.asSeq().at(0)).object
//          in
//            problems := problems + m.moveParent(class, parentToBeRemoved, parentToBeAdded)
//          end
//        else
//          problems := problems + ["Only one parent may be moved at a time."]
//        end;
        if problems.isEmpty() then
          self.log := self.log + [[
          "changeParent", 
          ["package", class.owner.path()], 
          ["class", class.path()], 
          ["old", self.getParentsPaths(requestID, oldParentList)], 
          ["new", self.getParentsPaths(requestID, class.parents->select(c | c.owner = class.owner))]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    //////////////////////// Attribute Manipulations /////////////////////

    @Operation addAttribute(requestID : Seq(Integer), className, name, level, typeName, multiplicityV)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
//        class = self.getMapping(requestID).getMapping(classId).object;
        type = m.getTypeForName(typeName, self.getPackage(requestID));
        multiplicity = m.valueList2Multiplicity(self.vector2Seq(multiplicityV))
      then
        problems = if class <> null then m.checkAddAttribute(class, name, level, typeName, null) else ["Class not found"] end
      in
        if
          problems.isEmpty()
        then
          problems := try
            m.addAttribute(class, name, level, type, multiplicity); []
          catch(e)
            [("addAttribute failed during transaction: " + e.message)]
          end // try
        end; // if
        if problems.isEmpty() then
            self.log := self.log + [["addAttribute", 
                                            ["package", class.owner.path()],
                                            ["class", class.path()],
                                            ["name", name.toString()],
                                            ["level", level+""],
                                            ["type", type.path()],
                                            ["multiplicity",  FmmlxManipulator::multiplicity2ValueList(multiplicity)+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end // in
    end

    @Operation changeAttributeName(requestID : Seq(Integer), className, oldName, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
          then
		class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeAttributeName(class, oldName, newName) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeAttributeName(class, oldName, newName);
          self.log := self.log + [["changeAttributeName", ["package", class.owner.path()], ["class", class.path()] , ["oldName", oldName] , ["newName", newName]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeLevel(requestID : Seq(Integer), className, attName, oldLevel, newLevel)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel) else ["Class not found"] end
        //problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
      in
        if problems.isEmpty() then
          m.changeAttributeLevel(class, attName, oldLevel, newLevel);
          self.log := self.log + [["changeAttributeLevel", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldLevel", oldLevel+""] , ["newLevel", newLevel+""]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeType(requestID : Seq(Integer), className, attName, oldTypeName, newTypeName)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
          class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        problems = if class <> null then m.checkChangeAttributeType(class, attName, oldTypeName, newTypeName, self.getPackage(requestID)) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeAttributeType(class, attName, oldTypeName, newTypeName, self.getPackage(requestID));
          self.log := self.log + [["changeAttributeType", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldType", oldTypeName] , ["newType", newTypeName]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeMultiplicity(requestID : Seq(Integer), className, attName, oldMul, newMul)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        oldMult = m.valueList2Multiplicity(self.vector2Seq(oldMul));
        newMult = m.valueList2Multiplicity(self.vector2Seq(newMul))
      then    // TODO !!!
//          problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
         problems = []
         
      in
        if problems.isEmpty() then
          m.changeAttributeMultiplicity(class, attName, null, newMult);
          self.log := self.log + [["changeAttributeMultiplicity", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldMul", FmmlxManipulator::multiplicity2ValueList(oldMult)+""] , ["newMul", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation removeAttribute(requestID : Seq(Integer), className, attName, strategy)
     // for now: ignore strategy and simply delete
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      in
        m.removeAttribute(class, attName, strategy);
        self.log := self.log + [["removeAttribute", ["package", class.owner.path()], ["class", class.path()], ["name", attName]]]
      end;
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result
    end

    //////////////////////// Slot Manipulations /////////////////////

    @Operation changeSlotValue(requestID : Seq(Integer), className, slotName, valueToBeParsed)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        obj = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
        error = null
      then
        class = obj.of();
        foundAtt = m.findAttributeForSlot(obj, slotName)
      in
        if
          foundAtt <> null
        then
          let
            parseResult = m.evalString(valueToBeParsed, self.getPackage(requestID))
          in
            if parseResult.at(1) = null then
              error := m.changeSlotValue(obj, slotName, parseResult.at(0), foundAtt.type, self.getPackage(requestID))
            else
              error := parseResult.at(1) // error as message or as return value? maybe try exceptions...
            end
          end

        else
          error := "slot " + slotName + " not found in " + className
        end;
	  self.log := self.log + [["changeSlotValue", 
                                  ["package", class.owner.path()],
                                  ["class", obj.path()],
                                  ["slotName", slotName],
                                  ["valueToBeParsed", valueToBeParsed]]];
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), if error = null then null else [error] end]) // temporary empty result
      end
    end

    //////////////// Local Operations ///////////////////

    @Operation vector2Seq(vec) // for local use
      let list = [] in
        @For id in vec do
          list := list.append([id])
        end; // for
        list
      end// let
    end

    @Operation getParentsList(requestID, parentNames) // for local use
      let
        list = [];
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        @For name in parentNames do
        let
            parent = try m.getTypeForName(name, self.getPackage(requestID)) catch(e) null end
        in
            if not parent = null then list := list.append([parent]) end
        end
        end; // for
        list
      end// let
    end

    @Operation getParentsPaths(requestID, parents) // for local use
      let list = "" in
        @For parent in parents do
          if not parent = null then list := list + parent.path() + "," end
        end; // for
        list.subString(0, list.size()-1)
      end// let
    end
    
    @Operation getParentsPathsList(requestID, c : FMML::MetaClass) // for local use
      let list = [] in
        @For p in c.parents do
          //if p.isKindOf(FMML::MetaClass) then 
            list := list.append([p.path()]) //end
        end; // for
        list
      end// let
    end

    @Operation isOperationMonitored(o)
      if o.hasProperty("monitor") then FmmlxDiagramClient::getOpProp(o, "monitor") else false end
    end

    ////////////////// Operations for editing associations ///////////////////

  @Operation addAssociation(requestID : Seq(Integer),
      classSourceName : String,
      classTargetName : String,
      accessSourceFromTargetName : String,
      accessTargetFromSourceName : String,
      fwName : String,
      reverseName : String,
      multTargetToSourceS : String,
      multSourceToTargetS : String,
      instLevelSource : Integer,
      instLevelTarget : Integer,
      sourceVisibleFromTarget : Boolean,
      targetVisibleFromSource : Boolean,
	  isSymmetric : Boolean,
	  isTransitive : Boolean):XCore::Element


  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator()
      then
        classSource = m.evalString(classSourceName, self.getPackage(requestID)).at(0);//if package.hasElement(classSourceName) then package.getElement(classSourceName) else null end;
        classTarget = m.evalString(classTargetName, self.getPackage(requestID)).at(0)//if package.hasElement(classTargetName) then package.getElement(classTargetName) else null end
      then
        multTargetToSource = m.valueList2Multiplicity(self.vector2Seq(multTargetToSourceS));
        multSourceToTarget = m.valueList2Multiplicity(self.vector2Seq(multSourceToTargetS))
      then
        problems = [] /*m.checkAddAssociation(self.getPackage(requestID),
  	      classSource, classTarget,
  	      accessSourceFromTargetName, accessTargetFromSourceName,
  	      fwName, reverseName,
  	      multTargetToSource, multSourceToTarget,
  	      instLevelSource, instLevelTarget) */
      in
        if problems.isEmpty() then
  	      problems := m.addAssociation(self.getPackage(requestID),
  	        classSource, classTarget,
  	        accessSourceFromTargetName, accessTargetFromSourceName,
  	        fwName, reverseName,
  	        multTargetToSource, multSourceToTarget,
  	        instLevelSource, instLevelTarget,
  	        sourceVisibleFromTarget, targetVisibleFromSource,
  	        isSymmetric, isTransitive);
          if problems.isEmpty() then self.log := self.log + [["addAssociation", ["package", classSource.owner.path()],
            ["classSource", classSource.path()] ,["classTarget", classTarget.path()] ,
            ["accessSourceFromTargetName", accessSourceFromTargetName] , ["accessTargetFromSourceName", accessTargetFromSourceName] ,
            ["fwName", fwName+""],
            ["reverseName", reverseName+""],
            ["multTargetToSource", FmmlxManipulator::multiplicity2ValueList(multTargetToSource)+""] , ["multSourceToTarget", FmmlxManipulator::multiplicity2ValueList(multSourceToTarget)+""] ,
            ["instLevelSource", instLevelSource+""] , ["instLevelTarget", instLevelTarget+""] ,
            ["sourceVisibleFromTarget", sourceVisibleFromTarget+""] , ["targetVisibleFromSource", targetVisibleFromSource+""] ,
            ["isSymmetric", isSymmetric+""] , ["isTransitive", isTransitive+""]]] end
   	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
  	end

    @Operation removeAssociation(
      requestID  : Seq(Integer),
      assocName    : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.removeAssociation(assoc);
        packagePath = assoc.owner.path();
        assocName =  assoc.name
      in
        if problems.isEmpty() then
          self.log := self.log + [["removeAssociation", ["package", packagePath], ["name", assocName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation setAssociationEndVisibility(
      requestID      : Seq(Integer),
      assocName      : String,
      concernsTarget : Boolean,
      newVisibility  : Boolean)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.setAssociationEndVisibility(assoc, concernsTarget, newVisibility)
      in
        if problems.isEmpty() then
          self.log := self.log + [["setAssociationEndVisibility", ["package", assoc.owner.path()], ["concernsTarget", concernsTarget+""], ["newVisibility", newVisibility+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAssociationForwardName(
      requestID  : Seq(Integer),
      assocName  : String,
      newName    : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        oldName = assoc.name
      then
        problems = m.changeAssociationForwardName(assoc, newName)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeAssociationForwardName", ["package", assoc.owner.path()], ["newFwName", newName], ["oldFwName", oldName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

   @Operation changeAssociationEnd2StartMultiplicity(requestID : Seq(Integer), assocName, multV)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      then
        problems = m.changeAssociationMultiplicity(a, newMult, null)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeAssociationEnd2StartMultiplicity", ["package", a.owner.path()], ["name", a.name], ["multiplicity", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeAssociationStart2EndMultiplicity(requestID : Seq(Integer), assocName, multV)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      then
        problems = m.changeAssociationMultiplicity(a, null, newMult)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeAssociationStart2EndMultiplicity", ["package", a.owner.path()], ["name", a.name], ["multiplicity", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation changeAssociationStart2EndAccessName(requestID : Seq(Integer), assocName, name)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.changeAssociationAccessName(a, null, name)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeAssociationEnd2StartAccessName(requestID : Seq(Integer), assocName, name)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.changeAssociationAccessName(a, name, null)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeAssociationStart2EndLevel(requestID : Seq(Integer), assocName, level)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.changeAssociationLevel(a, null, level)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeAssociationEnd2StartLevel(requestID : Seq(Integer), assocName, level)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.changeAssociationLevel(a, level, null)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    //////////////////////////////////////////////////////////

  	@Operation addAssociationInstance(requestID : Seq(Integer),
      obj1Name  : String,
      obj2Name  : String,
      assocName : String)

  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    obj1 = if self.getPackage(requestID).hasElement(obj1Name) then self.getPackage(requestID).getElement(obj1Name) else null end;
  	    obj2 = if self.getPackage(requestID).hasElement(obj2Name) then self.getPackage(requestID).getElement(obj2Name) else null end;
  	    association = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
  	  then
        problems = m.addAssociationInstance(self.getPackage(requestID), obj1, obj2, association)
  	  in
  	    if problems.isEmpty() then
  	      self.log := self.log + [["addLink", ["package", association.owner.path()], ["name", association.name.toString()], ["classSource", obj1.path()], ["classTarget", obj2.path()]]]
  	    end;
  	    self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
  	  end
    end

    @Operation removeAssociationInstance(
      requestID : Seq(Integer),
      assocName : String,
      obj1Name  : String,
      obj2Name  : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        obj1 = if self.getPackage(requestID).hasElement(obj1Name) then self.getPackage(requestID).getElement(obj1Name) else null end;
        obj2 = if self.getPackage(requestID).hasElement(obj2Name) then self.getPackage(requestID).getElement(obj2Name) else null end;
        association = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.removeAssociationInstance(association,obj1,obj2)
      in
        if problems.isEmpty() then
          self.log := self.log + [["removeLink", ["package", association.owner.path()], ["name", association.name.toString()], ["classSource", obj1.path()], ["classTarget", obj2.path()]]]
  	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    ////////////////// Operations for delegation ///////////////////////////

    @Operation addDelegation(
      requestID   : Seq(Integer),
      delegateFromName  : String,
      delegateToName    : String,
      delegateToLevel   : Integer)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        delegateFrom = if self.getPackage(requestID).hasElement(delegateFromName) then self.getPackage(requestID).getElement(delegateFromName) else null end;
        delegateTo = if self.getPackage(requestID).hasElement(delegateToName) then self.getPackage(requestID).getElement(delegateToName) else null end
      then
        problems = m.setDelegation(delegateFrom, delegateTo, delegateToLevel)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addDelegation", ["package", delegateFrom.owner.path()],
              ["delegateFrom",  delegateFrom.path()],  
              ["delegateTo",  delegateTo.path()],  
              ["delegateToLevel",  delegateToLevel+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation removeDelegation(
      requestID   : Seq(Integer),
      delegateFromName  : String)
    let
        m = FmmlxDiagrams::FmmlxManipulator();
        delegateFrom = if self.getPackage(requestID).hasElement(delegateFromName) then self.getPackage(requestID).getElement(delegateFromName) else null end
      then
        problems = m.removeDelegation(delegateFrom)
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeDelegation", ["package", delegateFrom.owner.path()],
              ["delegateFrom",  delegateFrom.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    

    @Operation setRoleFiller(
      requestID   : Seq(Integer),
      roleName  : String,
      roleFillerName    : String)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        role = if self.getPackage(requestID).hasElement(roleName) then self.getPackage(requestID).getElement(roleName) else null end;
        roleFiller = if self.getPackage(requestID).hasElement(roleFillerName) then self.getPackage(requestID).getElement(roleFillerName) else null end
      then
        problems = m.setRoleFiller(role, roleFiller)
      in
        if problems.isEmpty() then
            self.log := self.log + [["setRoleFiller", ["package", role.owner.path()], ["role", role.path()], ["roleFiller", roleFiller.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation removeRoleFiller(
      requestID   : Seq(Integer),
      roleName    : String)
    let
        m = FmmlxDiagrams::FmmlxManipulator();
        role = if self.getPackage(requestID).hasElement(roleName) then self.getPackage(requestID).getElement(roleName) else null end
      then
        problems = m.removeRoleFiller(role)
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeRoleFiller", ["package", role.owner.path()],
              ["role",  role.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    ////////////////// Operations for editing operations ///////////////////

    @Operation changeOperationName(requestID : Seq(Integer), className, oldName, newName)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeOperationName(class, oldName, newName) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeOperationName(class, oldName, newName);
          self.log := self.log + [["changeOperationName", ["package", class.owner.path()], ["oldName", oldName] , ["newName", newName] , ["class", class.path()]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeOperationLevel(requestID : Seq(Integer), className, name, oldLevel, newLevel)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        o = m.findOperation(class,name)
      then
        problems = if class <> null then m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o)) else ["Class not found"] end
        //problems = m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o))
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeOperationLevel", ["package", class.owner.path()], ["oldLevel", oldLevel+""], ["newLevel", newLevel+""] , ["name", name] , ["class", class.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    /* @Operation addOperation(
      requestID  : Seq(Integer),
      classId    : Integer,
      opName     : String,
      level      : Integer,
      returnType : String,
      body       : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then
        type = m.getTypeForName(returnType, self.getPackage(requestID));
        problems = m.addOperation(class, opName, level, type, body)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addOperation", ["package", class.owner.path()],
                ["class", class.path()],
                ["opName", opName],
                ["level", level+""],
                ["returnType", returnType.path()],
                ["body", body]]]
            end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end */

    @Operation addOperation2(
      requestID  : Seq(Integer),
      className  : String,
      level      : Integer,
      body       : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.addOperation2(class, level, body) else ["Class not found"] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["addOperation2", ["package", class.owner.path()],
            ["class", class.path()],
            ["level", level+""],
            ["body", body]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation removeOperation(
      requestID  : Seq(Integer),
      className    : String,
      opName     : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        //class = self.getMapping(requestID).getMapping(classId).object
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        //problems = m.removeOperation(class, opName)
        problems = if class<>null then m.removeOperation(class, opName) else ["Class not found"] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeOperation", ["package", class.owner.path()], ["class", class.path()], ["name", opName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation getOpProp(operation, name) // for local use
      let
        properties = operation.properties();
        tagFound = null
      in
        @For property in properties do
          if property->head() = name
            then tagFound := property->tail()
          end
        end;
        tagFound
      end
    end

    @Operation changeOperationOwner(requestID : Seq(Integer), className_old, name, className_new)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        oldOwner = if self.getPackage(requestID).hasElement(className_old) then self.getPackage(requestID).getElement(className_old) else null end;
        newOwner = if self.getPackage(requestID).hasElement(className_new) then self.getPackage(requestID).getElement(className_new) else null end
      then
        operation = oldOwner.getOperation(name)
      then
        problems = m.changeOperationOwner(oldOwner, operation, newOwner)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeOperationOwner", ["package", oldOwner.owner.path()], ["class_old", oldOwner.path()], ["class_new",newOwner.path()] , ["name",name]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation checkOperationNameLegal(op, name):Boolean // todo: check for duplicates, consider arity
      let nameSymbol = Symbol(name) in
        if nameSymbol = op.name()
        then
          true
        else
          op.legalNameChangeCheck(nameSymbol,op.name())
        end
      end
    end

    @Operation changeOperationBody(requestID : Seq(Integer), className:String, operationName:String, body:String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
        problems = []
      then
        op = class.getOperation(operationName)
      then
        newName = body.splitBy("()[]",0,0)->head.subst("","@Operation ",false)
      in
//        if operationName.toString() <> newName.toString() then
//          problems := ["name change not allowed here"]
//        else
        if
          op = null then
          problems := ["operation not found"]
        else // let the manipulator try
          problems := m.changeOperationBody(class, op, newName, body)
        end;
        if problems.isEmpty() orelse problems.equals(["Compiled successfully!"]) then
          self.log := self.log + [["changeOperationBody", ["package", class.owner.path()], ["class",className] , ["name",operationName], ["body", body]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    ///////////////////////// Constraints ///////////////////////////
    
    @Operation addConstraint(
      requestID  : Seq(Integer),
      classPath  : String,
      constName  : String,
      instLevel  : Integer,
      body       : String,
      reason     : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0);
        constSymbol = constName.asSymbol()
      then
        problems = if class <> null then m.addConstraint(class, constSymbol, body, reason, instLevel) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["addConstraint", ["package", class.owner.path()],
            ["class", class.path()],
            ["constName", constName],
            ["instLevel", instLevel+""],
            ["body", body],
            ["reason", reason]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeConstraintName(
      requestID  : Seq(Integer),
      classPath  : String,
      oldName    : String,
      newName    : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0);
        newNameSymbol = newName.asSymbol()
      then
        problems = if class <> null then m.changeConstraintName(class, oldName, newNameSymbol) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["changeConstraintName", ["package", class.owner.path()],
            ["class", class.path()],
            ["oldName", oldName],
            ["newName", newName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeConstraintLevel(
      requestID  : Seq(Integer),
      classPath  : String,
      name       : String,
      level      : Integer)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.changeConstraintLevel(class, name, level) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["changeConstraintName", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name],
            ["level", level+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeConstraintBodyAndReason(
      requestID  : Seq(Integer),
      classPath  : String,
      name       : String,
      body       : String,
      reason     : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.changeConstraintBodyAndReason(class, name, body, reason) else ["Class "+classPath+" not found."] end
      in
        /*if problems.isEmpty() then
            self.log := self.log + [["changeConstraintBodyAndReason", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name],
            ["body", body+""],
            ["reason", reason+""]]]
        end;*/
        if problems.isEmpty() then
            self.log := self.log 
            + [["removeConstraint", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name]]] 
            + [["addConstraint", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name],
            ["instLevel", class.getConstraint(name).body.instLevel+""],
            ["body", body],
            ["reason", reason]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeConstraintOwner(
      requestID    : Seq(Integer),
      oldClassPath : String,
      newClassPath : String,
      name         : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        oldClass = m.evalString(oldClassPath, self.getPackage(requestID)).at(0);
        newClass = m.evalString(newClassPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.changeConstraintOwner(oldClass, newClass, name) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["changeConstraintReason", ["package", class.owner.path()],
            ["oldClassPath", oldClass.path()],
            ["newClassPath", newClass.path()],
            ["name", name]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation removeConstraint(
      requestID  : Seq(Integer),
      classPath  : String,
      name       : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.removeConstraint(class, name) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeConstraint", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    // Not yet implemented

    @Operation respondNotYetImplemented(name: String, requestID : Seq(Integer))
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["The feature \"" + name + "\" is temporarily unavailable. Please try again in later version."]])
    end

    @Operation updateAssociationInstance(requestID : Seq(Integer), startObjectPath : String, endObjectPath : String)
      self.respondNotYetImplemented("updateAssociationInstance", self.vector2Seq(requestID))
    end

    @Operation changeAssociationTarget(inA : Seq(Integer), nameT_o, nameT_n)
      self.respondNotYetImplemented("changeAssociationTarget", self.vector2Seq(requestID))
    end

    @Operation changeAssociationSource(inA : Seq(Integer), idS_o, idS_n)
      self.respondNotYetImplemented("changeAssociationSource", self.vector2Seq(requestID))
    end

    @Operation checkOperationBody(requestID : Seq(Integer), operationBodyToBeChecked)
      self.respondNotYetImplemented("checkOperationBody", self.vector2Seq(requestID))
    end

    @Operation changeOperationType(requestID : Seq(Integer), className, opName, newType)
      self.respondNotYetImplemented("changeOperationType", self.vector2Seq(requestID))
    end

    @Operation changeAttributeOwner(requestID : Seq(Integer), path_old, name, path_new)
      self.respondNotYetImplemented("changeAttributeOwner", self.vector2Seq(requestID))
    end

    @Operation changeOf(requestID : Seq(Integer), idO, idC_old, idC_new)
      self.respondNotYetImplemented("changeOf", self.vector2Seq(requestID))
    end

    @Operation changeClassLevel(requestID : Seq(Integer), idO, newLevel)
      self.respondNotYetImplemented("changeClassLevel", self.vector2Seq(requestID))
    end

    @Operation addEnumeration(requestID : Seq(Integer), newEnumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumeration(self.getPackage(requestID), newEnumName)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addEnumeration", ["name",newEnumName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeEnumerationName(requestID : Seq(Integer), oldEnumName:String, newEnumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationName(self.getPackage(requestID), oldEnumName, newEnumName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation removeEnumeration(requestID : Seq(Integer), enumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumeration(self.getPackage(requestID), enumName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation addEnumerationValue(requestID : Seq(Integer), enumName:String, newEnumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumerationValue(self.getPackage(requestID), enumName, newEnumValueName)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addEnumerationValue", ["enum_name",enumName], ["enum_value_name", newEnumValueName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeEnumerationValueName(requestID : Seq(Integer), enumName:String, oldEnumValueName:String, newEnumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationValueName(self.getPackage(requestID), enumName, oldEnumValueName, newEnumValueName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation removeEnumerationValue(requestID : Seq(Integer), enumName:String, enumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumerationValue(self.getPackage(requestID), enumName, enumValueName)
      in
        ("removeEnumerationValue problems: " + problems).println();
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation printProtocol(requestID : Seq(Integer)) // to be removed
      self.log.println()
    end

    @Operation printLog(requestID : Seq(Integer))
      self.log.println()
    end

    @Operation assignToGlobal(requestID : Seq(Integer), objPath:String, varName:String)
      let
        class = FmmlxDiagrams::FmmlxManipulator().evalString(objPath, self.getPackage(requestID)).at(0)
      in
        if
          class <> null
        then
          class.assignToGlobal(varName)
        end;
        []
      end
    end

    @Operation showBody(requestID : Seq(Integer), objPath:String, opName:String, arity:Integer)
      let
        class = FmmlxDiagrams::FmmlxManipulator().evalString(objPath, self.getPackage(requestID)).at(0)
      in
        if
          class <> null andthen class.getOperation(opName) <> null
        then
          class.getOperation(opName).edit()
        end;
        []
      end
    end

    @Operation updateAll(obj:Element)
      let
        clients = Clients::FmmlxDiagrams::FmmlxDiagramClient.allInstances()->select(a | a.package = obj.owner)
      in
        @For client in clients do
          client.communicator.triggerUpdate()
        end
      end
    end

    @Operation evalList(requestID : Seq(Integer), text)
      ("eval List start: " + text).println();
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        result = [];
        error = [];
        parseResult = m.evalString(text, self.getPackage(requestID))
      in
        if
          parseResult.at(1) = null
        then
          parseResult.at(0).println();
          if
            parseResult.at(0).isKindOf(Seq(Element))
          then
            @For element in parseResult.at(0) do
              result := result + [element.toString()]
            end
          else
            result:=["The expression " + text + " does not evaluate to a list."]
          end
        else
          parseResult.at(1).println();
          result:=[parseResult.at(1)]
        end;
        "eval List done".println();
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation addDefaultEnums(p:Package)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        if not p.hasElement("Level") then
          m.addEnumeration(p, "Level");
          m.addEnumerationValue(p, "Level", "High");
          m.addEnumerationValue(p, "Level", "Medium");
          m.addEnumerationValue(p, "Level", "Low") end;
        if not p.hasElement("Gender") then
          m.addEnumeration(p, "Gender");
          m.addEnumerationValue(p, "Gender", "Male");
          m.addEnumerationValue(p, "Gender", "Female");
          m.addEnumerationValue(p, "Gender", "Unspecified") end;
        if not p.hasElement("LegalForm") then
          m.addEnumeration(p, "LegalForm");
          m.addEnumerationValue(p, "LegalForm", "Private_Limited_Partnership");
          m.addEnumerationValue(p, "LegalForm", "Limited_Liability");
          m.addEnumerationValue(p, "LegalForm", "Corporation");
          m.addEnumerationValue(p, "LegalForm", "Non_Profit") end;
        if not p.hasElement("Unit") then
          m.addEnumeration(p, "Unit");
          m.addEnumerationValue(p, "Unit", "piece");
          m.addEnumerationValue(p, "Unit", "kg");
          m.addEnumerationValue(p, "Unit", "litre");
          m.addEnumerationValue(p, "Unit", "gr");
          m.addEnumerationValue(p, "Unit", "meter");
          m.addEnumerationValue(p, "Unit", "km");
          m.addEnumerationValue(p, "Unit", "qm");
          m.addEnumerationValue(p, "Unit", "crate") end
      end
    end

    @Operation getDiagramData(requestID : Seq(Integer))
       //self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), if log.size() = 0 then ["log"] else ["log"] + log end])
       let
         diagramID = self.vector2Seq(requestID).at(0)
       then
         diagram = self.diagrams.get(diagramID)
       then
         package = diagram.package;
         log = ["log"]
       in
         let
           maxLevel = 0;
           classes = package.classes;
           associations = package.associations;
           links = package.fmmlxAssociationInstances
         //then
           //sort classes; //TODO ????? how to sort? if impossible leave it to java (consider parents)
         in
           @For class in classes do
             if class.level>maxLevel then
               maxLevel := class.level
             end
           end;
           @For level in (-maxLevel).to(0) do
             @For class in classes do
               if class.level=(-level) then
                 if class.of()=FMML::MetaClass then
                   log := log + 
                     [["addMetaClass",
                      ["package", class.owner.path()],
                      ["name",class.name.toString()],
                      ["level",class.level+""],
                      ["parents",""],
                      ["abstract",class.isAbstract+""]]]
                 elseif class.isKindOf(Enum) then
                   let
                     enumItems = class.getChildren()
                   in
                     log:= log + [["addEnumeration", ["name",class.name.toString()]]];
                     @For item in enumItems do
                       log:= log + [["addEnumerationValue", ["enum_name",class.name.toString()], ["enum_value_name", item.name.toString()]]]
		             end
                   end
                 else
                   log := log + 
                     [["addInstance", 
                      ["package", class.owner.path()], 
                      ["of", class.of().path()] , 
                      ["name",class.name.toString()] , 
                      ["parents",""], 
                      ["abstract", class.isAbstract+""]]]
                 end
               end
             end
           end;
/*           @For class in classes do
             if class <> null andthen class.isKindOf(Enum) then
               let
                 enumItems = class.getChildren()
               in
                 log:= log + [["addEnumeration", ["name",class.name.toString()]]];
                 @For item in enumItems do
                   log:= log + [["addEnumerationValue", ["enum_name",class.name.toString()], ["enum_value_name", item.name.toString()]]]
		         end
               end
             end
           end;*/
           @For class in classes do
             if self.getParentsPaths(requestID, class.parents->select(c | c.owner = class.owner)) <> "" then
               log:= log + [["changeParent",
                            ["package", class.owner.path()],
                            ["class", class.path()],
                            ["old", ""],
                            ["new", self.getParentsPaths(requestID, class.parents->select(c | c.owner = class.owner))]]]
             end
           end;
           @For class in classes do
             @For att in class.attributes.asSeq() do
               log := log + [["addAttribute", ["package", class.owner.path()],
                                            ["class", class.path()],
                                            ["name", att.name.toString()],
                                            ["level", att.instLevel+""],
                                            ["type", att.type.path()],
                                            ["multiplicity",  FmmlxManipulator::multiplicity2ValueList(att.mult())+""]]]
             end;
             @For op in class.operations.asSeq() do
               if not op.hasProperty("getterKey") and not op.hasProperty("setterKey") then
                 log := log + [["addOperation", ["package", class.owner.path()],
                                                ["class", class.path()],
                                                ["level", op.instLevel+""],
                                                ["body", op.codeBox.source()]]]
               end
             end;
             @For constraint in class.constraints.asSeq() do
               log := log + [["addConstraint", ["package", class.owner.path()],
                                       ["class", class.path()],
                                       ["constName", constraint.name.toString()],
                                       ["instLevel", constraint.body.instLevel+""],
                                       ["body", constraint.body.codeBox.source()],
                                       ["reason", constraint.reason.codeBox.source()]]]
             end
           end;
           @For class in classes  do// new for to make sure att exists
             let
               slots = class.slots()
             then
               slotNames = class.of().allAttributes()->select(a | a.owner.isKindOf(FMML::MetaClass)).name
             in
               @For slot in slots do
                 if slotNames.contains(slot.name) then
                   log := log + [["changeSlotValue", ["package", class.owner.path()],
                                ["class", class.path()],
                                ["slotName", slot.name.toString()],
                                ["valueToBeParsed", self.toParseableString(slot.value, class.owner)]]]
                 end
               end
             end
           end;
           @For assoc in associations.asSeq() do
             log := log + [["addAssociation", ["package", assoc.end1.type.owner.path()],
                                     ["classSource", assoc.end1.type.path()] ,["classTarget", assoc.end2.type.path()] ,
                                     ["accessSourceFromTargetName", assoc.end1.name.toString()] , ["accessTargetFromSourceName", assoc.end2.name.toString()] ,
                                     ["fwName", assoc.name.toString()+""],
                                     ["reverseName", "-1"],
                                     ["multTargetToSource", FmmlxManipulator::multiplicity2ValueList(assoc.end1.mult())+""] , ["multSourceToTarget", FmmlxManipulator::multiplicity2ValueList(assoc.end2.mult())+""] ,
                                     ["instLevelSource", assoc.end1.instLevel+""] , ["instLevelTarget", assoc.end2.instLevel+""] ,
                                     ["sourceVisibleFromTarget", assoc.end2.visible+""] , ["targetVisibleFromSource", assoc.end1.visible+""] ,
                                     ["isSymmetric", assoc.symmetric()+""] , ["isTransitive", assoc.transitive()+""]]]
           end;
           @For link in links.asSeq() do
             log := log + [["addLink", ["package", link.asSeq().at(2).end1.type.owner.path()], ["name", link.asSeq().at(2).name.toString()], ["classSource", link.asSeq().at(0).path()], ["classTarget", link.asSeq().at(1).path()]]]
           end;
           @For class in classes do
             if
               class.delegatesTo <> null
             then
               log := log + [["addDelegation", ["package", class.owner.path()],
                                         ["delegateFrom",  class.path()],
                                         ["delegateTo",  class.delegatesTo.path()],
                                         ["delegateToLevel",  class.delegatesToLevel+""]]]
             end
           end;
           @For class in classes do
             if class.roleFiller <> null
             then
               log := log + [["setRoleFiller", ["package", class.owner.path()], ["role", class.path()], ["roleFiller", class.roleFiller.path()]]]
             end
           end;
           self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), log])
         end //(let);
       end
    end

    @Operation findOperationImplementation(requestID: Seq(Integer), opNames: Seq(String), model:String, arity:String, returnType:String)
      let
        result = [];
        allClasses = Class.allInstances();
        opName = self.vector2Seq(opNames).at(0)
      in
        @For class in allClasses do
          @For op in class.operations do
            if op.name.toString() = opName.toString() then
              let paramTypes = [] in
                @For pt in op.paramTypes() do paramTypes := paramTypes + [pt.path()] end;
                result := result + [[
                  class.path(),
                  class.name.toString(),
                  op.arity,
                  op.paramNames(),
                  paramTypes,
                  op.type.path(),
                  op.codeBox.source()]]
              end
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation findAllOperations(requestID: Seq(Integer))
      let
        result = [];
        allClasses = Class.allInstances()
      in
        @For class in allClasses do
          @For op in class.operations do
              let paramTypes = [] in
                @For pt in op.paramTypes() do paramTypes := paramTypes + [pt.path()] end;
                result := result + [[
                  class.path(),
                  class.name.toString(),
                  op.arity,
                  op.paramNames(),
                  paramTypes,
                  op.type.path(),
                  op.codeBox.source()]]
              end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation findOperationUsage(requestID: Seq(Integer), opName: String, usage:String)

      let
        result = [];
        StringCheck = xmf.javaClass("tool.helper.StringCheck")
      then
        stringCheck = StringCheck()
      in
        @For class in Classifier.allInstances() do
          @For op in class.operations do
            if stringCheck.contains(op.codeBox.source(), opName) then
              result := result + [[
                class.path(),
                class.name.toString(),
                op.name.toString(),
                op.arity,
                op.paramNames(),
                null,
                op.type.path(),
                op.codeBox.source()]]
            end
          end
        end;

        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end // let
    end // @Op

    @Operation hideElements(requestID: Seq(Integer), elementPaths: String, hide:Boolean)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        @For path in elementPaths do
          let
            element = m.evalString(path, self.getPackage(requestID)).at(0)
          in
            if
              element <> null
            then
              let
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(element)
              in
                mappingInfo.hidden := hide
              end // let
            end // if
          end // let
        end // for
      end // let
    end // @Op

    @Operation loadProjectFromXml(requestID : Seq(Integer), packageName : String, diagramNames : Seq(String), file : String)
      let
        package : XCore::Element = XCore::Package(packageName)
      in
        let
          project : XCore::Element = Projects::Project(package,"",null)
        in
          Root.add(package);
          xmf.projectManager("MyProjects").add(project);
          if Root.hasElement("FMML")
          then
            package.addParent(FMML)
            //;
            //@For diagramName in diagramNames do
            //    self.getCommunicator().createDiagram(package.path(), diagramName, file)
            //end;
            //self.getCommunicator().populateDiagram(file, self.vector2Seq(diagramNames).at(0))
          end
        end
      end;
      []
    end

    @Operation saveAsXml(requestID : Seq(Integer), packagePath, resourceName)
        let initName =
            if resourceName = ""
            then self.name + ".xml"
            else resourceName.toString().splitBy("/",0,0)->last
        end then
            file = xmf.saveFile(xmf.projDir(),"*.xml",initName)
        in
            if file <> "" then
            self.saveAsXml(requestID, file,packagePath, true)
        end
      end
    end

    @Operation saveAsXml(requestID : Seq(Integer), file:String, packagePath, confirm:Boolean)
        let write = true
        then
            package = self.getPackage(requestID)
        then
            project : XCore::Element = Projects::Project(package,"",null)
        in
            if not file.isReadOnly()
            then
                if file.fileExists() and self.loaded(package) and confirm
                then write := xmf.confirm(file + " exists. Overwrite?")
                end;
                if write //and self.ensureDir(dir)
                then
                    let dialog = xmf.busy("Saving")
                    in
                        project.savedBy := xmf.user();
                        project.saveDate := xmf.date();
                        self.getCommunicator().saveXmlFile(file, package.toString())
                    end;
                    xmf.message(
                        "Project " + project.name().toString() +
                        " saved (xml format).\nProject saved in file " + file + " on " + project.saveDate + ".\n" +
                        "Project created by " + project.creator + " on " + project.creationDate + ".\n" +
                        "Project saved by " + project.savedBy + ".\n")
                    end
                else
                    xmf.message("File " + file + " exists and is read only.  Cannot save to this file.")
                end
        end
    end

    @Operation loaded(package):Boolean
          package <> null
    end
    
    @Operation toParseableString(o:Element, p: package):String 
      if o = null orelse o.isKindOf(Integer) orelse o.isKindOf(Boolean)
        then o.toString()
      elseif o.isKindOf(Float) 
        then if o = 1/0 then "1/0" elseif o = 0/0 then "0/0" elseif o = -1/0 then "-1/0" else o.toString() end
      elseif o.isKindOf(String)
        then o.asSeq().pprint() + ".asString()"
      elseif o.of().isKindOf(Enum) orelse try o.owner() = p catch(e) false end
        then o.path()
      elseif try o.of().owner() = Auxiliary catch(e) false end // all classes in that package are supposed have that operation
        then o.toParseableString()
      else
        ("The object " + o + " of type " + o.of().path() + " cannot be saved.").println();
        "null"
      end
    end
    
end
