parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramClient extends Client

    @Attribute communicator : Element end
    @Attribute log : Seq(Element) = [] end
    @Attribute errorLog : Seq(Element) = [] end
    @Attribute diagrams : Table = Table(10) end
    @Attribute cachedPaths : Table = null end
    
    @Constructor(name)
      ("invoking FmmlxDiagramClient: " +  name).println();
//      self.setCommandInterpreter(DiagramCommandInterpreter());
//      self.setEventHandler(DiagramEventHandler())
        null
    end
    
    /* This operation returns an instance of 
      the java class "FmmlxDiagramCommunicator",
      For the only instance of FmmlxDiagramClient,
      there is only one instance of the communicator, 
      which is created once, if not yet present.
    */
    @Operation getCommunicator()
      if self.communicator = null then
        "initCommunicator".println();
        let
          FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self)
        in
          self.communicator := FmmlxDiagramCommunicator(handle)
        end
      end;
      self.communicator
    end

    /* this (3) operation(s) is invoked when "show in diagram" 
       in the menu of the package is invoked.
       
       It allows the user to pick an existing one or to create a new one. */
       
    @Operation showDiagram(package,name)
      let 
        key = self.findDiagram(package,name)
      in
        self.showDiagramInView(key)
      end
    end
    
    @Operation showDiagramInView(key)
      if 
        key <> null
      then
        self.getCommunicator().newDiagram( // <-- from the java's point of view a NEW diagram is created
          key, 
          self.diagrams.get(key).diagramName.toString(), 
          self.diagrams.get(key).package.path(),
          self.diagrams.get(key).file.toString(),
          self.diagrams.get(key).views,
          self.diagrams.get(key).options,
          self.diagrams.get(key).umlMode)
      end
    end    
    
    @Operation findDiagram(package,name)   
      let
        selectedName = name;
        keys = self.diagrams.keys();
        key = null;
        keyCount = 0
      in
        @While key = null and keyCount < keys.size() do
        if diagrams.get(keys.at(keyCount)).diagramName.toString() = selectedName.toString() then key := keys.at(keyCount) end;
          keyCount := keyCount + 1
        end;
        key
      end
    end

    @Operation createDiagramFromJava(packagePath, diagramName, file, typeAsString, umlMode)
      let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    type = FmmlxDiagramType.getElement(typeAsString)
      then
        package = m.evalString(packagePath, Root).at(0)
      then
        newID = self.createNewDiagram(package, diagramName, file, type, umlMode)
      in
        self.communicator.notifyDiagramCreated(packagePath, diagramName, newID)
      end      
    end
	
	@Operation createDiagramFromJavaUsingAsynchCall(requestID, packagePath, diagramName, file, typeAsString, umlMode)
      let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    type = FmmlxDiagramType.getElement(typeAsString)
      then
        package = m.evalString(packagePath, Root).at(0)
      then
        newID = self.createNewDiagram(package, diagramName, file, type, umlMode)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), newID])
      end      
    end
	
    /* This Operation creates a new diagram, 
       and returns its key!!! ... */
    @Operation createNewDiagram(package:Package, name:String, file:String, type:FmmlxDiagramType, umlMode:Boolean)
      ///////////FIND ALTERNATIVE TO THIS///////////////////
      if
        package.of() <> FMMLx::FmmlxPackage
      then
        package.setOf(FMMLx::FmmlxPackage);
        Kernel_addAtt(package,"fmmlxAssociationInstances",{})
      end;
      //////////////////////////////////////////////////////
        
      let 
        handle = xmf.getHandle(self);
        diagram = FmmlxDiagram();
        newID = 0
      in
        @While diagrams.hasKey(newID) do newID := newID + 1 end;
        diagram.diagramName := name;//("Diagram " + package.name + " (id " + newID + ")");
        diagram.package := package;
        diagram.file := file;
        diagram.umlMode := umlMode;
        diagram.diagramType := type;
        diagram.views := [["Main View", 1.0, 0.0, 0.0]];
        diagram.options := [];
        self.diagrams.put(newID, diagram);
        
        //diagram
        newID
      end
    end
    
    // This operation is invoked by the java side while the window is closing
    @Operation closeDiagram(requestID, keepDiagram : Boolean) 
      let
        diagramID = self.vector2Seq(requestID).at(0)
      in
        if not keepDiagram then self.diagrams.remove(diagramID) end
      end
    end

    @Operation getMapping(requestID : Seq(Integer))
      self.diagrams.get(self.vector2Seq(requestID).at(0)).mapping
    end
    
    @Operation getPackage(requestID : Seq(Integer))
      self.diagrams.get(self.vector2Seq(requestID).at(0)).package
    end

    //////////////////////// Queries ///////////////////////////////
    
    @Operation getAllObjectPositions(requestID : Seq(Integer), diagramID)
      let 
        result = [];
        diagram = self.diagrams.get(diagramID)
      then
        package = diagram.package;
        mapping = diagram.mapping
      in
        @For c in package.classes->select(x | x.isKindOf(FMMLx::FmmlxObject) orelse x.isKindOf(Class)) do
          let
    	    mappingInfo = mapping.addOrGetObjectMapping(c.path())	        
    	  in
    	    result := result.append([[
			  c.path(), // ownPath
    	      mappingInfo.lastKnownDiagramX,
    	      mappingInfo.lastKnownDiagramY,
			  mappingInfo.hidden,
			  diagram.toString()
			  ]])
	      end
	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllEdgePositions(requestID : Seq(Integer), diagramID)
      let 
        result = [];
        diagram = self.diagrams.get(diagramID)
      then
        package = diagram.package;
        mapping = diagram.mapping
      in
        @For mappingItem in mapping.mapping do
          let
    	    obj = mappingItem.id
    	  then
    	    key = obj//if obj.isKindOf(Associations::Association) then obj.name else obj end
    	  in
    	    if mappingItem.points <> null then // not obj.isKindOf(FMMLx::FmmlxObject) or obj.isKindOf(Class) then 
    	      result := result.append([[
                key.toString(),
                mappingItem.points]])
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllLabelPositions(requestID : Seq(Integer), diagramID)
      self.getCommunicator()
          .sendMessageToJava([self.vector2Seq(requestID), 
               self
                  .diagrams
                  .get(diagramID)
                  .mapping
                  .labelMapping
                  .asSeq()])
    end

    @Operation getAssociationTypes(requestID : Seq(Integer))
      let
        result = [];
        p = self.getPackage(requestID);
        assocTypes = {Associations::DefaultAssociation, Associations::Aggregation, Associations::Composition}
      in
        if p.hasSlot("associationTypes") then
          assocTypes := p.associationTypes + assocTypes
        end;        
        @For aType in assocTypes do
          result := [[
            aType.name.toString(),
            aType.path(),
            aType.color,
            aType.strokeWidth,
            aType.dashArray,
            aType.startDeco,
            aType.endDeco,
            aType.sourceType.path(),
            aType.targetType.path(),
            aType.sourceLevel+"",
            aType.targetLevel+"",
            aType.sourceMult+"",
            aType.targetMult+"",
            aType.colorLink,
            aType.strokeWidthLink,
            aType.dashArrayLink,
            aType.startDecoLink,
            aType.endDecoLink
          ]] + result
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllObjects(requestID : Seq(Integer))
        let
          result = [];
          classes = self.getPackage(requestID).contents()
        in
          self.cachedPaths := Table(classes.size());
    	  @For c in classes do
    	    if c <> null andthen (c.isKindOf(FMMLx::FmmlxObject) or c.isKindOf(Class)) then let 
    	      mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(c.path());
    	      level_ = if c.isKindOf(FMMLx::FmmlxObject) then c.level else -1 end;
    	      isAbstract = if c.isKindOf(Class) then c.isAbstract else false end;
    	      isSingleton = if c.isKindOf(FMMLx::MetaClass) then c.isSingleton else false end;
    	      parents = if c.isKindOf(Class) then self.getParentsPathsList(requestID, c) else [] end;
    	      type = if c.isKindOf(FMMLx::FmmlxObject) then "FMMLX" else if c.isKindOf(Enum) then "ENUM" else if c.isKindOf(Class) then "CLASS" else "UNDEFINED" end end end
    	    then 
    	      level = if level_.isKindOf(Integer) then FMMLx::Level(level_) else level_ end
    	    in
    	      result := result.append([[
    	      	type				         , // 0: UNUSED
                c.name.toString(),             // 1: name
                  //if level = -1 then 2 else level end,  // 2: level
    	      	  //if level = -1 then -1 else level end, // 3: UNUSED
    	      	level.minLevel,                // 2: minLevel
    	      	if level.maxLevel = null 
    	      	  then -1 
    	      	  else level.maxLevel end,     // 3: maxLevel
    	      	isSingleton,                   // 4: UNUSED
                isAbstract,                    // 5
                mappingInfo.lastKnownDiagramX, // 6
                mappingInfo.lastKnownDiagramY, // 7
                mappingInfo.hidden,            // 8: visibility in this diagram
    	      					           -1, // 9: UNUSED
    	        self.getCachedPath(c),         // 10: ownPath
    	        self.getCachedPath(c.of()),    // 11: ofPath
    	        parents                        // 12: parentsPaths
    	      ]])
    	    end end
    	  end;
    	  // clean up mapping ?
    	  if requestID <> -3 then self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result]) end
        end
    end

    @Operation getAllDelegationEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object.isKindOf(Class) andthen object.delegatesTo <> null then
            if object.delegatesTo.isKindOf(FMMLx::MetaClass) then
              let
                delegatesFromPath = object.path();
                delegatesToPath = object.delegatesTo.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createDelegationKey(delegatesFromPath, delegatesToPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            delegatesFromPath, // 1 start Path
  	            delegatesToPath, // 2 end Path
  	            object.delegatesToLevel.minLevel, // 3 level
  	            mappingInfo.points // 4 points
  	          ]])
              end
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllRoleFillerEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object <> null then if object.roleFiller <> null then
            if object.roleFiller.isKindOf(FMMLx::FmmlxObject) then
              let
                //childPath = self.getMapping(requestID).addOrGetObjectMapping(object).object.path();
                //parentPath = self.getMapping(requestID).addOrGetObjectMapping(object.roleFiller).object.path()
                childPath = object.path();
                parentPath = object.roleFiller.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createRoleKey(childPath, parentPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            childPath, // 1 start ID
  	            parentPath, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllInheritanceEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object.isKindOf(Class) then @For parent in object.parents do
            if parent.isKindOf(FMMLx::MetaClass) then
              let
//                childPath = self.getMapping(requestID).addOrGetObjectMapping(object).object.path();
//                parentPath = self.getMapping(requestID).addOrGetObjectMapping(parent).object.path()
                childPath = object.path();
                parentPath = parent.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createInheritanceKey(childPath, parentPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            childPath, // 1 start ID
  	            parentPath, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllAssociations(requestID : Seq(Integer))
        let
          result = [];
          classes = self.getPackage(requestID).classes->select(c | c.isKindOf(FMMLx::MetaClass))
        then
          ends = classes->collect(c | c.attributes)->flatten()->select(a | a.isKindOf(Associations::End))
        then
          associations = ends->collect(e | e.association)
        in
    	  //@For a in self.getPackage(requestID).associations do
    	  @For a in associations do
    	    if a.isKindOf(Associations::AbstractAssociation)
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createAssociationKey(a))
    	      in
    	        //("a is of " + a.of()).println();
    	        result := result.append([[
    	          a.getID(), // 0 ID
    	          a.source.type.path(), // 1 source ID
    	          a.target.type.path(), // 2 target ID
    	          -1, // 3 parent ID
    	          mappingInfo.points, // 4 points
    	          a.name.toString(), // 5 name 1
    	          a.of().path(), // 6 name 2
    	          a.target.name.toString(), // 7 name start->end slot name
    	          a.source.name.toString(), // 8 name end->start slot name
    	          a.target.instLevel.minLevel, // 9 level of source
    	          a.source.instLevel.minLevel, // 10 level of target
    	          FmmlxManipulator::multiplicity2ValueList(a.target.mult()), // 11 mul s->t
    	          FmmlxManipulator::multiplicity2ValueList(a.source.mult()),  // 12 mul t->s
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id), // 13 labels
    	          a.source.visible, // 14 visibility t->s
    	          a.target.visible, // 15 visibility s->t
    	          false,//a.symmetric, // 16
    	          false//a.transitive // 17
    	        ]])
    	      end // let
    	    //else ("a is of " + a.of()).println()
    	    end // if
    	  end;
    	  // clean up mapping ?
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end
    
    @Operation getAllLinks(requestID : Seq(Integer))
      let
        result = [];
        linkList = {}
      in
        @For object in self.getPackage(requestID).classes do
              /* to avoid duplicates, only those slots which are pointing from 
              source to target are considered. That mandates that an association 
              is either bidirectional or the target is the navigable end. 
              An association where the source end is navigable must not be created.
              Otherwise the links will be ignored here. */
          @For link in object.slots()
              ->select(s | s.type.of() = Associations::End)
              ->select(s | s.type.association.target = s.type)              
          do
            linkList := {};
            if 
              link.value = null or link.value = {} 
            then 
              null // do nothing 
            elseif
              link.value.isKindOf(Set(Element))
            then 
              linkList := link.value
            else
              linkList := {link.value}
            end;
            @For item in linkList do
              let
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(
                  FmmlxDiagramMapping::createAssociationLinkKey(
                  object.path(), 
                  item.path(), 
                  link.type.association.getID()
                  ))
              in
                result := result.append([[
    	          mappingInfo.id,                // 0 ID
    	          object.path(),                 // 1 start ID
    	          item.path(),                   // 2 end ID
    	          link.type.association.getID(), // 3 assoc ID
    	          mappingInfo.points,            // 4 points
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id) // 5 labels
    	        ]])
    	      end
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllAttributes(requestID : Seq(Integer))
        let
          result = [];
          classes = self.getPackage(requestID).contents()->select(x | x.isKindOf(Class))
        in
          @For c in classes do
            let
              resultOwn   = [];
              resultOther = []              
            in
              if c <> null // andthen not self.getMapping(requestID).addOrGetObjectMapping(c).hidden
              then
                @For a in c.attributes->select(att | att.of() = Attribute) do
                  resultOwn   :=   resultOwn.append([[
                      a.name.toString(),
                      a.type.name.toString(),
                      //if a.isIntrinsic then a.instLevel else -1 end,
                      if a.isIntrinsic then a.instLevel.minLevel else -1 end,
                      if a.isIntrinsic then if a.instLevel.maxLevel = null then -1 else a.instLevel.maxLevel end else -1 end,
                      FmmlxManipulator::multiplicity2ValueList(a.mult()),
                      a.isIncomplete,
                      a.isOptional,
                      self.getCachedPath(c)
                      ]])
                end; // for own
                @For a in (c.allAttributes() - c.attributes)->select(att | att.of() = Attribute) do
                  if a.isIntrinsic orelse self.attIsInList(a) then
                    resultOther := resultOther.append([[
                      a.name.toString(),
                      a.type.name.toString(),
                      //if a.isIntrinsic then a.instLevel else -1 end,                      
                      if a.isIntrinsic then a.instLevel.minLevel else -1 end,
                      if a.isIntrinsic then if a.instLevel.maxLevel = null then -1 else a.instLevel.maxLevel end else -1 end,
                      FmmlxManipulator::multiplicity2ValueList(a.mult()),
                      a.isIncomplete,
                      a.isOptional,
                      self.getCachedPath(a.owner)
                      ]])
                  end
                end; // for other
                result := result + [[c.path(), resultOwn, resultOther]]
              end // let
            end // if <> null
          end; // for
          //result := [resultOwn, resultOther];
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end // let
    end
    
    @Operation getAllOperations(requestID : Seq(Integer))
      let
        result = null;
        classes = self.getPackage(requestID).contents()->select(x | x.isKindOf(Class)).asSeq()
//        O = 0;
//        S = ""
      in
        // done in allObjects already: self.cachedPaths := Table(classes.size());
      
        result := Vector(classes.size());
        @For classCount in 0.to(classes.size()-1) do
          let 
//           resultLocal = null;
            c = classes.at(classCount)
          in            
            if c <> null 
              // andthen c.isKindOf(FMMLx::MetaClass)
              // andthen not self.getMapping(requestID).addOrGetObjectMapping(c).hidden
            then
              let
                allOps = if c.isKindOf(FMMLx::MetaClass) 
                then c.allOperations2()->select(o | o.owner <> null)->select(o | o.owner.isKindOf(FMMLx::MetaClass))
                else c.allOperations()
                end
              then
                allOpSize = allOps.size()
              then
                resultLocal = Vector(allOpSize);
                minLevel = null; maxLevel = null
              in
                @For oCount in 0.to(allOpSize-1) do if (not allOps.at(oCount).owner = null) then//c.allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMMLx::MetaClass) then
                  let
                    o = allOps.at(oCount)
                  then
                    paramNames = o.paramNames();
                    paramTypesRaw = o.paramTypes()
                  then
                    paramSize = paramTypesRaw.size()
                  then
                    paramTypes = Vector(paramSize);
                    ownerPath = ""
                  in
                    ownerPath := self.getCachedPath(o.owner);                   
                    @For i in 0.to(paramTypesRaw.size()-1) do
                      paramTypes.put(i, self.getPathAsString(paramTypesRaw.at(i)))
                    end;
                    if 
                      o.isIntrinsic 
                    then 
                      if 
                        o.instLevel.isKindOf(FMMLx::Level) 
                      then 
                        if o.instLevel.maxLevel = null 
                        then minLevel := o.instLevel.minLevel; maxLevel := (-1)
                        else minLevel := o.instLevel.minLevel; maxLevel := o.instLevel.maxLevel
                        end
                      else 
                        ("old level still in use: " + o.name.toString()).println();
                        minLevel := o.instLevel; maxLevel := o.instLevel
                      end
                    else
                      minLevel := (-1); maxLevel := (-1)
                    end;
                    resultLocal.put(oCount, [
                      o.name.toString(),
                      paramNames,
                      paramTypes.asSeq(),
                      minLevel,
                      maxLevel,
                      self.getReturnPathAsString(o),
                      o.source(),
                      ownerPath,
                      [0,1,false,true], // to-do: multiplicity
                      self.isOperationMonitored(o),
                      let P = o.properties(); b = false in @For p in P do if p->head() = "delToClassAllowed" then b := p->tail() end end; b end
                    ])
                  end // let
                end end; // for+if
                //null
                result.put(classCount, [c.path(), resultLocal.asSeq()])
              end // let
            end // if 

          end // let
        end; // for
  	    self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result.asSeq()])
      end // let
    end
    
    @Operation getAllConstraints(requestID : Seq(Integer))
      let
        result = []
      in
        @For c in self.getPackage(requestID).classes->select(x |  x.hasSlot("level") andthen x.level.minLevel > 0) do
          let
            localResult = []
          in
            if c <> null 
              andthen c.isKindOf(FMMLx::MetaClass) 
            then
              @For con in c.constraints do if (not con.owner = null) then
                localResult := localResult.append([[
                  con.name.toString(),
                  con.body.instLevel.minLevel,
                  OCL::OCL.grammar.parseString(con.get("body").source(),"Exp1",Seq{XOCL}).performable.pprint(3),
                  con.body.source(),
                  OCL::OCL.grammar.parseString(con.get("reason").source(),"Exp1",Seq{XOCL}).performable.pprint(3),
                  con.reason.source()]])
              end end; // for+if
              result := result + [[c.path(), localResult]]
            end // if <> null
          end // let local
        end; // for
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end  // let
    end // O
    
    
    @Operation attIsInList(a) false end
//      if a.owner = NamedElement andthen a.name.toString() = "name" then true
//      elseif a.owner = Class  andthen a.name.toString() = "level" then true
//      else false end
//    end

    @Operation getAllSlots(requestID : Seq(Integer), objectSlotList)
      let 
        result = []
      in
        @For objectSlotElement in objectSlotList do
          let
            localResult = [];
            objectName = self.vector2Seq(objectSlotElement).at(0);
            slotList = self.vector2Seq(objectSlotElement).at(1)
          in
            @For o in self.getPackage(requestID).contents() do
              if o <> null andthen o.isKindOf(NamedElement) andthen o.name.toString() = objectName
              then
                @For name in slotList do
                  if o.hasSlot(name)
                  then
                    let
                      value = o.get(name)
                    then
                      text = if value.of().isKindOf(Enum) then value.name().toString() else value.toString() end
                    in
                      localResult := localResult.append([[name.toString(), text]])
                    end
                  end
                end
              end
            end;
            result := result.append([[objectName.toString(), localResult]])
          end          
        end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    /*@Operation getSlots(requestID : Seq(Integer), objectName, slotList)
      let
        result = []
      in
        @For o in self.getPackage(requestID).classes do
          if o <> null andthen o.isKindOf(FMMLx::MetaClass) andthen o.name.toString() = objectName
          then
            @For name in slotList do
              if o.hasSlot(name)
              then
                let
                  value = o.get(name)
                then
                  text = if value.of().isKindOf(Enum) then value.name().toString() else value.toString() end
                in
                  result := result.append([[name, text]])
                end
              end
            end
          end
        end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end*/

    @Operation getAllOperationValues(requestID : Seq(Integer), objectOpValList)
      let 
        result = [];
        p = self.getPackage(requestID)   
      in
        @For objectOpValElement in objectOpValList do
          let
            localResult = [];
            objectName = self.vector2Seq(objectOpValElement).at(0);
            opNames = self.vector2Seq(objectOpValElement).at(1)
          in
            @For n in opNames do
              let
                opResult = FmmlxDiagrams::FmmlxManipulator().evalString(objectName + "." + n + "()", p)
              then
                value = opResult.at(0);
                error = opResult.at(1);
                monMin = false;//o.hasProperty("monitorMin");
                monMax = false//o.hasProperty("monitorMax")
              then
                minVal = null;//if monMin then FmmlxDiagramClient::getOpProp(o, "monitorMin") else null end;
                maxVal = null//if monMax then FmmlxDiagramClient::getOpProp(o, "monitorMax") else null end
              then
                hasRange = monMin or monMax or error <> null;
                isInRange = (error = null) andthen
                        if monMin then minVal <= value else true end andthen
                        if monMax then maxVal >= value else true end
              in
                localResult := localResult.append([[
                  n,
                  if error = null then value.toString() else error.toString() end, // error should be of type String
                  hasRange,
                  isInRange]])
              end // let
            end; // for names
            result := result.append([[objectName.toString(), localResult]])
          end          
        end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getOperationValues(requestID : Seq(Integer), objectName, opNames)
      let
        result = [];
        p = self.getPackage(requestID)        
      in
        @For n in opNames do
          let
            opResult = FmmlxDiagrams::FmmlxManipulator().evalString(objectName + "." + n + "()", p)
          then
            value = opResult.at(0);
            error = opResult.at(1);
            monMin = false;//o.hasProperty("monitorMin");
            monMax = false//o.hasProperty("monitorMax")
          then
            minVal = null;//if monMin then FmmlxDiagramClient::getOpProp(o, "monitorMin") else null end;
            maxVal = null//if monMax then FmmlxDiagramClient::getOpProp(o, "monitorMax") else null end
          then
            hasRange = monMin or monMax or error <> null;
            isInRange = (error = null) andthen
                        if monMin then minVal <= value else true end andthen
                        if monMax then maxVal >= value else true end
          in
            result := result.append([[
              n,
              if error = null then value.toString() else error.toString() end, // error should be of type String
              hasRange,
              isInRange]])
          end // let
        end; // for names
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getPathAsString(type:Class)
      try type.path() catch(e) Element.path() end
    end

    @Operation getReturnPathAsString(o) //:Operation
      try o.type().path() catch(e) Element.path() end
    end
    
    @Operation getAllEnums(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For e in self.getPackage(requestID).classes do
    	    if e  <> null andthen e.isKindOf(Enum)
    	    then
    	      let
    	        enumItems = e.getChildren();
    	        itemList = []
    	      in
    	        @For item in enumItems do
    	          itemList := itemList + [item.name.toString()]
    	        end;
    	        result := result.append([[
    	        e.name.toString(),
    	        itemList]])
    	      end
    	    end
    	  end;
    	  // clean up mapping ?
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAuxTypes(requestID : Seq(Integer))
      let
        result = []
      in
        if Root.hasElement("Auxiliary") then
    	  @For ac in Root::Auxiliary.getChildren() do
    	    if
    	      ac.isKindOf(Class)
    	    then
    	      result := result.append([[ac.name.toString()]])
    	    end
    	  end
    	end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllDiagrams(requestID : Seq(Integer), packagePath : String) 
      let 
        result = []      
      in
        @For key in diagrams.keys() do
          if 
            diagrams.get(key).package.path().equals(packagePath)
          andthen
            diagrams.get(key).diagramType = FmmlxDiagramType::ClassDiagram
          then
            result := result + [[key, diagrams.get(key).diagramName]]
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllIssues(requestID : Seq(Integer))
      let
        result = []
      in
        @For obj in self.getPackage(requestID).contents()->select(x | x.isKindOf(FMMLx::FmmlxObject)) do
        //@For obj in self.getPackage(requestID).classes do if obj <> null andthen obj.isKindOf(FMMLx::MetaClass) // andthen not self.getMapping(requestID).addOrGetObjectMapping(obj).hidden 
        //  then
		  /*@For slot in obj.slots() do
		    if self.getPackage(requestID).classes.contains(slot.type.owner) then
		      if slot.type.mult().lowerBound > 0 andthen slot.value = null then
		        result := result + [[
		        "SLOT_NULL",
		        "The slot " + slot.name + " must not be empty.",
		        [obj.path()],
		        ["setSlotValue", obj.path(), slot.name.toString()],
		        FMMLx::Severity::NORMAL.name.toString()]]
		      end // if null and mandatory
		    end // if slot fmmlx
		  end; // for slots */
/*		  if obj.hasSlot("delegatesTo") andthen obj.delegatesTo <> null then @For otherObj in self.getPackage(requestID).classes do // if for (check delegation)
		    if FmmlxManipulator::isInstanceOf(otherObj, obj, obj.delegatesToLevel) andthen 
		     ( otherObj.roleFiller = null orelse not FmmlxManipulator::isInstanceOf(otherObj.roleFiller, obj.delegatesTo, obj.delegatesToLevel))
			then result := result + [[
			    "NO_ROLE_FILLER",
			    "A role filler is required",
			    [self.getMapping(requestID).addOrGetObjectMapping(otherObj).id],
			    ["addRoleFiller",
			     otherObj.path(),
			      obj.delegatesTo.path()],
		          FMMLx::Severity::NORMAL.name.toString()]]
			end
		  end end; // for/if delegation */
//		  if obj.of().isKindOf(FMMLx::MetaClass) andthen obj.of().delegatesTo <> null and obj.roleFiller = null
//		  then result := result + [[
//		    "NO_ROLE_FILLER",
//		    "A role filler is required",
//		    [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
//		    ["addRoleFiller",
//		      self.getMapping(requestID).addOrGetObjectMapping(obj).id,
//		      self.getMapping(requestID).addOrGetObjectMapping(obj.of().delegatesTo).id]]]
//		  end;
		  @For assoc in self.getPackage(requestID).associations do
		    if FmmlxManipulator::isInstanceOf(obj, assoc.end1.type, assoc.end2.instLevel) // if obj fits sourceDef
		    then
		      let
		        count = FmmlxManipulator::countOccurences(obj, self.getPackage(requestID), assoc, true, false) // how many links go out of obj as source
		      in
		        if
		          count < assoc.end2.mult().lowerBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_LOW",
		            "The association " + assoc.name + " requires more links.",
		            [obj.path()],
		            ["addMissingLink", obj.path(), self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createAssociationKey(assoc)).id],
		            FMMLx::Severity::NORMAL.name.toString()]]
		        end;
		        if
		          assoc.end2.mult().hasUpperBound() andthen count > assoc.end2.mult().upperBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_HIGH",
		            "The association " + assoc.name + " requires fewer links.",
		            [obj.path()],
		            ["removeTooManyLinks", obj.path(), self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createAssociationKey(assoc)).id],
		            FMMLx::Severity::NORMAL.name.toString()]]
		        end
		      end // let
		    end; // if instance of
		    if FmmlxManipulator::isInstanceOf(obj, assoc.end2.type, assoc.end1.instLevel) // if obj fits targetDef
		    then
		      let
		        count = FmmlxManipulator::countOccurences(obj, self.getPackage(requestID), assoc, false, true)
		      in
		        if
		          count < assoc.end1.mult().lowerBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_LOW",
		            "The association " + assoc.name + " requires more links.",
		            [obj.path()],
		            ["addMissingLink", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id],
		            FMMLx::Severity::NORMAL.name.toString()]]
		        end;
		        if
		          assoc.end1.mult().hasUpperBound() andthen count > assoc.end1.mult().upperBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_HIGH",
		            "The association " + assoc.name + " requires fewer links.",
		            [obj.path()],
		            ["removeTooManyLinks", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id],
		            FMMLx::Severity::NORMAL.name.toString()]]
		        end
		      end // let
		    end // if instance of
		  end; // for assoc
		  
		  let 
		    constraintReport = obj.checkConstraints()
		  in
		    @For crItem in constraintReport.failures() do //constraintReport.children() do
		      if 
		        crItem.constraint.isKindOf(FMMLx::Issue)
		      then
		        result := [[
		          "CONSTRAINT_FAILURE",
		          crItem.reason,
		          [obj.path()],
		          [crItem.constraint.getSolution(obj)],
		          crItem.constraint.severity.name.toString()]] + result
		      else
    	        result := [[
		          "CONSTRAINT_FAILURE",
		          crItem.reason,
		          [obj.path()],
		          ["no solution available"],
		          FMMLx::Severity::USER_DEFINED.name.toString()]] + result
		      end
		    end
		  end		    
                end; // for obj
		//end end; // for/if obj
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    ///////////////////// Updates to the View ////////////////////

    @Operation sendNewPosition(requestID : Seq(Integer), objectPath, x:Integer, y:Integer, hidden:Boolean)
        self.getMapping(requestID).setNewPosition(objectPath, x, y, hidden);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation sendNewPositions(requestID : Seq(Integer), edgeID, listOfpoints)
        self.getMapping(requestID).setNewPositions(edgeID, listOfpoints);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation storeLabelInfo(requestID : Seq(Integer), edgeID, localID, x, y)
        self.getMapping(requestID).storeLabelInfo(edgeID, localID, x, y);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    ////////////////// Class Manipulations ///////////////////

    @Operation addMetaClass(requestID : Seq(Integer), name, minLevel, maxLevel, parents, abstract, singleton, x, y, hidden)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        parentsList = self.getParentsList(requestID, parents);
        problems = [];
        allParentsLegal = true;
        level = FMMLx::Level(minLevel,maxLevel)
      in
        @For p in parentsList do
          if p.of() <> FMMLx::MetaClass 
            orelse p.level.minLevel <> minLevel 
            orelse p.level.maxLevel <> maxLevel 
          then allParentsLegal := false end
        end;
        problems := problems + if not (level.isValidForObject() and level.minLevel > 0) then ["Level not suitable for a class"] else [] end;
        problems := problems + if not allParentsLegal then ["Not all superclasses are legal."] else [] end;
        problems := problems + if not Symbol(name).isValidName() then ["name " + name + " not legal."] else [] end;
        problems := problems + if self.getPackage(requestID).hasElement(name) then ["name " + name + " already in use."] else [] end;
        if problems.isEmpty() then
          let 
            newClass = m.addMetaClass(self.getPackage(requestID), name, FMMLx::Level(minLevel,maxLevel), parentsList, abstract, singleton)
          then
            mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newClass.path())
          in
            mappingInfo.lastKnownDiagramX := x;
            mappingInfo.lastKnownDiagramY := y;
            mappingInfo.hidden := hidden;
            self.log := self.log + [["addMetaClass", 
              ["package", newClass.owner.path()], 
              ["name",name], 
              ["minLevel",minLevel+""],
              ["maxLevel",maxLevel+""], 
              ["parents",self.getParentsPaths(requestID, parentsList)], 
              ["abstract",abstract+""]]]
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end  
    end

    @Operation mergeMetaClass(requestID : Seq(Integer), name, level, parents, abstract, x, y, hidden)
          let
            m = FmmlxDiagrams::FmmlxManipulator();
            parentsList = self.getParentsList(requestID, parents);
            problems = []
          in
            problems := problems + if not Symbol(name).isValidName() then ["name " + name + " not legal."] else [] end;
            problems := problems + if self.getPackage(requestID).hasElement(name) then ["name " + name + " already in use."] else [] end;
            if problems.isEmpty() then
              let
                newClass = m.addMetaClass(self.getPackage(requestID), name, level, parentsList, abstract)
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newClass.path())
              in
                mappingInfo.lastKnownDiagramX := x;
                mappingInfo.lastKnownDiagramY := y;
                mappingInfo.hidden := hidden;
                self.log := self.log + [["addMetaClass",
                  ["package", newClass.owner.path()],
                  ["name",name],
                  ["level",level+""],
                  ["parents",self.getParentsPaths(requestID, parentsList)],
                  ["abstract",abstract+""]]]
              end
            end
          end
    end

    @Operation addInstance(
            requestID : Seq(Integer),
            ofName,
            name,
            minLevel,
            maxLevel,
            parents,
            abstract,
            singleton,
            x, y,
            hidden,
            slotValueList: Seq(Seq(String)))
        try
          let
            m = FmmlxDiagrams::FmmlxManipulator();
            ofClass = if self.getPackage(requestID).hasElement(ofName) 
                      then self.getPackage(requestID).getElement(ofName) 
                      else null 
                      end
          then
            level = if minLevel = -2 and maxLevel = -2 // legacy, old savefile, auto-level
                    then FMMLx::Level(ofClass.level.minLevel-1, ofClass.level.maxLevel-1)
                    else FMMLx::Level(minLevel, maxLevel)
                    end
          then
            parentsList = self.getParentsList(requestID, parents);
            allParentsLegal = true
          in
            @For p in parentsList do
              if p.of() <> ofClass then allParentsLegal := false end
            end;
            if 
              ofClass.isAbstract
            then 
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["Abstract class " + ofClass.name.toString() + " cannot be instantiated."]])
            elseif 
              not Symbol(name).isValidName() 
            then 
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["name " + name + " not legal."]])
            elseif 
              self.getPackage(requestID).hasElement(name)
            then 
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["name " + name + " already in use."]])
            elseif 
              not allParentsLegal
            then 
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["Not all superclasses are legal."]])
            elseif 
              not ofClass.level.canBeInstantiatatedTo(level) and level.isValidForObject()
            then 
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["Level " + ofClass.level.toString() + " cannot be instantiated to level " + level.toString() + "."]])
            else
              let
                newInstance = m.addInstance(self.getPackage(requestID), ofClass, name, level, parentsList, abstract, singleton, slotValueList)
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newInstance.path())
              in
                mappingInfo.lastKnownDiagramX := x;
                mappingInfo.lastKnownDiagramY := y;
                mappingInfo.hidden := hidden;
                self.log := self.log + [["addInstance", ["package", newInstance.owner.path()], ["of", ofClass.path()] , ["name",name] , ["parents",self.getParentsPaths(requestID, parentsList)] , ["abstract",abstract+""]]];
                self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
              end
            end
          end          
        catch (exception)
          self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), [exception.message]])
        end
    end

	@Operation addGeneratedInstance(
                requestID      : Seq(Integer),
                ofName         : String,
                level          : Integer,
                prefix         : String,
                slotValueList  : Seq(Seq(String)),
                constraintList : Seq(String))
      let 
        m = FmmlxDiagrams::FmmlxManipulator();
        package = self.getPackage(requestID);
        instanceSuffixCount = 0
      then
        ofClass = if self.getPackage(requestID).hasElement(ofName) then self.getPackage(requestID).getElement(ofName) else null end
      in
        @While package.hasElement(prefix+instanceSuffixCount) do
          instanceSuffixCount := instanceSuffixCount + 1
        end;
        let 
          newInstance = try m.addInstance(self.getPackage(requestID), ofClass, prefix+instanceSuffixCount, FMMLx::Level(level), [], false, false, slotValueList) catch (exception) null end
        in
          if
            newInstance <> null 
          then
            let
              failures = newInstance.checkConstraints().failures();
              ok = true
            in
              @For failure in failures do
                @For constraint in constraintList do
                  ok := ok andthen not constraint.equals(failure.constraint.name.toString())
                end
              end;
              if 
                not ok
              then
                m.removeClass(newInstance, null)
              end;
              self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID),ok, newInstance.name.toString()])
            end
          else
            self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), false])
          end
        
          
        end
      end
      // generateInstance 
      //"addGeneratedInstance".println();
      //("prefix:" + prefix).println();
      //("slotValueList:" + slotValueList).println();
      //("constraintList:" + constraintList).println();
      // ....
      // and then if successful:
      
    end                
	

    @Operation mergeInstance(
                requestID : Seq(Integer),
                ofName,
                name,
                parents,
                abstract,
                x, y,
                hidden,
                slotValueList: Seq(Seq(String)) )
	    try
	      let
	        m = FmmlxDiagrams::FmmlxManipulator()
	      then
	        ofClass = if self.getPackage(requestID).hasElement(ofName) then self.getPackage(requestID).getElement(ofName) else null end;
	        parentsList = self.getParentsList(requestID, parents)
	      in
	        if
	          not self.getPackage(requestID).hasElement(name)
	        then
	          let
	            newInstance = m.addInstance(self.getPackage(requestID), ofClass, name, parentsList, abstract, slotValueList)
	          then
	            mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newInstance)
	          in
	            mappingInfo.lastKnownDiagramX := x;
	            mappingInfo.lastKnownDiagramY := y;
	            mappingInfo.hidden := hidden
	          end
	        end
	      end
	    catch (exception)
	      exception.message.println()
	    end
    end
    
    @Operation classify(requestID : Seq(Integer), objectNames, newClassName)
      ////// TEST
      "classify".println();
      objectNames := self.vector2Seq(objectNames);
      objectNames.println();
      objectNames.of().println();
      //////
      let
        instances = [];
        m = FmmlxDiagrams::FmmlxManipulator();
        problems = [];
        level = null
      in
        @For oName in objectNames do
          let 
            instance = if self.getPackage(requestID).hasElement(oName) then self.getPackage(requestID).getElement(oName) else null end
          in
            problems := problems + if instance = null then ["element " + oName + " does not exist."] else [] end;
            instances := instances + [instance];
            if level = null then level:=instance.level end;
	        problems := problems + if instance.level <> level then ["element " + oName + " is on wrong level."] else [] end
          end
        end;
        ("level: " + level).println();
        ("problems: " + problems).println();
        problems := problems + if not Symbol(newClassName).isValidName() then ["name " + newClassName + " not legal."] else [] end;
        problems := problems + if self.getPackage(requestID).hasElement(newClassName) then ["name " + newClassName + " already in use."] else [] end;
        if problems.isEmpty() then
          let
            newClass = m.addMetaClass(self.getPackage(requestID), newClassName, level+1, [], false)
          then
            mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newClass)
          in
            ("newClass: " + newClass).println();
            @For instance in instances do
               problems := problems + ["element " + instance.name + " cannot be migrated yet. Please try again in a later version."]
            end
            ;("problems: " + problems).println()
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), if problems.isEmpty() then [] else [problems.at(0)] end])
      end
    end
    

    @Operation removeClass(requestID : Seq(Integer), className, strategy)
      let
        problems = ["no problems yet"];
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        classPath4Log = class.path()
      in
        xmf.startUndoable();
        problems := try        
          m.removeClass(class, strategy);
          self.log := self.log + 	[["removeClass", ["package", self.getPackage(requestID).path()], ["class", classPath4Log]]];
          []
        catch(e)
          [e.message]
        end;
        xmf.endUndoable();
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // temporary empty result 
      end
    end

    @Operation changeClassName(requestID : Seq(Integer), className, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        oldPath = class.path()
      in
        m.changeClassName(class, newName);
        self.getMapping(requestID).updateKey(oldPath, class.path());
        self.log := self.log + [["changeClassName", ["package", class.owner.path()], ["class", className] , ["newName",newName]]]
      end;
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end
    
    @Operation changeClassLevel(requestID : Seq(Integer), 
            classPath, 
            minLevel,
            maxLevel)
      let 
        m = FmmlxDiagrams::FmmlxManipulator();
        newLevel = FMMLx::Level(minLevel,maxLevel)
      then
        obj = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        problems = try 
          m.changeClassLevel(obj, newLevel);[]
        catch (e)
          [e.toString()]
        end
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation setClassAbstract(requestID : Seq(Integer), className, isAbstract)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.changeClassAbstract(class, isAbstract) else ["Class not found"] end
      in
        if problems.isEmpty() then
          self.log := self.log + [["setClassAbstract", ["package", class.owner.path()], ["class", class.path()] , ["abstract",isAbstract+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation setClassSingleton(requestID : Seq(Integer), className, isSingleton)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.changeClassSingleton(class, isSingleton) else ["Class not found"] end
      in
        if problems.isEmpty() then
          self.log := self.log + [["setClassSingleton", ["package", class.owner.path()], ["class", class.path()] , ["singleton",isSingleton+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation levelRaiseAll(requestID : Seq(Integer), amount)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.levelRaiseAll(self.getPackage(requestID), amount)
      in
        if problems.isEmpty() then
           self.log := self.log + [["levelRaiseAll", ["package", self.getPackage(requestID).path()], ["amount", amount+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeParent(requestID : Seq(Integer), className, oldList, newList)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        oldSet = self.vector2Seq(oldList).asSet();
        newSet = self.vector2Seq(newList).asSet();
        problems = [];
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
        allParentsLegal = true
      then
        oldParentList = class.parents->select(c | c.owner = class.owner); // for Log
        addSet = newSet - oldSet;
        removeSet = oldSet - newSet
      in
        @For pName in newSet do
          let
            pParse = m.evalString(pName, self.getPackage(requestID))
          then
            p = if pParse.at(1) = null then pParse.at(0) else null end
          in
            if p = null 
              orelse p.of() <> class.of() 
              orelse p.level.minLevel <> class.level.minLevel 
              orelse p.level.maxLevel <> class.level.maxLevel 
            then allParentsLegal := false end
          end
        end;
        problems := problems + if not allParentsLegal then ["Not all superclasses are legal."] else [] end;      
      
//        if
//          removeSet = {}
//        then
          @For parentName in addSet do
            let
              pr = m.evalString(parentName, self.getPackage(requestID))
            then
              parentToBeAdded = if pr.at(1) = null then pr.at(0) else null end
            in
              problems := problems + if parentToBeAdded = null or (not allParentsLegal) then ["Cannot find new parent " + parentName] else m.addParent(class, parentToBeAdded) end
            end
          end
;//        elseif
//          addSet = {}
//        then
          @For parentName in removeSet do
            let
              pr = m.evalString(parentName, self.getPackage(requestID))
            then
              parentToBeRemoved = if pr.at(1) = null then pr.at(0) else null end
            in
              problems := problems + if parentToBeRemoved = null then ["Cannot find old parent " + parentName] else m.removeParent(class, parentToBeRemoved) end
            end
          end
;//        elseif
//          removeSet.size() = 1 and addSet.size() = 1 // move exactly one parent
//        then
//          let
//            parentToBeAdded = self.getMapping(requestID).getMapping(addSet.asSeq().at(0)).object;
//            parentToBeRemoved = self.getMapping(requestID).getMapping(removeSet.asSeq().at(0)).object
//          in
//            problems := problems + m.moveParent(class, parentToBeRemoved, parentToBeAdded)
//          end
//        else
//          problems := problems + ["Only one parent may be moved at a time."]
//        end;
        if problems.isEmpty() then
          self.log := self.log + [[
          "changeParent", 
          ["package", class.owner.path()], 
          ["class", class.path()], 
          ["old", self.getParentsPaths(requestID, oldParentList)], 
          ["new", self.getParentsPaths(requestID, class.parents->select(c | c.owner = class.owner))]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation mergeParent(requestID : Seq(Integer), className, oldList, newList)
          let
            m = FmmlxDiagrams::FmmlxManipulator();
            oldSet = self.vector2Seq(oldList).asSet();
            newSet = self.vector2Seq(newList).asSet();
            problems = [];
            class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
          then
            oldParentList = class.parents->select(c | c.owner = class.owner); // for Log
            addSet = newSet - oldSet;
            removeSet = oldSet - newSet
          in
              @For parentName in addSet do
                let
                  pr = m.evalString(parentName, self.getPackage(requestID))
                then
                  parentToBeAdded = if pr.at(1) = null then pr.at(0) else null end
                in
                  problems := problems + if parentToBeAdded = null then ["Cannot find new parent " + parentName] else m.addParent(class, parentToBeAdded) end
                end
              end;
              @For parentName in removeSet do
                let
                  pr = m.evalString(parentName, self.getPackage(requestID))
                then
                  parentToBeRemoved = if pr.at(1) = null then pr.at(0) else null end
                in
                  problems := problems + if parentToBeRemoved = null then ["Cannot find old parent " + parentName] else m.removeParent(class, parentToBeRemoved) end
                end
              end
          end
    end

    //////////////////////// Attribute Manipulations /////////////////////

    @Operation addAttribute(requestID : Seq(Integer), className, name, minLevel, maxLevel, typeName, multiplicityV, isIntrinsic, isIncomplete, isOptional)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
//        class = self.getMapping(requestID).getMapping(classId).object;
        type = m.getTypeForName(typeName, self.getPackage(requestID));
        multiplicity = m.valueList2Multiplicity(self.vector2Seq(multiplicityV))
      then
        problems = if class <> null then [] else ["Class not found"] end
//        problems = if class <> null then m.checkAddAttribute(class, name, if not isIntrinsic then null else FMMLx::Level(minLevel, maxLevel) end, typeName, multiplicity, isIncomplete, isOptional) else ["Class not found"] end
      in
        if
          problems.isEmpty()
        then
          problems := try
            m.addAttribute(class, name, if not isIntrinsic then null else FMMLx::Level(minLevel, maxLevel) end, type, multiplicity, isIncomplete, isOptional); []
          catch(e)
            [("addAttribute failed during transaction: " + e.message)]
          end // try
        end; // if
        if problems.isEmpty() then
            self.log := self.log + [["addAttribute", 
                                            ["package", class.owner.path()],
                                            ["class", class.path()],
                                            ["name", name.toString()],
                                            ["level", minLevel+""],
                                            ["type", type.path()],
                                            ["multiplicity",  FmmlxManipulator::multiplicity2ValueList(multiplicity)+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end // in
    end

    // used for merging two projects into one
    @Operation mergeAttribute(requestID : Seq(Integer), className, name, level, typeName, multiplicityV)
          let
            m = FmmlxDiagrams::FmmlxManipulator()
          then
            class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
    //        class = self.getMapping(requestID).getMapping(classId).object;
            type = m.getTypeForName(typeName, self.getPackage(requestID));
            multiplicity = m.valueList2Multiplicity(self.vector2Seq(multiplicityV))
          then
            problems = if class <> null then m.checkAddAttribute(class, name, level, typeName, null) else ["Class not found"] end
          in
            if
              problems.isEmpty()
            then
              problems := try
                m.addAttribute(class, name, level, type, multiplicity); []
              catch(e)
                [("addAttribute failed during transaction: " + e.message)]
              end // try
            end
          end // in
    end

    @Operation changeAttributeName(requestID : Seq(Integer), className, oldName, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
          then
		class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeAttributeName(class, oldName, newName) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeAttributeName(class, oldName, newName);
          self.log := self.log + [["changeAttributeName", ["package", class.owner.path()], ["class", class.path()] , ["oldName", oldName] , ["newName", newName]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeLevel(requestID : Seq(Integer), classPath, attName, oldLevel, newLevel)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel) else ["Class not found"] end
        //problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
      in
        if problems.isEmpty() then
          m.changeAttributeLevel(class, attName, oldLevel, newLevel);
          self.log := self.log + [["changeAttributeLevel", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldLevel", oldLevel+""] , ["newLevel", newLevel+""]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeType(requestID : Seq(Integer), className, attName, oldTypeName, newTypeName)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
          class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        problems = if class <> null then m.checkChangeAttributeType(class, attName, oldTypeName, newTypeName, self.getPackage(requestID)) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeAttributeType(class, attName, oldTypeName, newTypeName, self.getPackage(requestID));
          self.log := self.log + [["changeAttributeType", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldType", oldTypeName] , ["newType", newTypeName]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeMultiplicity(requestID : Seq(Integer), className, attName, oldMul, newMul)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        oldMult = m.valueList2Multiplicity(self.vector2Seq(oldMul));
        newMult = m.valueList2Multiplicity(self.vector2Seq(newMul))
      then    // TODO !!!
//          problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
         problems = []
         
      in
        if problems.isEmpty() then
          m.changeAttributeMultiplicity(class, attName, null, newMult);
          self.log := self.log + [["changeAttributeMultiplicity", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldMul", FmmlxManipulator::multiplicity2ValueList(oldMult)+""] , ["newMul", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end    

    @Operation changeAttributeOwner(requestID : Seq(Integer), oldName, name, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
        ;problems = null
      then
        oldClass = if self.getPackage(requestID).hasElement(oldName) then self.getPackage(requestID).getElement(oldName) else null end;
        newClass = if self.getPackage(requestID).hasElement(newName) then self.getPackage(requestID).getElement(newName) else null end
      in
        problems := try
          m.changeAttributeOwner(oldClass, name, newClass); []
        catch(e)
          [("changeAttributeOwner failed during transaction: " + e.message)]
        end; // try
        if problems.isEmpty() then
          self.log := self.log + [["changeAttributeOwner", 
                                  ["package", class.owner.path()],
                                  ["oldName", oldName],
                                  ["name", name],
                                  ["newName", newName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end // in
    end


    @Operation removeAttribute(requestID : Seq(Integer), className, attName, strategy)
     // for now: ignore strategy and simply delete
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      in
        m.removeAttribute(class, attName, strategy);
        self.log := self.log + [["removeAttribute", ["package", class.owner.path()], ["class", class.path()], ["name", attName]]]
      end;
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result
    end

    //////////////////////// Slot Manipulations /////////////////////

    @Operation changeSlotValue(requestID : Seq(Integer), className, slotName, valueToBeParsed)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        obj = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
        error = null
      then
        class = obj.of();
        foundAtt = m.findAttributeForSlot(obj, slotName)
      in
        if
          foundAtt <> null
        then
          let
            parseResult = m.evalString(valueToBeParsed, self.getPackage(requestID))
          in
            if parseResult.at(1) = null then
              error := m.changeSlotValue(obj, slotName, parseResult.at(0), foundAtt.type, self.getPackage(requestID))
            else
              error := parseResult.at(1) // error as message or as return value? maybe try exceptions...
            end
          end
		elseif slotName = "lastUpdated" then null
        else
          error := "slot " + slotName + " not found in " + className
        end;
	  self.log := self.log + [["changeSlotValue", 
                                  ["package", class.owner.path()],
                                  ["class", obj.path()],
                                  ["slotName", slotName],
                                  ["valueToBeParsed", valueToBeParsed]]];
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), if error = null then null else [error] end]) // temporary empty result
      end
    end

    @Operation mergeSlotValue(requestID : Seq(Integer), className, slotName, valueToBeParsed)
          let
            m = FmmlxDiagrams::FmmlxManipulator();
            obj = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
            error = null
          then
            class = obj.of();
            foundAtt = m.findAttributeForSlot(obj, slotName)
          in
            if
              foundAtt <> null
            then
              let
                parseResult = m.evalString(valueToBeParsed, self.getPackage(requestID))
              in
                if parseResult.at(1) = null then
                  error := m.changeSlotValue(obj, slotName, parseResult.at(0), foundAtt.type, self.getPackage(requestID))
                else
                  error := parseResult.at(1) // error as message or as return value? maybe try exceptions...
                end
              end

            else
              error := "slot " + slotName + " not found in " + className
            end;
    	  self.log := self.log + [["changeSlotValue",
                                      ["package", class.owner.path()],
                                      ["class", obj.path()],
                                      ["slotName", slotName],
                                      ["valueToBeParsed", valueToBeParsed]]]
          end
    end

    //////////////// Local Operations ///////////////////

    @Operation vector2Seq(vec) // for local use
      let list = [] in
        @For id in vec do
          list := list.append([id])
        end; // for
        list
      end// let
    end

    @Operation getParentsList(requestID, parentNames) // for local use
      let
        list = [];
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        @For name in parentNames do
        let
            parent = try m.getTypeForName(name, self.getPackage(requestID)) catch(e) null end
        in
            if not parent = null then list := list.append([parent]) end
        end
        end; // for
        list
      end// let
    end

    @Operation getParentsPaths(requestID, parents) // for local use
      let list = "" in
        @For parent in parents do
          if not parent = null then list := list + parent.path() + "," end
        end; // for
        list.subString(0, list.size()-1)
      end// let
    end
    
    @Operation getParentsPathsList(requestID, c : FMMLx::MetaClass) // for local use
      let list = [] in
        @For parent in c.parents do 
            list := list.append([self.getCachedPath(parent)]) //end
        end; // for
        list
      end// let
    end

    @Operation isOperationMonitored(o)
      if o.hasProperty("monitor") then FmmlxDiagramClient::getOpProp(o, "monitor") else false end
    end

    ////////////////// Operations for editing associations ///////////////////
    
  @Operation addAssociationType(requestID : Seq(Integer),
      typeName        : String,
      color           : String,
      strokeWidth     : Integer,
      dashArray       : String,
      startDeco       : String,
      endDeco         : String,
      colorLink       : String,
      strokeWidthLink : Integer,
      dashArrayLink   : String,
      startDecoLink   : String,
      endDecoLink     : String,
      sourcePath      : String,
      targetPath      : String)
    let 
      m = FmmlxDiagrams::FmmlxManipulator();
      p = self.getPackage(requestID)
    then
      sourceEval = m.evalString(sourcePath, self.getPackage(requestID));
      targetEval = m.evalString(targetPath, self.getPackage(requestID));
      problems = []
    in
      problems := if 
        not typeName.isValidName() then [typeName + " is not a valid name"] elseif
        not p.hasSlot("associationTypes") then ["Package " + p.name + "is not suitable for association types"] elseif
        0 <> p.associationTypes->select(a | a.name.toString() = typeName).size() then [typeName + " is already in use"] elseif
        sourceEval.at(1) <> null then [sourceEval.at(1)] elseif
        targetEval.at(1) <> null then [targetEval.at(1)] else
          let 
            a = Associations::AssociationType(typeName, sourceEval.at(0), targetEval.at(0))
          in           
            a.color       := color;           
            a.strokeWidth := strokeWidth;           
            a.dashArray   := dashArray;           
            a.startDeco   := startDeco;           
            a.endDeco     := endDeco;
            a.colorLink       := colorLink;           
            a.strokeWidthLink := strokeWidthLink;           
            a.dashArrayLink   := dashArrayLink;           
            a.startDecoLink   := startDecoLink;           
            a.endDecoLink     := endDecoLink;
            p.associationTypes := {a} + p.associationTypes;
            p.add(a);
            []
          end       
        end;
      
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) 
    end
  end

  @Operation addAssociation(requestID : Seq(Integer),
      classSourceName : String,
      classTargetName : String,
      accessSourceFromTargetName : String,
      accessTargetFromSourceName : String,
      fwName : String,
      associationType : String,
      multTargetToSourceS : String,
      multSourceToTargetS : String,
      instLevelSourceMin : Integer,
      instLevelSourceMax : Integer,
      instLevelTargetMin : Integer,
      instLevelTargetMax : Integer,
      sourceVisibleFromTarget : Boolean,
      targetVisibleFromSource : Boolean,
	  isSymmetric : Boolean,
	  isTransitive : Boolean,	  
      sourceGetterName : String,
      sourceSetterName : String,
      targetGetterName : String,
      targetSetterName : String):XCore::Element

  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    instLevelSource = FMMLx::Level(instLevelSourceMin, if instLevelSourceMax = -1 then null else instLevelSourceMax end);
  	    instLevelTarget = FMMLx::Level(instLevelTargetMin, if instLevelTargetMax = -1 then null else instLevelTargetMax end)
      then
        classSource = m.evalString(classSourceName, self.getPackage(requestID)).at(0);//if package.hasElement(classSourceName) then package.getElement(classSourceName) else null end;
        classTarget = m.evalString(classTargetName, self.getPackage(requestID)).at(0);//if package.hasElement(classTargetName) then package.getElement(classTargetName) else null end
        assocType = m.evalString(associationType, Root).at(0)
      then
        multTargetToSource = m.valueList2Multiplicity(self.vector2Seq(multTargetToSourceS));
        multSourceToTarget = m.valueList2Multiplicity(self.vector2Seq(multSourceToTargetS))
      then
        problems = [] /*m.checkAddAssociation(self.getPackage(requestID),
  	      classSource, classTarget,
  	      accessSourceFromTargetName, accessTargetFromSourceName,
  	      fwName, reverseName,
  	      multTargetToSource, multSourceToTarget,
  	      instLevelSource, instLevelTarget) */
      in
        if problems.isEmpty() then
  	      problems := m.addAssociation(self.getPackage(requestID),
  	        classSource, classTarget,
  	        accessSourceFromTargetName, accessTargetFromSourceName,
  	        fwName, assocType,
  	        multTargetToSource, multSourceToTarget,
  	        instLevelSource, instLevelTarget,
  	        sourceVisibleFromTarget, targetVisibleFromSource,
  	        isSymmetric, isTransitive);
  	      /*if problems.isEmpty() then
  	        "TODO: add getters and setters:".println();
  	        if sourceGetterName <> -1 then ("Create Getter for Source: " + sourceGetterName + "()").println() end;
  	        if sourceSetterName <> -1 then ("Create Setter for Source: " + sourceSetterName + "(val)").println() end;
  	        if targetGetterName <> -1 then ("Create Getter for Target: " + targetGetterName + "()").println() end;
  	        if targetSetterName <> -1 then ("Create Setter for Target: " + targetSetterName + "(val)").println() end;
  	        if sourceGetterName <> -1 then m.generateAssociationGetter(classTarget, classSource, instLevelSource, accessSourceFromTargetName, sourceGetterName) end;
  	        if sourceSetterName <> -1 then m.generateAssociationSetter(classTarget, classSource, instLevelSource, accessSourceFromTargetName, sourceSetterName) end;
  	        if targetGetterName <> -1 then m.generateAssociationGetter(classSource, classTarget, instLevelTarget, accessTargetFromSourceName, targetGetterName) end;
  	        if targetSetterName <> -1 then m.generateAssociationSetter(classSource, classTarget, instLevelTarget, accessTargetFromSourceName, targetSetterName) end
  	      end;*/
          if problems.isEmpty() then self.log := self.log + [["addAssociation", ["package", classSource.owner.path()],
            ["classSource", classSource.path()] ,["classTarget", classTarget.path()] ,
            ["accessSourceFromTargetName", accessSourceFromTargetName] , ["accessTargetFromSourceName", accessTargetFromSourceName] ,
            ["fwName", fwName+""],
            ["assocType", assocType+""],
            ["multTargetToSource", FmmlxManipulator::multiplicity2ValueList(multTargetToSource)+""] , ["multSourceToTarget", FmmlxManipulator::multiplicity2ValueList(multSourceToTarget)+""] ,
            ["instLevelSource", instLevelSource+""] , ["instLevelTarget", instLevelTarget+""] ,
            ["sourceVisibleFromTarget", sourceVisibleFromTarget+""] , ["targetVisibleFromSource", targetVisibleFromSource+""] ,
            ["isSymmetric", isSymmetric+""] , ["isTransitive", isTransitive+""]]] end
   	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
  	end

  	@Operation mergeAssociation(requestID : Seq(Integer),
          classSourceName : String,
          classTargetName : String,
          accessSourceFromTargetName : String,
          accessTargetFromSourceName : String,
          fwName : String,
          reverseName : String,
          multTargetToSourceS : String,
          multSourceToTargetS : String,
          instLevelSource : Integer,
          instLevelTarget : Integer,
          sourceVisibleFromTarget : Boolean,
          targetVisibleFromSource : Boolean,
    	  isSymmetric : Boolean,
    	  isTransitive : Boolean):XCore::Element
      	  let
      	    m = FmmlxDiagrams::FmmlxManipulator()
          then
            classSource = m.evalString(classSourceName, self.getPackage(requestID)).at(0);//if package.hasElement(classSourceName) then package.getElement(classSourceName) else null end;
            classTarget = m.evalString(classTargetName, self.getPackage(requestID)).at(0)//if package.hasElement(classTargetName) then package.getElement(classTargetName) else null end
          then
            multTargetToSource = m.valueList2Multiplicity(self.vector2Seq(multTargetToSourceS));
            multSourceToTarget = m.valueList2Multiplicity(self.vector2Seq(multSourceToTargetS))
          then
            problems = [] /*m.checkAddAssociation(self.getPackage(requestID),
      	      classSource, classTarget,
      	      accessSourceFromTargetName, accessTargetFromSourceName,
      	      fwName, reverseName,
      	      multTargetToSource, multSourceToTarget,
      	      instLevelSource, instLevelTarget) */
          in
            if problems.isEmpty() then
      	      problems := m.addAssociation(self.getPackage(requestID),
      	        classSource, classTarget,
      	        accessSourceFromTargetName, accessTargetFromSourceName,
      	        fwName, reverseName,
      	        multTargetToSource, multSourceToTarget,
      	        instLevelSource, instLevelTarget,
      	        sourceVisibleFromTarget, targetVisibleFromSource,
      	        isSymmetric, isTransitive)
       	    end
          end
    end

    @Operation removeAssociation(
      requestID     : Seq(Integer),
      sourcePath    : String,
      targetName    : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
        //problems = m.removeAssociation(assoc);
        //packagePath = assoc.owner.path();
        //assocName =  assoc.name
      then
        problems = m.removeAssociation(sourceClass, targetName)
      in
        //if problems.isEmpty() then
        //  self.log := self.log + [["removeAssociation", ["package", packagePath], ["name", assocName]]]
        //end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation setAssociationEndVisibility(
      requestID      : Seq(Integer),
      sourcePath     : String,
      targetName     : String,
      concernsTarget : Boolean,
      newVisibility  : Boolean)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
      then
        assoc = self.findAssociation(sourceClass, targetName)
        // assoc = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.setAssociationEndVisibility(assoc, concernsTarget, newVisibility)
      in
        if problems.isEmpty() then
          self.log := self.log + [["setAssociationEndVisibility", ["package", assoc.owner.path()], ["concernsTarget", concernsTarget+""], ["newVisibility", newVisibility+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAssociationForwardName(
      requestID     : Seq(Integer),
      sourcePath    : String,
      targetName    : String,
      newName       : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
      then
        assoc = self.findAssociation(sourceClass, targetName)
        // assoc = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        oldName = assoc.name
      then
        problems = m.changeAssociationForwardName(assoc, newName)
      in
//        if problems.isEmpty() then
//          self.log := self.log + [["changeAssociationForwardName", ["package", assoc.owner.path()], ["newFwName", newName], ["oldFwName", oldName]]]
//        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAssociationEnd2StartMultiplicity(
      requestID : Seq(Integer),
      sourcePath    : String,
      targetName    : String,
      multV)

      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
      then
        a = self.findAssociation(sourceClass, targetName)
        // a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      then
        problems = m.changeAssociationMultiplicity(a, newMult, null)
      in
//        if problems.isEmpty() then
//          self.log := self.log + [["changeAssociationEnd2StartMultiplicity", ["package", a.owner.path()], ["name", a.name], ["multiplicity", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
//        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeAssociationStart2EndMultiplicity(
      requestID     : Seq(Integer),
      sourcePath    : String,
      targetName    : String,
      multV)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
      then
        a = self.findAssociation(sourceClass, targetName)
        // a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      then
        problems = m.changeAssociationMultiplicity(a, null, newMult)
      in
//        if problems.isEmpty() then
//          self.log := self.log + [["changeAssociationStart2EndMultiplicity", ["package", a.owner.path()], ["name", a.name], ["multiplicity", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
//        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation changeAssociationStart2EndAccessName(
      requestID : Seq(Integer),
      sourcePath    : String,
      targetName    : String, 
      name)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
      then
        a = self.findAssociation(sourceClass, targetName)
        // a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.changeAssociationAccessName(a, null, name)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeAssociationEnd2StartAccessName(
      requestID : Seq(Integer),
      sourcePath    : String,
      targetName    : String, 
      name)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
      then
        a = self.findAssociation(sourceClass, targetName)
        // a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.changeAssociationAccessName(a, name, null)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation changeAssociationStart2EndLevel(
      requestID : Seq(Integer),
      sourcePath    : String,
      targetName    : String,
      level)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
      then
        a = self.findAssociation(sourceClass, targetName)
        // a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.changeAssociationLevel(a, null, FMMLx::Level(level))
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeAssociationEnd2StartLevel(
      requestID : Seq(Integer),
      sourcePath    : String,
      targetName    : String, 
      level)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        sourceClass = m.evalString(sourcePath, self.getPackage(requestID)).at(0)
      then
        a = self.findAssociation(sourceClass, targetName)
        // a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.changeAssociationLevel(a, FMMLx::Level(level), null)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    //////////////////////////////////////////////////////////

    @Operation findAssociation(obj1, obj2, aName)
      let 
        classes1 = obj1.allAncestors()
      then
        atts1 = classes1->collect(c | c.attributes)->flatten()
      then
        assoc = atts1
          ->select(a | a.isKindOf(Associations::End))
          ->collect(e | e.association)
          ->select(a | a.name.equals(aName))
      in
        if assoc.size() > 1 then throw Exception("too many associations found")
        elseif assoc.size() < 1 then throw Exception("no association ("+aName+") found")
        else assoc.asSeq().at(0)
        end
      end 
    end
    
    @Operation findAssociation(obj1, role2AccessName)
      let 
        classes1 = {obj1} + obj1.allAncestors()
      then
        atts1 = classes1
          ->select(c|c.isKindOf(Class))
          ->collect(c | c.attributes)->flatten()
      then
        assoc = atts1
          ->select(a | a.isKindOf(Associations::End))
          ->collect(e | e.association)
          ->select(a | a.target.name.toString().equals(role2AccessName))
      in
        if assoc.size() > 1 then throw Exception("too many associations found")
        elseif assoc.size() < 1 then throw Exception("no association ("+role2AccessName+") found")
        else assoc.asSeq().at(0)
        end
      end 
    end

    //////////////////////////////////////////////////////////

    @Operation addLink(requestID : Seq(Integer),
      obj1Name  : String,
      obj2Name  : String,
      role2Name : String)

      let
  	    m = FmmlxDiagrams::FmmlxManipulator()
  	  then
  	    obj1 = m.evalString(obj1Name, self.getPackage(requestID)).at(0);//if self.getPackage(requestID).hasElement(obj1Name) then self.getPackage(requestID).getElement(obj1Name) else null end;
  	    obj2 = m.evalString(obj2Name, self.getPackage(requestID)).at(0)//if self.getPackage(requestID).hasElement(obj2Name) then self.getPackage(requestID).getElement(obj2Name) else null end
  	  then
        association = try self.findAssociation(obj1, role2Name) catch (e) self.findAssociation(obj1, obj2, role2Name) end
 	  then
        problems = m.addAssociationInstance(self.getPackage(requestID), obj1, obj2, association)
  	  in
  	    if problems.isEmpty() then
  	      self.log := self.log + [["addLink", ["package", "tbd"], ["name", association.name.toString()], ["classSource", obj1.path()], ["classTarget", obj2.path()]]]
  	    end;
  	    self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
  	  end
    end

    @Operation mergeAssociationInstance(requestID : Seq(Integer),
          obj1Name  : String,
          obj2Name  : String,
          assocName : String)

      	  let
      	    m = FmmlxDiagrams::FmmlxManipulator();
      	    obj1 = if self.getPackage(requestID).hasElement(obj1Name) then self.getPackage(requestID).getElement(obj1Name) else null end;
      	    obj2 = if self.getPackage(requestID).hasElement(obj2Name) then self.getPackage(requestID).getElement(obj2Name) else null end;
      	    association = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      	  then
            problems = m.addAssociationInstance(self.getPackage(requestID), obj1, obj2, association)
      	  in
      	    if problems.isEmpty() then
      	      self.log := self.log + [["addLink", ["package", association.owner.path()], ["name", association.name.toString()], ["classSource", obj1.path()], ["classTarget", obj2.path()]]]
      	    end
      	  end
    end

    @Operation removeLink(
      requestID : Seq(Integer),
      role2Name : String,
      obj1Name  : String,
      obj2Name  : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        obj1 = if self.getPackage(requestID).hasElement(obj1Name) then self.getPackage(requestID).getElement(obj1Name) else null end;
        obj2 = if self.getPackage(requestID).hasElement(obj2Name) then self.getPackage(requestID).getElement(obj2Name) else null end
      then
        association = self.findAssociation(obj1, role2Name)
        //association = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.removeAssociationInstance(association,obj1,obj2)
      in
        if problems.isEmpty() then
          self.log := self.log + [["removeLink", ["package", association.owner.path()], ["name", association.name.toString()], ["classSource", obj1.path()], ["classTarget", obj2.path()]]]
  	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    ////////////////// Operations for delegation ///////////////////////////

    @Operation addDelegation(
      requestID   : Seq(Integer),
      delegateFromName  : String,
      delegateToName    : String,
      delegateToLevel   : Integer)
    //("delegateFromName: " + delegateFromName).println();
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        delegateFrom = if self.getPackage(requestID).hasElement(delegateFromName) then self.getPackage(requestID).getElement(delegateFromName) else null end;
        delegateTo = if self.getPackage(requestID).hasElement(delegateToName) then self.getPackage(requestID).getElement(delegateToName) else null end
      then
        problems = m.setDelegation(delegateFrom, delegateTo, FMMLx::Level(delegateToLevel))
      in
        if problems.isEmpty() then
            self.log := self.log + [["addDelegation", ["package", delegateFrom.owner.path()],
              ["delegateFrom",  delegateFrom.path()],  
              ["delegateTo",  delegateTo.path()],  
              ["delegateToLevel",  delegateToLevel+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation mergeDelegation(
          requestID   : Seq(Integer),
          delegateFromName  : String,
          delegateToName    : String,
          delegateToLevel   : Integer)
          let
            m = FmmlxDiagrams::FmmlxManipulator();
            delegateFrom = if self.getPackage(requestID).hasElement(delegateFromName) then self.getPackage(requestID).getElement(delegateFromName) else null end;
            delegateTo = if self.getPackage(requestID).hasElement(delegateToName) then self.getPackage(requestID).getElement(delegateToName) else null end
          then
            problems = m.setDelegation(delegateFrom, delegateTo, delegateToLevel)
          in
            if problems.isEmpty() then
                self.log := self.log + [["addDelegation", ["package", delegateFrom.owner.path()],
                  ["delegateFrom",  delegateFrom.path()],
                  ["delegateTo",  delegateTo.path()],
                  ["delegateToLevel",  delegateToLevel+""]]]
            end
          end
        end
    
    @Operation removeDelegation(
      requestID   : Seq(Integer),
      delegateFromName  : String)
    //("delegateFromName: " + delegateFromName).println();
    let
        m = FmmlxDiagrams::FmmlxManipulator();
        delegateFrom = if self.getPackage(requestID).hasElement(delegateFromName) then self.getPackage(requestID).getElement(delegateFromName) else null end
      then
        problems = m.removeDelegation(delegateFrom)
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeDelegation", ["package", delegateFrom.owner.path()],
              ["delegateFrom",  delegateFrom.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeDelegationLevel(requestID : Seq(Integer), className, level)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then 
        c = m.evalString(className, self.getPackage(requestID)).at(0)
      then
        problems = ["This change has been accepted but not been propagated. Check the role fillers."]
      in
        c.delegatesToLevel := level;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation setRoleFiller(
      requestID   : Seq(Integer),
      roleName  : String,
      roleFillerName    : String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then 
        role =  m.evalString(roleName, self.getPackage(requestID)).at(0);
        roleFiller =  m.evalString(roleFillerName, self.getPackage(requestID)).at(0)
      then
        problems = m.setRoleFiller(role, roleFiller)
      in
        if problems.isEmpty() then
            self.log := self.log + [["setRoleFiller", ["package", role.owner.path()], ["role", role.path()], ["roleFiller", roleFiller.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation mergeRoleFiller(
          requestID   : Seq(Integer),
          roleName  : String,
          roleFillerName    : String)
          let
            m = FmmlxDiagrams::FmmlxManipulator();
            role = if self.getPackage(requestID).hasElement(roleName) then self.getPackage(requestID).getElement(roleName) else null end;
            roleFiller = if self.getPackage(requestID).hasElement(roleFillerName) then self.getPackage(requestID).getElement(roleFillerName) else null end
          then
            problems = m.setRoleFiller(role, roleFiller)
          in
            if problems.isEmpty() then
                self.log := self.log + [["setRoleFiller", ["package", role.owner.path()], ["role", role.path()], ["roleFiller", roleFiller.path()]]]
            end
          end
        end
    
    @Operation removeRoleFiller(
      requestID   : Seq(Integer),
      roleName    : String)
    let
        m = FmmlxDiagrams::FmmlxManipulator();
        role = if self.getPackage(requestID).hasElement(roleName) then self.getPackage(requestID).getElement(roleName) else null end
      then
        problems = m.removeRoleFiller(role)
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeRoleFiller", ["package", role.owner.path()],
              ["role",  role.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    ////////////////// Operations for editing operations ///////////////////

    @Operation changeOperationName(requestID : Seq(Integer), className, oldName, newName)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeOperationName(class, oldName, newName) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeOperationName(class, oldName, newName);
          self.log := self.log + [["changeOperationName", ["package", class.owner.path()], ["oldName", oldName] , ["newName", newName] , ["class", class.path()]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeOperationLevel(requestID : Seq(Integer), classPath, name, oldLevel, newLevel)

      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        o = m.findOperation(class,name)
      then
        problems = if class <> null then m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o)) else ["Class not found"] end
        //problems = m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o))
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeOperationLevel", ["package", class.owner.path()], ["oldLevel", oldLevel+""], ["newLevel", newLevel+""] , ["name", name] , ["class", class.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation addOperation(
      requestID  : Seq(Integer),
      className  : String,
      level      : Integer,
      body       : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.addOperation(class, FMMLx::Level(level), body) else ["Class not found"] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["addOperation2", ["package", class.owner.path()],
            ["class", class.path()],
            ["level", level+""],
            ["body", body]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation mergeOperation(
          requestID  : Seq(Integer),
          className  : String,
          level      : Integer,
          body       : String)

          let
            m = FmmlxDiagrams::FmmlxManipulator();
            class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
          then
            problems = if class <> null then m.addOperation(class, level, body) else ["Class not found"] end
          in
            if problems.isEmpty() then
                self.log := self.log + [["addOperation2", ["package", class.owner.path()],
                ["class", class.path()],
                ["level", level+""],
                ["body", body]]]
            end
          end
        end

    @Operation removeOperation(
      requestID  : Seq(Integer),
      className    : String,
      opName     : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        //class = self.getMapping(requestID).getMapping(classId).object
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        //problems = m.removeOperation(class, opName)
        problems = if class<>null then m.removeOperation(class, opName) else ["Class not found"] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeOperation", ["package", class.owner.path()], ["class", class.path()], ["name", opName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation getOpProp(operation, name) // for local use
      let
        properties = operation.properties();
        tagFound = null
      in
        @For property in properties do
          if property->head() = name
            then tagFound := property->tail()
          end
        end;
        tagFound
      end
    end

    @Operation changeOperationOwner(requestID : Seq(Integer), className_old, name, className_new)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        oldOwner = if self.getPackage(requestID).hasElement(className_old) then self.getPackage(requestID).getElement(className_old) else null end;
        newOwner = if self.getPackage(requestID).hasElement(className_new) then self.getPackage(requestID).getElement(className_new) else null end
      then
        operation = oldOwner.getOperation(name)
      then
        problems = m.changeOperationOwner(oldOwner, operation, newOwner)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeOperationOwner", ["package", oldOwner.owner.path()], ["class_old", oldOwner.path()], ["class_new",newOwner.path()] , ["name",name]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation checkOperationNameLegal(op, name):Boolean // todo: check for duplicates, consider arity
      let nameSymbol = Symbol(name) in
        if nameSymbol = op.name()
        then
          true
        else
          op.legalNameChangeCheck(nameSymbol,op.name())
        end
      end
    end

    @Operation changeOperationBody(requestID : Seq(Integer), className:String, operationName:String, body:String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
        problems = []
      then
        op = class.getOperation(operationName)
      then
        newName = body.splitBy("()[]",0,0)->head.subst("","@Operation ",false)
      in
//        if operationName.toString() <> newName.toString() then
//          problems := ["name change not allowed here"]
//        else
        if
          op = null then
          problems := ["operation not found"]
        else // let the manipulator try
          problems := m.changeOperationBody(class, op, newName, body)
        end;
        if problems.isEmpty() orelse problems.equals(["Compiled successfully!"]) then
          self.log := self.log + [["changeOperationBody", ["package", class.owner.path()], ["class",className] , ["name",operationName], ["body", body]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    ///////////////////////// Bottom-Up Modelling ///////////////////
    
    @Operation mergeProperties(
      requestID  : Seq(Integer),
      classPath  : String,
      mergeItemsVec  : Seq(Element)) 
      
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        mergeItems = self.vector2Seq(mergeItemsVec)
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      in
        ("Merge Properties into " + class.name).println();
        @For mergeItemVec in mergeItems do
          let 
            mergeItem = self.vector2Seq(mergeItemVec)
          then
            propType = mergeItem.at(0);
            propOwner = mergeItem.at(1);
            propName = mergeItem.at(2);
            propAction = mergeItem.at(3);
            propArg0 =  mergeItem.at(4)
          then
            owner = m.evalString(propOwner, self.getPackage(requestID)).at(0)
          in
            if "Attribute".equals(propType) then
              (propName + " -> " + propAction).println();
              if "DROP".equals(propAction) then
                ("action: removeAttribute(" + propOwner + "," + propName + ")").println();
                m.removeAttribute(owner, propName, null);
                self.log := self.log + [["removeAttribute", ["package", owner.owner.path()], ["class", owner.path()], ["name", propName]]]
              elseif "KEEP_AS".equals(propAction) then
                ("action: changeAttributeName(" + propOwner + "," + propName + "," + propArg0 + ")").println();
                m.changeAttributeName(owner, propName, propArg0);
                self.log := self.log + [["changeAttributeName", ["package", owner.owner.path()], ["class", owner.path()] , ["oldName", propName] , ["newName", propArg0]]]
              elseif "MERGE_INTO".equals(propAction) then
                ("not yet implemented: mergeSlotValuesInto(" + propOwner + "," + propName + "," + propArg0 + ")").println()
              elseif "PULL_UP".equals(propAction) then
                ("action: changeAttributeOwner(" + propOwner + "," + propName + "," + class.name + ")").println();
                m.changeAttributeOwner(propOwner, propName, propArg0);
                self.log := self.log + [["changeAttributeOwner",["package", propOwner.owner.path()],["oldName", oldName],["name", name],["newName", newName]]]
              else
                ("Command not yet implemented: " + propAction).println()
              end // if action
            end // if attribute        
          end // let
        end // for each mergeItem
      end // let
    end // @
    
    ///////////////////////// Constraints ///////////////////////////
    
    @Operation addConstraint(
      requestID  : Seq(Integer),
      classPath  : String,
      constName  : String,
      instLevel  : Integer,
      body       : String,
      reason     : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0);
        constSymbol = constName.asSymbol()
      then
        problems = if class <> null then m.addConstraint(class, constSymbol, body, reason, FMMLx::Level(instLevel), FMMLx::Severity::USER_DEFINED, "NO_SOLUTION") else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["addConstraint", ["package", class.owner.path()],
            ["class", class.path()],
            ["constName", constName],
            ["instLevel", instLevel+""],
            ["body", body],
            ["reason", reason]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation mergeConstraint(
          requestID  : Seq(Integer),
          classPath  : String,
          constName  : String,
          instLevel  : Integer,
          body       : String,
          reason     : String)

          let
            m = FmmlxDiagrams::FmmlxManipulator()
          then
            class = m.evalString(classPath, self.getPackage(requestID)).at(0);
            constSymbol = constName.asSymbol()
          then
            problems = if class <> null then m.addConstraint(class, constSymbol, body, reason, instLevel) else ["Class "+classPath+" not found."] end
          in
            if problems.isEmpty() then
                self.log := self.log + [["addConstraint", ["package", class.owner.path()],
                ["class", class.path()],
                ["constName", constName],
                ["instLevel", instLevel+""],
                ["body", body],
                ["reason", reason]]]
            end
          end
    end
    
    @Operation changeConstraintName(
      requestID  : Seq(Integer),
      classPath  : String,
      oldName    : String,
      newName    : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0);
        newNameSymbol = newName.asSymbol()
      then
        problems = if class <> null then m.changeConstraintName(class, oldName, newNameSymbol) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["changeConstraintName", ["package", class.owner.path()],
            ["class", class.path()],
            ["oldName", oldName],
            ["newName", newName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeConstraintLevel(
      requestID  : Seq(Integer),
      classPath  : String,
      name       : String,
      level      : Integer)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.changeConstraintLevel(class, name, level) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["changeConstraintName", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name],
            ["level", level+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeConstraintBodyAndReason(
      requestID  : Seq(Integer),
      classPath  : String,
      name       : String,
      body       : String,
      reason     : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.changeConstraintBodyAndReason(class, name, body, reason) else ["Class "+classPath+" not found."] end
      in
        /*if problems.isEmpty() then
            self.log := self.log + [["changeConstraintBodyAndReason", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name],
            ["body", body+""],
            ["reason", reason+""]]]
        end;*/
        if problems.isEmpty() then
            self.log := self.log 
            + [["removeConstraint", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name]]] 
            + [["addConstraint", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name],
            ["instLevel", class.getConstraint(name).body.instLevel+""],
            ["body", body],
            ["reason", reason]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation changeConstraintOwner(
      requestID    : Seq(Integer),
      oldClassPath : String,
      newClassPath : String,
      name         : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        oldClass = m.evalString(oldClassPath, self.getPackage(requestID)).at(0);
        newClass = m.evalString(newClassPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.changeConstraintOwner(oldClass, newClass, name) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["changeConstraintReason", ["package", class.owner.path()],
            ["oldClassPath", oldClass.path()],
            ["newClassPath", newClass.path()],
            ["name", name]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation removeConstraint(
      requestID  : Seq(Integer),
      classPath  : String,
      name       : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = m.evalString(classPath, self.getPackage(requestID)).at(0)
      then
        problems = if class <> null then m.removeConstraint(class, name) else ["Class "+classPath+" not found."] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeConstraint", ["package", class.owner.path()],
            ["class", class.path()],
            ["name", name]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    // Not yet implemented

    @Operation respondNotYetImplemented(name: String, requestID : Seq(Integer))
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["The feature \"" + name + "\" is temporarily unavailable. Please try again in later version."]])
    end

    @Operation updateAssociationInstance(requestID : Seq(Integer), startObjectPath : String, endObjectPath : String)
      self.respondNotYetImplemented("updateAssociationInstance", self.vector2Seq(requestID))
    end

    @Operation changeAssociationTarget(inA : Seq(Integer), nameT_o, nameT_n)
      self.respondNotYetImplemented("changeAssociationTarget", self.vector2Seq(requestID))
    end

    @Operation changeAssociationSource(inA : Seq(Integer), idS_o, idS_n)
      self.respondNotYetImplemented("changeAssociationSource", self.vector2Seq(requestID))
    end

    @Operation checkOperationBody(requestID : Seq(Integer), operationBodyToBeChecked)
      self.respondNotYetImplemented("checkOperationBody", self.vector2Seq(requestID))
    end

    @Operation changeOperationType(requestID : Seq(Integer), className, opName, newType)
      self.respondNotYetImplemented("changeOperationType", self.vector2Seq(requestID))
    end

    @Operation changeOf(requestID : Seq(Integer), idO, idC_old, idC_new)
      self.respondNotYetImplemented("changeOf", self.vector2Seq(requestID))
    end

    @Operation addEnumeration(requestID : Seq(Integer), newEnumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumeration(self.getPackage(requestID), newEnumName)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addEnumeration", ["name",newEnumName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation mergeEnumeration(requestID : Seq(Integer), newEnumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumeration(self.getPackage(requestID), newEnumName)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addEnumeration", ["name",newEnumName]]]
        end
      end
    end

    @Operation changeEnumerationName(requestID : Seq(Integer), oldEnumName:String, newEnumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationName(self.getPackage(requestID), oldEnumName, newEnumName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation removeEnumeration(requestID : Seq(Integer), enumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumeration(self.getPackage(requestID), enumName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation addEnumerationValue(requestID : Seq(Integer), enumName:String, newEnumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumerationValue(self.getPackage(requestID), enumName, newEnumValueName)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addEnumerationValue", ["enum_name",enumName], ["enum_value_name", newEnumValueName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation mergeEnumerationValue(requestID : Seq(Integer), enumName:String, newEnumValueName:String)
          let
            m = FmmlxDiagrams::FmmlxManipulator()
          then
            problems = m.addEnumerationValue(self.getPackage(requestID), enumName, newEnumValueName)
          in
            if problems.isEmpty() then
                self.log := self.log + [["addEnumerationValue", ["enum_name",enumName], ["enum_value_name", newEnumValueName]]]
            end
          end
        end

    @Operation changeEnumerationValueName(requestID : Seq(Integer), enumName:String, oldEnumValueName:String, newEnumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationValueName(self.getPackage(requestID), enumName, oldEnumValueName, newEnumValueName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation removeEnumerationValue(requestID : Seq(Integer), enumName:String, enumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumerationValue(self.getPackage(requestID), enumName, enumValueName)
      in
        ("removeEnumerationValue problems: " + problems).println();
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation printProtocol(requestID : Seq(Integer)) // to be removed
      self.log.println()
    end

    @Operation printLog(requestID : Seq(Integer))
      self.log.println()
    end

    @Operation assignToGlobal(requestID : Seq(Integer), objPath:String, varName:String)
      let
        class = FmmlxDiagrams::FmmlxManipulator().evalString(objPath, self.getPackage(requestID)).at(0)
      in
        if
          class <> null
        then
          class.assignToGlobal(varName)
        end;
        []
      end
    end

    @Operation showBody(requestID : Seq(Integer), objPath:String, opName:String, arity:Integer)
      let
        class = FmmlxDiagrams::FmmlxManipulator().evalString(objPath, self.getPackage(requestID)).at(0)
      in
        if
          class <> null andthen class.getOperation(opName) <> null
        then
          class.getOperation(opName).edit()
        end;
        []
      end
    end

    @Operation updateAll(obj:Element)
      let
        clients = Clients::FmmlxDiagrams::FmmlxDiagramClient.allInstances()->select(a | a.package = obj.owner)
      in
        @For client in clients do
          client.communicator.triggerUpdate()
        end
      end
    end

	@Operation runOperation(requestID : Seq(Integer), text)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        parseResult = m.evalString(text, self.getPackage(requestID))
      in
        if parseResult.at(1) <> null then 
           self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), [parseResult.at(1)]])
        end
      end
	end

    @Operation evalList(requestID : Seq(Integer), text)
      ("eval List start: " + text).println();
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        result = [];
        error = [];
        parseResult = m.evalString(text, self.getPackage(requestID))
      in
        if
          parseResult.at(1) = null
        then
          parseResult.at(0).println();
          if
            parseResult.at(0).isKindOf(Seq(Element))
          then
            @For element in parseResult.at(0) do
              result := result + [element.toString()]
            end
          else
            result:=["The expression " + text + " does not evaluate to a list."]
          end
        else
          parseResult.at(1).println();
          result:=[parseResult.at(1)]
        end;
        "eval List done".println();
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation addDefaultEnums(p:Package)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        if not p.hasElement("Level") then
          m.addEnumeration(p, "Level");
          m.addEnumerationValue(p, "Level", "High");
          m.addEnumerationValue(p, "Level", "Medium");
          m.addEnumerationValue(p, "Level", "Low") end;
        if not p.hasElement("Gender") then
          m.addEnumeration(p, "Gender");
          m.addEnumerationValue(p, "Gender", "Male");
          m.addEnumerationValue(p, "Gender", "Female");
          m.addEnumerationValue(p, "Gender", "Unspecified") end;
        if not p.hasElement("LegalForm") then
          m.addEnumeration(p, "LegalForm");
          m.addEnumerationValue(p, "LegalForm", "Private_Limited_Partnership");
          m.addEnumerationValue(p, "LegalForm", "Limited_Liability");
          m.addEnumerationValue(p, "LegalForm", "Corporation");
          m.addEnumerationValue(p, "LegalForm", "Non_Profit") end;
        if not p.hasElement("Unit") then
          m.addEnumeration(p, "Unit");
          m.addEnumerationValue(p, "Unit", "piece");
          m.addEnumerationValue(p, "Unit", "kg");
          m.addEnumerationValue(p, "Unit", "litre");
          m.addEnumerationValue(p, "Unit", "gr");
          m.addEnumerationValue(p, "Unit", "meter");
          m.addEnumerationValue(p, "Unit", "km");
          m.addEnumerationValue(p, "Unit", "qm");
          m.addEnumerationValue(p, "Unit", "crate") end
      end
    end

    @Operation getDiagramData(requestID : Seq(Integer))
       //self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), if log.size() = 0 then ["log"] else ["log"] + log end])
       let
         diagramID = self.vector2Seq(requestID).at(0)
       then
         diagram = self.diagrams.get(diagramID)
       then
         package = diagram.package;
         log = ["log"]
       in
         let
           maxLevel = 0;
           classes = package.classes;
           associations = package.associations;
           links = package.fmmlxAssociationInstances
         //then
           //sort classes; //TODO ????? how to sort? if impossible leave it to java (consider parents)
         in
           @For class in classes do
             if class.isKindOf(FMMLx::MetaClass) andthen class.level.minLevel>maxLevel then
               maxLevel := class.level.minLevel
             end
           end;
           @For level in (-maxLevel).to(0) do
             @For class in classes do
               if class.isKindOf(FMMLx::FmmlxObject) andthen class.level.minLevel=(-level) then
                 if class.of() = FMMLx::MetaClass then
                   log := log + 
                     [["addMetaClass",
                      ["package", class.owner.path()],
                      ["name", class.name.toString()],
                      ["level", class.level.minLevel+""],
                      ["maxLevel", if class.level.maxLevel = null then "none" else class.level.maxLevel+"" end],
                      ["abstract", class.isAbstract+""],
                      ["singleton", class.isSingleton+""]]]
                 elseif class.isKindOf(FMMLx::MetaClass) then
                   log := log + 
                     [["addInstance", 
                      ["package", class.owner.path()], 
                      ["of", class.of().path()], 
                      ["level", class.level.minLevel+""], 
                      ["maxLevel", if class.level.maxLevel = null then "none" else class.level.maxLevel+"" end],
                      ["name",class.name.toString()], 
                      ["abstract", class.isAbstract+""],
                      ["singleton", class.isSingleton+""]]]
                 else // must be FMMLx::FmmlxObject only and therefore on level 0
                   log := log + 
                     [["addInstance", 
                      ["package", class.owner.path()], 
                      ["of", class.of().path()], 
                      ["level", class.level.minLevel+""], 
                      ["maxLevel", if class.level.maxLevel = null then "none" else class.level.maxLevel+"" end],
                      ["name",class.name.toString()], 
                      ["abstract", "false"], // deprecated
					  ["singleton", "false"]
                      ]]
                 end
               end
             end
           end;
           @For enumClass in classes->select(c | c.isKindOf(Enum)) do
             let
               enumItems = enumClass.getChildren()
             in
               log:= log + [["addEnumeration", ["name",enumClass.name.toString()]]];
               @For item in enumItems do
                 log:= log + [["addEnumerationValue", ["enum_name",enumClass.name.toString()], ["enum_value_name", item.name.toString()]]]
   	           end
             end
           end;
           @For class in classes->select(c | c.isKindOf(FMMLx::MetaClass)) do
             if self.getParentsPaths(requestID, class.parents->select(c | c.owner = class.owner)) <> "" then
               log:= log + [["changeParent",
                            ["package", class.owner.path()],
                            ["class", class.path()],
                            ["old", ""],
                            ["new", self.getParentsPaths(requestID, class.parents->select(c | c.owner = class.owner))]]]
             end
           end;
           @For class in classes->select(c | c.isKindOf(FMMLx::MetaClass)) do
             @For att in class.attributes.asSeq()
                         ->reject(a | a.isKindOf(Associations::End)) do
               log := log + [["addAttribute", ["package", class.owner.path()],
                             ["class", class.path()],
                             ["name", att.name.toString()],
                             ["level", att.instLevel.minLevel+""],
                             ["type", att.type.path()],
                             ["multiplicity",  FmmlxManipulator::multiplicity2ValueList(att.mult())+""]]]
             end;
             @For op in class.operations.asSeq() do
             let
               paramTypesRaw = op.paramTypes()
             then
               paramSize = paramTypesRaw.size()
             then
               paramTypes = Vector(paramSize)
             in
                @For i in 0.to(paramTypesRaw.size()-1) do
                  paramTypes.put(i, self.getPathAsString(paramTypesRaw.at(i)))
                end;
                log := log + [["addOperation", ["package", class.owner.path()],
                             ["class", class.path()],
                             ["name", op.name.toString()],
                             ["paramNames", self.getListFromSeq(requestID, op.paramNames())],
                             ["paramTypes", self.getListFromSeq(requestID, paramTypes.asSeq())],
                             ["type", self.getReturnPathAsString(op)],
                             ["level", op.instLevel.minLevel+""],
                             ["monitored", self.isOperationMonitored(op).toString()],
                             ["body", op.codeBox.source()]]]

             end

             end;
             @For constraint in class.constraints.asSeq() do
               log := log + [["addConstraint", ["package", class.owner.path()],
                                       ["class", class.path()],
                                       ["constName", constraint.name.toString()],
                                       ["instLevel", constraint.body.instLevel.minLevel+""],
                                       ["body", OCL::OCL.grammar.parseString(constraint.get("body").source(),"Exp1",Seq{XOCL}).performable.pprint(3)],
                                       ["reason", OCL::OCL.grammar.parseString(constraint.get("reason").source(),"Exp1",Seq{XOCL}).performable.pprint(3)]]]
             end
           end;
           @For class in classes  do// new for to make sure att exists
             let
               slots = class.slots()
             then
               slotNames = class.of().allAttributes()->select(a | not a.isKindOf(Associations::End))
                                                     ->select(a | a.owner.isKindOf(FMMLx::MetaClass))
                                                     .name
                                                     
             in 
               // evil unorthodox hack
               // slotNames := slotNames + {"lastUpdated".asSymbol()};

               @For slot in slots do
                 if slotNames.contains(slot.name) then
                   log := log + [["changeSlotValue", ["package", class.owner.path()],
                                ["class", class.path()],
                                ["slotName", slot.name.toString()],
                                ["valueToBeParsed", self.toParseableString(slot.value, class.owner)]]]
                 end
               end
             end
           end;
           @For assoc in classes
                         ->select(c | c.isKindOf(FMMLx::MetaClass))
                         ->collect(c | c.allAttributes())
                         ->flatten()
                         ->select(a | a.isKindOf(Associations::End))
                         ->collect(e | e.association) do
//           @For assoc in associations.asSeq() do
             log := log + [["addAssociation", ["package", assoc.source.type.owner.path()],
                                     ["classSource", assoc.source.type.path()] ,["classTarget", assoc.target.type.path()] ,
                                     ["accessSourceFromTargetName", assoc.source.name.toString()] , ["accessTargetFromSourceName", assoc.target.name.toString()] ,
                                     ["fwName", assoc.name.toString()+""],
                                     ["reverseName", "-1"],
                                     ["multTargetToSource", FmmlxManipulator::multiplicity2ValueList(assoc.source.mult())+""] , ["multSourceToTarget", FmmlxManipulator::multiplicity2ValueList(assoc.target.mult())+""] ,
                                     ["instLevelSource", assoc.target.instLevel.minLevel+""] , ["instLevelTarget", assoc.source.instLevel.minLevel+""] ,
                                     ["sourceVisibleFromTarget", assoc.source.visible+""] , ["targetVisibleFromSource", assoc.target.visible+""]
//                                     ,["isSymmetric", assoc.symmetric()+""] , ["isTransitive", assoc.transitive()+""]
                                     ]]
           end;
           @For object in self.getPackage(requestID).classes do
             @For slot in object.slots()
               ->select(s | s.type.of() = Associations::End)
               ->select(s | s.type.association.target = s.type)              
             do             
               let
                 linkList = {}
               in
                 if 
                   slot.value = null or slot.value = {} 
                 then 
                   null // do nothing 
                 elseif
                   slot.value.isKindOf(Set(Element))
                 then // found multi value 
                   linkList := slot.value
                 else // found single value               
                   linkList := {slot.value}
                 end;
                 @For item in linkList do
                   log := log + [["addLink", 
                     ["package", object.owner.path()], 
                     ["name", slot.type.name.toString()], 
                     ["classSource", object.path()], 
                     ["classTarget", item.path()]]]
                 end
               end
             end
           end;
           @For class in classes->select(c | c.isKindOf(FMMLx::MetaClass)) do
             if
               class.delegatesTo <> null
             then
               log := log + [["addDelegation", ["package", class.owner.path()],
                                         ["delegateFrom",  class.path()],
                                         ["delegateTo",  class.delegatesTo.path()],
                                         ["delegateToLevel",  class.delegatesToLevel+""]]]
             end
           end;
           @For class in classes do
             if class.roleFiller <> null
             then
               log := log + [["setRoleFiller", ["package", class.owner.path()], ["role", class.path()], ["roleFiller", class.roleFiller.path()]]]
             end
           end;
           self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), log])
         end //(let);
       end
    end
    
    @Operation findClasses(requestID: Seq(Integer), className:String, levelText:String, attName:String) 
      let
        result = ["Foo", "Goo", "Hoo"]
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation findOperationImplementation(requestID: Seq(Integer), opNames: Seq(String), model:String, arity:String, returnType:String)
      let
        result = [];
        allClasses = Class.allInstances();
        opName = self.vector2Seq(opNames).at(0)
      in
        @For class in allClasses do
          @For op in class.operations do
            if op.name.toString() = opName.toString() then
              let paramTypes = [] in
                @For pt in op.paramTypes() do paramTypes := paramTypes + [pt.path()] end;
                result := result + [[
                  class.path(),
                  class.name.toString(),
                  op.arity,
                  op.paramNames(),
                  paramTypes,
                  op.type.path(),
                  op.codeBox.source()]]
              end
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation findAllOperations(requestID: Seq(Integer))
      let
        result = [];
        allClasses = Class.allInstances()
      in
        @For class in allClasses do
          @For op in class.operations do
              let paramTypes = [] in
                @For pt in op.paramTypes() do paramTypes := paramTypes + [pt.path()] end;
                result := result + [[
                  class.path(),
                  class.name.toString(),
                  op.arity,
                  op.paramNames(),
                  paramTypes,
                  op.type.path(),
                  op.codeBox.source()]]
              end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation findOperationUsage(requestID: Seq(Integer), opName: String, usage:String)

      let
        result = [];
        StringCheck = xmf.javaClass("tool.helper.StringCheck")
      then
        stringCheck = StringCheck()
      in
        @For class in Classifier.allInstances() do
          @For op in class.operations do
            if stringCheck.contains(op.codeBox.source(), opName) then
              result := result + [[
                class.path(),
                class.name.toString(),
                op.name.toString(),
                op.arity,
                op.paramNames(),
                null,
                op.type.path(),
                op.codeBox.source()]]
            end
          end
        end;

        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end // let
    end // @Op

    @Operation hideElements(requestID: Seq(Integer), elementPaths: String, hide:Boolean)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        @For path in elementPaths do
          let
            element = m.evalString(path, self.getPackage(requestID)).at(0)
          in
            if
              element <> null
            then
              let
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(element.path())
              in
                mappingInfo.hidden := hide
              end // let
            end // if
          end // let
        end // for
      end // let
    end // @Op

    @Operation loadProjectFromXml(requestID : Seq(Integer), packageName : String, file : String)
      let
        package : XCore::Element = XCore::Package(packageName)
      in
        let
          project : XCore::Element = Projects::Project(package,"",null)
        in
          Root.add(package);
          xmf.projectManager("MyProjects").add(project);
          if Root.hasElement("FMMLx")
          then
            package.addParent(FMMLx)
          end
        end
      end;
      []
    end

    @Operation saveAsXml(requestID : Seq(Integer), packagePath, resourceName)
        let initName =
            if resourceName = ""
            then self.name + ".xml"
            else resourceName.toString().splitBy("/",0,0)->last
        end then
            file = xmf.saveFile(xmf.projDir(),"*.xml",initName)
        in
            if file <> "" then
            self.saveAsXml(requestID, file,packagePath, true)
        end
      end
    end

    @Operation saveAsXml(requestID : Seq(Integer), file:String, packagePath, confirm:Boolean)
        let write = true
        then
            package = self.getPackage(requestID)
        then
            project : XCore::Element = Projects::Project(package,"",null)
        in
            if not file.isReadOnly()
            then
                if write //and self.ensureDir(dir)
                then
                    let dialog = xmf.busy("Saving")
                    in
                        self.getCommunicator().saveXmlFile(file, package.toString());
                      	dialog.finished()  
                    end
                end
            else
                xmf.message("File " + file + " exists and is read only.  Cannot save to this file.")
            end
        end
    end

    @Operation isSaved(requestID : Seq(Integer), file:String)
        let
            package = self.getPackage(requestID)
        then
            project : XCore::Element= Projects::Project(package,"",null)
        in
            let
                write = true
            in
                project.savedBy := xmf.user();
                project.saveDate := xmf.date()
            end;
            xmf.message("Project " + project.name().toString() +
                    " saved (xml format).\nProject saved in file " + file + " on " + project.saveDate + ".\n" +
                    "Project created by " + project.creator + " on " + project.creationDate + ".\n" +
                    "Project saved by " + project.savedBy + ".\n")
        end
    end

    @Operation loaded(package):Boolean
      package <> null
    end
        
    @Operation getCachedPath(o : Object) 
      if self.cachedPaths.hasKey(o) then self.cachedPaths.get(o) else let p = o.path() in self.cachedPaths.put(o, p); p end end
    end
    
    @Operation toParseableString(o:Element, p: Package):String 
      if o = null orelse o.isKindOf(Integer) orelse o.isKindOf(Boolean)
        then o.toString()
      elseif o.isKindOf(Float) 
        then if o = 1/0 then "1/0" elseif o = 0/0 then "0/0" elseif o = -1/0 then "-1/0" else o.toString() end
      elseif o.isKindOf(String)
        // NOT then o.asSeq().pprint() + ".asString()" BECAUSE pprint caps at 10
        then
          let s = "["; seq = o.asSeq() in
            @For i in 0.to(seq.size()-1) do
              s := s + if i = 0 then "" else "," end + seq.at(i)
            end; s + "].asString()"
          end
      elseif o.of().isKindOf(Enum) orelse try o.owner() = p catch(e) false end
        then o.path()
      elseif try o.of().owner() = Auxiliary catch(e) false end // all classes in that package are supposed have that operation
        then o.toParseableString()
      else
        ("The object " + o + " of type " + o.of().path() + " cannot be saved.").println();
        "null"
      end
    end

    @Operation getListFromSeq(requestID : Seq(Integer), items) // for local use
      let list = "" in
        @For item in items do
          if not item = null then list := list + item + "," end
        end; // for
        list.subString(0, list.size()-1)
      end // let
    end
    
    @Operation sendViewStatusToModel(requestID : Seq(Integer), listOfViews) 
      let
        diagramID = self.vector2Seq(requestID).at(0)
      then
        diagram = diagrams.get(diagramID)
      in
        let seq = [] in
          @For view in listOfViews do
            let viewSeq = [] in
              @For item in view do
                viewSeq := viewSeq + [item]
              end;
              seq := seq + [viewSeq] 
            end
          end;      
          diagram.views := seq
        end
      end
    end
    
    @Operation getAllViews(requestID : Seq(Integer))
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), self.diagrams.get(self.vector2Seq(requestID).at(0)).views])
    end
    
    @Operation sendViewOptions(requestID : Seq(Integer), listOfOptions) 
      let
        diagramID = self.vector2Seq(requestID).at(0)
      then
        diagram = diagrams.get(diagramID)
      in
        let seq = [] in
          @For option in listOfOptions do
            let optionSeq = [] in
              @For item in option do
                optionSeq := optionSeq + [item]
              end;
              seq := seq + [optionSeq] 
            end
          end;      
          diagram.options := seq
        end
      end
    end
    
    @Operation getViewOptions(requestID : Seq(Integer))
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), self.diagrams.get(self.vector2Seq(requestID).at(0)).options])
    end
    
	@Operation undo(requestID : Seq(Integer)) 
      xmf.undo()
	  ;"undo".println()
    end
	
	@Operation redo(requestID : Seq(Integer)) 
      xmf.redo()
	  ;"redo".println()
    end
	
    @Operation evalString(requestID : Seq(Integer), text) 
      let
  	    m = FmmlxDiagrams::FmmlxManipulator()
      then
        eval = m.evalString(text, Root)
      then
        val = eval.at(0);
        problems = eval.at(1)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), [val+"", problems]])
      end
    end
    
    @Operation checkSyntax(requestID : Seq(Integer), opString : String)
      let
        problems = [];
        opAS = null;
        opASfun = null;
        operation = null;
        result = null
      in 
        // first parse
        opAS := try [OCL::OCL.grammar.parseString(opString,"Exp1",Seq{XOCL}),null] catch(exception) [null, exception] end;

        // then compile
        if 
          opAS.at(0) <> null 
        then 
          opASfun := try [Compiler::compileToFun("",opAS.at(0),Seq{},Seq{Seq{2|Root.contents},Seq{2|XCore.contents}},true),null] catch(exception) [null, exception] end
        else
          opASfun := opAS
        end;

        // create an instance of the operation
        if 
          opASfun.at(0) <> null
        then 
          operation := try [(opASfun.at(0))(),null] catch(exception) [null, exception] end
        else
          operation := opASfun
        end;
        
        if 
          operation.at(0) = null
        then // otherwise leave result at []
          let 
            exception = operation.at(1)
//          then
//            ep = try exception.errorPos catch(e) -1 end
          in
            result := [if exception = null then "Exception not found" else exception.message end]//, 
//                       exception.lineCount, 
//                       exception.charCount, 
//                       exception.pprint(), 
//                       ep]
          end
        end;
        
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
end
