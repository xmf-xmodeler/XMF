parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramClient extends Client//, DiagramListener

    @Attribute package : Package end
    @Attribute communicator : Element end
    @Attribute log : Seq(Element) = [] end
    @Attribute name : String = "no name set yet" end
    @Attribute diagrams : Table = Table(10) end
//    /* TEMP */ @Attribute diagram : FmmlxDiagram end
    
    @Constructor(name)
//      self.setCommandInterpreter(DiagramCommandInterpreter());
//      self.setEventHandler(DiagramEventHandler())
        null
    end
    
    @Operation getCommunicator()
      if self.communicator = null then
        let
          FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self)
        in
          self.communicator := FmmlxDiagramCommunicator();
          self.communicator.setHandle(handle)
        end
      end;
      self.communicator
    end
    @Operation createDiagram(package,name)
      let
        selectedNames = xmf.selects("Select Diagram","select existing diagram - or none for new", diagrams.values().diagramName,{},null)
      in
        if selectedNames = -1 then selectedNames := [] end;
        if
          selectedNames.size() = 0
        then
          self.createDiagram2(package,name)
        elseif
          selectedNames.size() = 1
        then
          ("diagrams: " + diagrams).println();
          let
            selectedName = selectedNames.at(0);
            keys = self.diagrams.keys();
            key = null;
            keyCount = 0
          in
            @While key = null and keyCount < keys.size() do
              if diagrams.get(keys.at(keyCount)).diagramName.toString() = selectedName.toString() then key := keys.at(keyCount) end;
              keyCount := keyCount + 1
            end;
            if key <> null then
//              self.communicator.reopenDiagram(key, selectedName.toString(), diagrams.get(key).package.path())
              self.communicator.newDiagram(key, diagrams.get(key).diagramName.toString(), diagrams.get(key).package.path())
            else
              "diagram not found".println()
            end
          end
        end
      end
    end

    @Operation createDiagram2(package,name)
        self.package := package;

        ///////////FIND ALTERNATIVE TO THIS///////////////////
        if
          package.of() <> FMML::FMMLxPackage
        then
          package.setOf(FMML::FMMLxPackage);
          Kernel_addAtt(package,"fmmlxAssociationInstances",{})
        end;

        self.addDefaultEnums(package);
        //////////////////////////////////////////////////////
        
        let 
          //FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self);
          diagram = FmmlxDiagram();
          newID = 0
        in
          //if diagram = null then self.diagram := FmmlxDiagram() end;
          //* FUTURE:
          @While diagrams.hasKey(newID) do newID := newID + 1 end;

          diagram.diagramName := ("Diagram " + package.name + " " + newID);
          diagram.package := package;
          self.diagrams.put(newID, diagram);
          
          //if self.communicator = null then 
          //  self.communicator := FmmlxDiagramCommunicator();
          //  self.communicator.setHandle(handle)
          //end;//*/
          self.getCommunicator();

          
          // TEMP
          //self.diagrams.put(newID, self.diagram);
          //self.communicator := FmmlxDiagramCommunicator();
          //self.communicator.setHandle(handle);
          self.communicator.newDiagram(newID, diagram.diagramName.toString(), self.package.path());

          diagram // vestigial return value for diagram manager
        end

    end

    @Operation getMapping(requestID : Seq(Integer))
      self.diagrams.get(self.vector2Seq(requestID).at(0)).mapping
    end

    //////////////////////// Queries ///////////////////////////////

    @Operation getAllObjects(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For c in self.package.classes do
    	    if c <> null andthen c.isKindOf(FMML::MetaClass) // TODO: find out how a null can possibly end up there
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(c)
    	      in
    	        result := result.append([[
    	        mappingInfo.id,
    	        c.name.toString(),
    	        c.level, // level
    	        if c.of().isKindOf(FMML::MetaClass) then self.getMapping(requestID).addOrGetObjectMapping(c.of()).id else -1 end,// of-ID
    	        self.getParentIdList(requestID, c),//[],// parents-ID
    	        c.isAbstract,
    	        mappingInfo.lastKnownDiagramX,
    	        mappingInfo.lastKnownDiagramY]])
    	      end
    	    end
    	  end;
    	  // clean up mapping ?
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllDelegationEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.package.classes do
          if object <> null then if object.delegatesTo <> null then
            if object.delegatesTo.isKindOf(FMML::MetaClass) then
              let
                childID = self.getMapping(requestID).addOrGetObjectMapping(object).id;
                parentID = self.getMapping(requestID).addOrGetObjectMapping(object.delegatesTo).id
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(("DelegatesToMapping"+childID+"/"+parentID).asSymbol())
              in
                result := result.append([[
  	            mappingInfo.id, // 0 ID
  	            childID, // 1 start ID
  	            parentID, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllRoleFillerEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.package.classes do
          if object <> null then if object.roleFiller <> null then
            if object.roleFiller.isKindOf(FMML::MetaClass) then
              let
                childID = self.getMapping(requestID).addOrGetObjectMapping(object).id;
                parentID = self.getMapping(requestID).addOrGetObjectMapping(object.roleFiller).id
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(("RoleFillerMapping"+childID+"/"+parentID).asSymbol())
              in
                result := result.append([[
  	            mappingInfo.id, // 0 ID
  	            childID, // 1 start ID
  	            parentID, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllInheritanceEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.package.classes do
          if object <> null then @For parent in object.parents do
            if parent.isKindOf(FMML::MetaClass) then
              let
                childID = self.getMapping(requestID).addOrGetObjectMapping(object).id;
                parentID = self.getMapping(requestID).addOrGetObjectMapping(parent).id
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(("InheritanceMapping"+childID+"/"+parentID).asSymbol())
              in
                result := result.append([[
  	            mappingInfo.id, // 0 ID
  	            childID, // 1 start ID
  	            parentID, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllAssociations(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For a in self.package.associations do
    	    if a.isKindOf(Associations::Association)
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(a)
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          self.getMapping(requestID).addOrGetObjectMapping(a.end1.type).id, // 1 source ID
    	          self.getMapping(requestID).addOrGetObjectMapping(a.end2.type).id, // 2 target ID
    	          -1, // 3 parent ID
    	          mappingInfo.points, // 4 points
    	          a.name.toString(), // 5 name 1
    	          null, // 6 name 2
    	          a.end2.name.toString(), // 7 name start->end slot name
    	          a.end1.name.toString(), // 8 name end->start slot name
    	          a.end2.instLevel, // 9 level s->t
    	          a.end1.instLevel, // 10 level t->s
    	          FmmlxManipulator::multiplicity2ValueList(a.end2.mult()), // 11 mul s->t
    	          FmmlxManipulator::multiplicity2ValueList(a.end1.mult()),  // 12 mul t->s
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id), // 13 labels
    	          a.end1.visible, // 14 visibility t->s
    	          a.end2.visible, // 15 visibility s->t
    	          a.symmetric, // 16
    	          a.transitive // 17
    	        ]])
    	      end // let
    	    else ("a is of " + a.of()).println()
    	    end // if
    	  end;
    	  // clean up mapping ?
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAssociationInstances(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For i in (if self.package.fmmlxAssociationInstances = null then {} else self.package.fmmlxAssociationInstances end) do

    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(i)
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          self.getMapping(requestID).addOrGetObjectMapping(i.at(0)).id, // 1 start ID
    	          self.getMapping(requestID).addOrGetObjectMapping(i.at(1)).id, // 2 end ID
    	          self.getMapping(requestID).addOrGetObjectMapping(i.at(2)).id, // 3 assoc ID
    	          mappingInfo.points, // 4 points
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id) // 5 labels
    	        ]])
    	      end // let
    	  end;
    	  // clean up mapping ?
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getOwnAttributes(requestID : Seq(Integer), className)
        let
          result = []
        in
          @For c in self.package.classes do
            if c <> null andthen c.isKindOf(FMML::MetaClass) and c.name.toString()  = className
            then
              @For a in c.attributes do
                result := result.append([[a.name.toString(), a.type.name.toString(), a.instLevel, a.mult()]])
              end
            end
          end;
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAttributes(requestID : Seq(Integer), className)
        let
          resultOwn   = [];
          resultOther = [];
          result = []
        in
          @For c in self.package.classes do
            if c <> null andthen c.isKindOf(FMML::MetaClass) and c.name.toString() = className
            then
              @For a in c.attributes do
                resultOwn   :=   resultOwn.append([[
                    a.name.toString(),
                    a.type.name.toString(),
                    a.instLevel,
                    FmmlxManipulator::multiplicity2ValueList(a.mult()),
                    self.getMapping(requestID).getMappingId(c)
                    ]])
              end;
              @For a in (c.allAttributes() - c.attributes) do
                if a.isIntrinsic then
                  resultOther := resultOther.append([[
                    a.name.toString(),
                    a.type.name.toString(),
                    a.instLevel,
                    FmmlxManipulator::multiplicity2ValueList(a.mult()),
                    self.getMapping(requestID).getMappingId(a.owner)
                    ]])
                end
              end
            end
          end;
          result := [resultOwn, resultOther];
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getSlots(requestID : Seq(Integer), objectName, slotList)
      let
        result = []
      in
        @For o in self.package.classes do
          if o <> null andthen o.isKindOf(FMML::MetaClass) andthen o.name.toString() = objectName
          then
            @For name in slotList do
              if o.hasSlot(name)
              then
                let
                  value = o.get(name)
                then
                  text = if value.of().isKindOf(Enum) then value.name().toString() else value.toString() end
                in
                  result := result.append([[name, text]])
                end
              end
            end
          end
        end;
    	self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getOperationValues(requestID : Seq(Integer), objectName, opNames)
      let
        result = []
      in
        @For obj in self.package.classes do
          if obj <> null andthen obj.isKindOf(FMML::MetaClass) andthen obj.name.toString() = objectName andthen opNames.size() > 0
          then
            @For o in obj.of().allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
              if o.instLevel = obj.level then
                @For name in opNames do
                  if name = o.name.toString() then
                    let
                      opResult = try [o.invoke(obj,{}),null] catch (e) [null, e] end
                    then
                      value = opResult.at(0);
                      error = opResult.at(1);
                      monMin = o.hasProperty("monitorMin");
                      monMax = o.hasProperty("monitorMax")
                    then
                      minVal = if monMin then FmmlxDiagramClient::getOpProp(o, "monitorMin") else null end;
                      maxVal = if monMax then FmmlxDiagramClient::getOpProp(o, "monitorMax") else null end
                    then
                      hasRange = monMin or monMax or error <> null;
                      isInRange = (error = null) andthen
                                  if monMin then minVal <= value else true end andthen
                                  if monMax then maxVal >= value else true end
                    in
                      result := result.append([[
                        o.name.toString(),
                        if error = null then value else error.message.toString() end,
                        hasRange,
                        isInRange]])
                    end
                end end // if contains // for
              end // if level
            end end // if // for
          end
        end;
    	self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getPathAsString(type:Class)
      try type.path() catch(e) Element.path() end
    end

    @Operation getReturnPathAsString(o) //:Operation
      try o.type().path() catch(e) Element.path() end
    end

    @Operation getOwnOperations(requestID : Seq(Integer), className)
        let
          result = []
        in
          @For c in self.package.classes do
            if c <> null andthen c.isKindOf(FMML::MetaClass) andthen c.name.toString() = className
            then
              @For o in c.allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
                let
                  paramNames = o.paramNames();
                  paramTypesRaw = o.paramTypes();
                  paramTypes = []
                in
                  @For type in paramTypesRaw do
                    paramTypes := paramTypes.append([self.getPathAsString(type)])
                  end;
                  result := result.append([[
                  o.name.toString(),
                  paramNames,
                  paramTypes,
                  o.instLevel,
                  self.getReturnPathAsString(o),
                  o.source(),
                  if o.owner.isKindOf(FMML::MetaClass) then self.getMapping(requestID).getMappingId(o.owner) else -1 end,
                  [0,1,false,true], // to-do: multiplicity
                  self.isOperationMonitored(o)
                  ]])
                end
              end end
            end
          end;
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllEnums(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For e in self.package.classes do
    	    if e  <> null andthen e.isKindOf(Enum)
    	    then
    	      let
    	        enumItems = e.getChildren();
    	        itemList = []
    	      in
    	        @For item in enumItems do
    	          itemList := itemList + [item.name.toString()]
    	        end;
    	        result := result.append([[
    	        e.name.toString(),
    	        itemList]])
    	      end
    	    end
    	  end;
    	  // clean up mapping ?
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAuxTypes(requestID : Seq(Integer))
      let
        result = []
      in
        if Root.hasElement("Auxiliary") then
    	  @For ac in Root::Auxiliary.getChildren() do
    	    if
    	      ac.isKindOf(Class)
    	    then
    	      result := result.append([[ac.name.toString()]])
    	    end
    	  end
    	end;
    	self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllIssues(requestID : Seq(Integer))
      let
        result = []
      in
		@For obj in self.package.classes do if obj <> null then
		  @For slot in obj.slots() do
		    if self.package.classes.contains(slot.type.owner) then
		      if slot.type.mult().lowerBound > 0 andthen slot.value = null then
		        result := result + [[
		        "SLOT_NULL",
		        "The slot " + slot.name + " must not be empty.",
		        [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		        ["setSlotValue", self.getMapping(requestID).addOrGetObjectMapping(obj).id, slot.name.toString()]]]
		      end // if null and mandatory
		    end // if slot fmmlx
		  end; // for slots
		  if obj.of().isKindOf(FMML::MetaClass) andthen obj.of().delegatesTo <> null and obj.roleFiller = null
		  then result := result + [[
		    "NO_ROLE_FILLER",
		    "A role filler is required",
		    [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		    ["addRoleFiller",
		      self.getMapping(requestID).addOrGetObjectMapping(obj).id,
		      self.getMapping(requestID).addOrGetObjectMapping(obj.of().delegatesTo).id]]]
		  end;
		  @For assoc in self.package.associations do
		    if FmmlxManipulator::isInstanceOf(obj, assoc.end1.type, assoc.end1.instLevel) // if obj fits sourceDef
		    then
		      let
		        count = FmmlxManipulator::countOccurences(obj, self.package, assoc, true, false) // how many links go out of obj as source
		      in
		        if
		          count < assoc.end2.mult().lowerBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_LOW",
		            "The association " + assoc.name + " requires more links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["addMissingLink", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end;
		        if
		          assoc.end2.mult().hasUpperBound() andthen count > assoc.end2.mult().upperBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_HIGH",
		            "The association " + assoc.name + " requires fewer links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["removeTooManyLinks", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end
		      end // let
		    end; // if instance of
		    if FmmlxManipulator::isInstanceOf(obj, assoc.end2.type, assoc.end2.instLevel) // if obj fits targetDef
		    then
		      let
		        count = FmmlxManipulator::countOccurences(obj, self.package, assoc, false, true)
		      in
		        if
		          count < assoc.end1.mult().lowerBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_LOW",
		            "The association " + assoc.name + " requires more links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["addMissingLink", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end;
		        if
		          assoc.end1.mult().hasUpperBound() andthen count > assoc.end1.mult().upperBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_HIGH",
		            "The association " + assoc.name + " requires fewer links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["removeTooManyLinks", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end
		      end // let
		    end // if instance of
		  end // for assoc
		end end; // for/if obj
    	self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    ///////////////////// Updates to the View ////////////////////

    @Operation sendNewPosition(requestID : Seq(Integer), objectID, x, y)
        self.getMapping(requestID).setNewPosition(objectID, x, y);
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation sendNewPositions(requestID : Seq(Integer), edgeID, listOfpoints)
        self.getMapping(requestID).setNewPositions(edgeID, listOfpoints);
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation storeLabelInfo(requestID : Seq(Integer), edgeID, localID, x, y)
        self.getMapping(requestID).storeLabelInfo(edgeID, localID, x, y);
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), []])
    end

    ////////////////// Class Manipulations ///////////////////

    @Operation addMetaClass(requestID : Seq(Integer), name, level, parents, abstract, x, y)
//        self.log := self.log + "\nE      addMetaClass: " + name + " | " + level + " | " + parents + " | " + abstract;
        let
          m = FmmlxDiagrams::FmmlxManipulator()
        then
          parentsList = self.getParentsList(requestID, parents)
        then
          newClass = m.addMetaClass(self.package, name, level, parentsList, abstract)
        then
          mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newClass)
        in
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y
        end;
        self.log := self.log + [["addMetaClass", ["name",name] , ["level",level+""] , ["parents",self.getParentsPaths(requestID, parents)] , ["abstract",abstract+""]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), []]) // temporary empty result
    end

    @Operation addInstance(
            requestID : Seq(Integer),
            ofName,
            name,
            parents,
            abstract,
            x, y,
            slotValueList: Seq(Seq(String)) )
//      self.log := self.log + "\nE      addInstance: " + ofId + " | " + name + " | " + parents + " | " + abstract;
        try
          let
            m = FmmlxDiagrams::FmmlxManipulator()
          then
            ofClass = if package.hasElement(ofName) then package.getElement(ofName) else null end
            //ofClass = self.getMapping(requestID).getMapping(ofId).object
          then
            parentsList = self.getParentsList(requestID, parents)
          then
            newInstance = m.addInstance(self.package, ofClass, name, parentsList, abstract, slotValueList)
          then
            mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newInstance)
          in
            mappingInfo.lastKnownDiagramX := x;
            mappingInfo.lastKnownDiagramY := y;
            self.log := self.log + [["addInstance", ["of", ofClass.path()] , ["name",name] , ["parents",self.getParentsPaths(requestID, parents)] , ["abstract",abstract+""]]]
          end;
          self.communicator.sendMessageToJava([self.vector2Seq(requestID), []])
        catch (exception)
          self.communicator.sendMessageToJava([self.vector2Seq(requestID), [exception.message]])
        end
    end

    @Operation removeClass(requestID : Seq(Integer), className, strategy)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if package.hasElement(className) then package.getElement(className) else null end
      then
        classPath4Log = class.path()
      in
        m.removeClass(class, strategy);
        self.log := self.log + 	[["removeClass", ["class", classPath4Log]]]
      end;
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result 
    end

    @Operation changeClassName(requestID : Seq(Integer), className, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if package.hasElement(className) then package.getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      in
        m.changeClassName(class, newName)
      end;
      self.log := self.log + [["changeClassName", ["class", class.path()] , ["newName",newName]]];
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation setClassAbstract(requestID : Seq(Integer), className, isAbstract)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if package.hasElement(className) then package.getElement(className) else null end
      in
        self.log := self.log + [["setClassAbstract", ["class", class.path()] , ["abstract",abstract+""]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.changeClassAbstract(class, isAbstract)])
      end
    end

    @Operation levelRaiseAll(requestID : Seq(Integer), amount)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        self.log := self.log + [["levelRaiseAll"]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.levelRaiseAll(self.package, amount)])
      end
    end

    @Operation changeParent(requestID : Seq(Integer), className, oldList, newList)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        oldSet = self.vector2Seq(oldList).asSet();
        newSet = self.vector2Seq(newList).asSet();
        problems = [];
        class = if package.hasElement(className) then package.getElement(className) else null end
      then
        addSet = newSet - oldSet;
        removeSet = oldSet - newSet
      in
//        if
//          removeSet = {}
//        then
          @For parentId in addSet do
            let
              parentToBeAdded = self.getMapping(requestID).getMapping(parentId).object
            in
              problems := problems + m.addParent(class, parentToBeAdded)
            end
          end
;//        elseif
//          addSet = {}
//        then
          @For parentId in removeSet do
            let
              parentToBeRemoved = self.getMapping(requestID).getMapping(parentId).object
            in
              problems := problems + m.removeParent(class, parentToBeRemoved)
            end
          end
;//        elseif
//          removeSet.size() = 1 and addSet.size() = 1 // move exactly one parent
//        then
//          let
//            parentToBeAdded = self.getMapping(requestID).getMapping(addSet.asSeq().at(0)).object;
//            parentToBeRemoved = self.getMapping(requestID).getMapping(removeSet.asSeq().at(0)).object
//          in
//            problems := problems + m.moveParent(class, parentToBeRemoved, parentToBeAdded)
//          end
//        else
//          problems := problems + ["Only one parent may be moved at a time."]
//        end;
        self.log := self.log + [["changeParent" , ["old",self.getParentsPaths(requestID, oldList)], ["new",self.getParentsPaths(requestID, newList)]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    //////////////////////// Attribute Manipulations /////////////////////

    @Operation addAttribute(requestID : Seq(Integer), className, name, level, typeName, multiplicityV)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if package.hasElement(className) then package.getElement(className) else null end;
//        class = self.getMapping(requestID).getMapping(classId).object;
        type = m.getTypeForName(typeName, self.package);
        multiplicity = m.valueList2Multiplicity(self.vector2Seq(multiplicityV))
      then
        problems = if class <> null then m.checkAddAttribute(class, name, level, typeName) else ["Class not found"] end
      in
        if
          problems.isEmpty()
        then
          problems := try
            m.addAttribute(class, name, level, type, multiplicity); null
          catch(e)
            [("addAttribute failed during transaction: " + e.message)]
          end // try
        end; // if
        self.log := self.log + [["addAttribute",
                                            ["class", class.path()],
                                            ["name", name],
                                            ["level", level+""],
                                            ["type", type.path()],
                                            ["multiplicity", multiplicity+""]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end // in
    end

    @Operation changeAttributeName(requestID : Seq(Integer), className, oldName, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
          then
		class = if package.hasElement(className) then package.getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeAttributeName(class, oldName, newName) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeAttributeName(class, oldName, newName);
          self.log := self.log + [["changeAttributeName", ["class", class.path()] , ["oldName", oldName] , ["newName", newName]]]
          end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeLevel(requestID : Seq(Integer), className, attName, oldLevel, newLevel)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if package.hasElement(className) then package.getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel) else ["Class not found"] end
        //problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
      in
        if problems.isEmpty() then
          m.changeAttributeLevel(class, attName, oldLevel, newLevel);
          self.log := self.log + [["changeAttributeLevel", ["class", class.path()] , ["name", attName] , ["oldLevel", oldLevel+""] , ["newLevel", newLevel+""]]]
          end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeType(requestID : Seq(Integer), className, attName, oldTypeName, newTypeName)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
          class = if package.hasElement(className) then package.getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        problems = if class <> null then m.checkChangeAttributeType(class, attName, oldTypeName, newTypeName, self.package) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeAttributeType(class, attName, oldTypeName, newTypeName, self.package);
          self.log := self.log + [["changeAttributeType", ["class", class.path()] , ["name", attName] , ["oldType", oldTypeName] , ["newType", newTypeName]]]
          end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeMultiplicity(requestID : Seq(Integer), className, attName, oldMul, newMul)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if package.hasElement(className) then package.getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(newMul))
      then    // TODO !!!
//          problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
         problems = []
         
      in
        if problems.isEmpty() then
          m.changeAttributeMultiplicity(class, attName, null, newMult);
          self.log := self.log + [["changeAttributeMultiplicity", ["class", class.path()] , ["name", attName] , ["oldMul", oldMul+""] , ["newMul", newMul+""]]]
          end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation removeAttribute(requestID : Seq(Integer), className, attName, strategy)
     // for now: ignore strategy and simply delete
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if package.hasElement(className) then package.getElement(className) else null end
      in
        m.removeAttribute(class, attName, strategy)
      end;
      self.log := self.log + [["removeAttribute", ["class", class.path()], ["name", attName]]];
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result
    end

    //////////////////////// Slot Manipulations /////////////////////

    @Operation changeSlotValue(requestID : Seq(Integer), className, slotName, valueToBeParsed)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        obj = if package.hasElement(className) then package.getElement(className) else null end;
        error = null
//      then
//        class = obj.of()
      then
//        atts = class.allAttributesForLevel(obj.level);
        foundAtt = m.findAttributeForSlot(obj, slotName)
      in
//        @For att in atts do
//          if att.name.toString() = slotName.toString() then
//            foundAtt := att
//          end
//        end;
        if
          foundAtt <> null
        then
          let
            parseResult = m.evalString(valueToBeParsed, self.package)
          in
            if parseResult.at(1) = null then
              error := m.changeSlotValue(obj, slotName, parseResult.at(0), foundAtt.type, self.package)
            else
              error := parseResult.at(1) // error as message or as return value? maybe try exceptions...
            end
          end

        else
          error := "no Slot Found"
        end;
		self.log := self.log + [["changeSlotValue",
                                            ["obj", obj.path()],
                                            ["slotName", slotName],
                                            ["valueToBeParsed", valueToBeParsed]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), if error = null then null else [error] end]) // temporary empty result
      end
    end

    //////////////// Local Operations ///////////////////

    @Operation vector2Seq(vec) // for local use
      let list = [] in
        @For id in vec do
          list := list.append([id])
        end; // for
        list
      end// let
    end

    @Operation getParentsList(requestID, parentIds) // for local use
      let list = [] in
        @For id in parentIds do
          if not id = -1 then list := list.append([self.getMapping(requestID).getMapping(id).object]) end
        end; // for
        list
      end// let
    end

    @Operation getParentsPaths(requestID, parentIds) // for local use
      let list = "" in
        @For id in parentIds do
          if not id = -1 then list := list + self.getMapping(requestID).getMapping(id).object.path() + "," end
        end; // for
        list
      end// let
    end

    @Operation getParentIdList(requestID, c : FMML::MetaClass) // for local use
      let list = [] in
        @For p in c.parents do
          if p.isKindOf(FMML::MetaClass) then list := list.append([self.getMapping(requestID).addOrGetObjectMapping(p).id]) end
        end; // for
        list
      end// let
    end

    @Operation isOperationMonitored(o)
      if o.hasProperty("monitor") then FmmlxDiagramClient::getOpProp(o, "monitor") else false end
    end

    ////////////////// Operations for editing associations ///////////////////

  @Operation addAssociation(requestID : Seq(Integer),
      class1Name : String,
      class2Name : String,
      accessSourceFromTargetName : String,
      accessTargetFromSourceName : String,
      fwName : String,
      reverseName : String,
      mult1S : String,
      mult2S : String,
      instLevel1 : Integer,
      instLevel2 : Integer,
      sourceVisibleFromTarget : Boolean,
      targetVisibleFromSource : Boolean,
	  isSymmetric : Boolean,
	  isTransitive : Boolean):XCore::Element


  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    class1 = if package.hasElement(class1Name) then package.getElement(class1Name) else null end;
        class2 = if package.hasElement(class2Name) then package.getElement(class2Name) else null end
  	  then
        mult1 = m.valueList2Multiplicity(self.vector2Seq(mult1S));
        mult2 = m.valueList2Multiplicity(self.vector2Seq(mult2S))
      then
        problems = [] /*m.checkAddAssociation(self.package,
  	      class1, class2,
  	      accessSourceFromTargetName, accessTargetFromSourceName,
  	      fwName, reverseName,
  	      mult1, mult2,
  	      instLevel1, instLevel2) */
      in
        if problems.isEmpty() then
  	      problems := m.addAssociation(self.package,
  	        class1, class2,
  	        accessSourceFromTargetName, accessTargetFromSourceName,
  	        fwName, reverseName,
  	        mult1, mult2,
  	        instLevel1, instLevel2,
  	        sourceVisibleFromTarget, targetVisibleFromSource,
  	        isSymmetric, isTransitive);
          self.log := self.log + [["addAssociation",
            ["class1", class1.path()] ,["class2", class2.path()] ,
            ["accessSourceFromTargetName", accessSourceFromTargetName] , ["accessTargetFromSourceName", accessTargetFromSourceName] ,
            ["fwName", fwName],
            ["mult1", mult1+""] , ["mult2", mult2+""] ,
            ["instLevel1", instLevel1+""] , ["instLevel2", instLevel2+""] ,
            ["sourceVisibleFromTarget", sourceVisibleFromTarget] , ["targetVisibleFromSource", targetVisibleFromSource] ,
            ["isSymmetric", isSymmetric+""] , ["isTransitive", isTransitive+""]]]
   	    end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
  	end

    @Operation removeAssociation(
      requestID  : Seq(Integer),
      assocId    : Integer)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = self.getMapping(requestID).getMapping(assocId).object
      then
        problems = m.removeAssociation(assoc)
      in
        self.log := self.log + [["removeAssociation", ["name", assoc.name]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation setAssociationEndVisibility(
      requestID      : Seq(Integer),
      assocID        : Integer,
      concernsTarget : Boolean,
      newVisibility  : Boolean)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = self.getMapping(requestID).getMapping(assocID).object
      then
        problems = m.setAssociationEndVisibility(assoc, concernsTarget, newVisibility)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAssociationForwardName(
      requestID  : Seq(Integer),
      assocId    : Integer,
      newName    : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = self.getMapping(requestID).getMapping(assocId).object
      then
        oldName = assoc.name
      then
        problems = m.changeAssociationForwardName(assoc, newName)
      in
        self.log := self.log + [["changeAssociationForwardName", ["newName", newName], ["oldName", oldName]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

   @Operation changeAssociationEnd2StartMultiplicity(requestID : Seq(Integer), associationID, multV)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = self.getMapping(requestID).getMapping(associationID).object
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      in 
        self.log := self.log + [["changeAssociationEnd2StartMultiplicity", ["name", a.name], ["mult", newMult+""]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.changeAssociationMultiplicity(a, newMult, null)])
      end
    end

    @Operation changeAssociationStart2EndMultiplicity(requestID : Seq(Integer), associationID, multV)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = self.getMapping(requestID).getMapping(associationID).object
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      in 
        self.log := self.log + [["changeAssociationStart2EndMultiplicity", ["name", a.name], ["mult", newMult+""]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.changeAssociationMultiplicity(a, null, newMult)])
      end
    end

    //////////////////////////////////////////////////////////

  	@Operation addAssociationInstance(requestID : Seq(Integer),
      obj1Name  : String,
      obj2Name  : String,
      assocId : Integer)

  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    obj1 = if package.hasElement(obj1Name) then package.getElement(obj1Name) else null end;
  	    obj2 = if package.hasElement(obj2Name) then package.getElement(obj2Name) else null end;
  	    association = self.getMapping(requestID).getMapping(assocId).object
  	  then
        problems = m.addAssociationInstance(self.package, obj1, obj2, association)
  	  in
  	    self.log := self.log + [["addLink", ["association", association.name], ["obj1", obj1.path()], ["obj2", obj2.path()]]];
  	    self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
  	  end
    end

    @Operation removeAssociationInstance(
      requestID   : Seq(Integer),
      assocInstId    : Integer)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assocInstSeq = self.getMapping(requestID).getMapping(assocInstId).object
      then
        problems = m.removeAssociationInstance(assocInstSeq)
      in
  	    self.log := self.log + [["removeLink", ["todo", "don't use id here"]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    ////////////////// Operations for delegation ///////////////////////////


    @Operation addDelegation(
      requestID   : Seq(Integer),
      delegateFromName  : String,
      delegateToName    : String)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        delegateFrom = if package.hasElement(delegateFromName) then package.getElement(delegateFromName) else null end;
        delegateTo = if package.hasElement(delegateToName) then package.getElement(delegateToName) else null end
      then
        problems = m.addDelegation(delegateFrom, delegateTo)
      in
        self.log := self.log + [["addDelegation", ["delegateFrom",  delegateFrom.path()],  ["delegateTo",  delegateTo.path()]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation setRoleFiller(
      requestID   : Seq(Integer),
      roleName  : String,
      roleFillerName    : String)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        role = if package.hasElement(roleName) then package.getElement(roleName) else null end;
        roleFiller = if package.hasElement(roleFillerName) then package.getElement(roleFillerName) else null end
      then
        problems = m.setRoleFiller(role, roleFiller)
      in
        self.log := self.log + [["setRoleFiller", ["role", role.path()], ["roleFiller", roleFiller.path()]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    ////////////////// Operations for editing operations ///////////////////

    @Operation changeOperationName(requestID : Seq(Integer), className, oldName, newName)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if package.hasElement(className) then package.getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        problems = if class <> null then m.checkChangeOperationName(class, oldName, newName) else ["Class not found"] end
        //problems = m.checkChangeOperationName(class, oldName, newName)
      in
        if problems.isEmpty() then
          m.changeOperationName(class, oldName, newName);
          self.log := self.log + [["changeOperationName", ["oldName", oldName] , ["newName", newName] , ["class", class.path()]]]
          end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeOperationLevel(requestID : Seq(Integer), className, name, oldLevel, newLevel)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if package.hasElement(className) then package.getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        o = m.findOperation(class,name)
      then
        problems = if class <> null then m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o)) else ["Class not found"] end
        //problems = m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o))
      in
        self.protocol := self.protocol + [["changeOperationLevel", ["newLevel", newLevel+""] , ["name", name] , ["class", class.path()]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation addOperation(
      requestID  : Seq(Integer), 
      classId    : Integer,
      opName     : String, 
      level      : Integer, 
      returnType : String,
      body       : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then 
        type = m.getTypeForName(returnType, self.package);
        problems = m.addOperation(class, opName, level, type, body)
      in
        self.log := self.log + [["addOperation", 
        ["class", class.path()],        
        ["opName", opName],        
        ["level", level+""],        
        ["returnType", returnType.path()],
        ["body", body]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation addOperation2(
      requestID  : Seq(Integer), 
      className  : String,
      level      : Integer, 
      body       : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if package.hasElement(className) then package.getElement(className) else null end
      then 
        problems = if class <> null then m.addOperation2(class, level, body) else ["Class not found"] end
      in
        self.log := self.log + [["addOperation2", 
        ["class", class.path()],        
        ["level", level+""],        
        ["body", body]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation removeOperation(
      requestID  : Seq(Integer), 
      className    : String,
      opName     : String)
      
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        //class = self.getMapping(requestID).getMapping(classId).object
        class = if package.hasElement(className) then package.getElement(className) else null end
      then 
        //problems = m.removeOperation(class, opName)
        problems = if class<>null then m.removeOperation(class, opName) else ["Class not found"] end
      in
        self.log := self.log + [["removeOperation", ["class", class.path()], ["opName", opName]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end
    
    @Operation getOpProp(operation, name) // for local use
      let
        properties = operation.properties();
        tagFound = null
      in 
        @For property in properties do  
          if property->head() = name
            then tagFound := property->tail()
          end
        end;
        tagFound
      end      
    end
    
    @Operation changeOperationOwner(requestID : Seq(Integer), className_old, name, className_new)
      
      let 
        m = FmmlxDiagrams::FmmlxManipulator();
        oldOwner = if package.hasElement(className_old) then package.getElement(className_old) else null end;
        newOwner = if package.hasElement(className_new) then package.getElement(className_new) else null end
      then
        operation = oldOwner.getOperation(name)
      in
        self.log := self.log + [["changeOperationOwner", ["todo", "don't use id here"]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), m.changeOperationOwner(oldOwner, operation, newOwner)])
      end      
    end
          
    @Operation checkOperationNameLegal(op, name):Boolean // todo: check for duplicates, consider arity
      let nameSymbol = Symbol(name) in
        if nameSymbol = op.name()
        then
          true
        else
          op.legalNameChangeCheck(nameSymbol,op.name())
        end
      end
    end
        
    @Operation changeOperationBody(requestID : Seq(Integer), classId:Integer, oldName:String, body:String)
      
      let 
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object;
        problems = []
      then
        op = class.getOperation(oldName)
      then
        newName = body.splitBy("()[]",0,0)->head.subst("","@Operation ",false)
      in
        if oldName.toString() <> newName.toString() then 
          problems := ["name change not allowed here"]
        elseif
          op = null then 
          problems := ["operation not found"]
        else // let the manipulator try
          problems := m.changeOperationBody(class, op, newName, body)
        end;
        self.log := self.log + [["changeOperationBody", ["todo", "don't use id here"]]];
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    // Not yet implemented
    
    @Operation respondNotYetImplemented(name: String, requestID : Seq(Integer))
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), ["The feature \"" + name + "\" is temporarily unavailable. Please try again later."]])
    end
      
    @Operation changeAssociationStart2EndAccessName(requestID : Seq(Integer), associationID, name) 
      self.respondNotYetImplemented("changeAssociationStart2EndAccessName", self.vector2Seq(requestID))
    end
      
    @Operation changeAssociationEnd2StartAccessName(requestID : Seq(Integer), associationID, name) 
      self.respondNotYetImplemented("changeAssociationEnd2StartAccessName", self.vector2Seq(requestID))
    end
      
    @Operation changeAssociationStart2EndLevel(requestID : Seq(Integer), associationID, level) 
      self.respondNotYetImplemented("changeAssociationStart2EndLevel", self.vector2Seq(requestID))
    end
      
    @Operation changeAssociationEnd2StartLevel(requestID : Seq(Integer), associationID,level) 
      self.respondNotYetImplemented("changeAssociationEnd2StartLevel", self.vector2Seq(requestID))
    end
      
    @Operation updateAssociationInstance(requestID : Seq(Integer), id1, id2) 
      self.respondNotYetImplemented("updateAssociationInstance", self.vector2Seq(requestID))
    end

    @Operation changeAssociationTarget(inA : Seq(Integer), idT_o, idT_n) 
      self.respondNotYetImplemented("changeAssociationTarget", self.vector2Seq(requestID))
    end
      
    @Operation changeAssociationSource(inA : Seq(Integer), idS_o, idS_n) 
      self.respondNotYetImplemented("changeAssociationSource", self.vector2Seq(requestID))
    end
      
    @Operation checkOperationBody(requestID : Seq(Integer), operationBodyToBeChecked) 
      self.respondNotYetImplemented("checkOperationBody", self.vector2Seq(requestID))
    end
      
    @Operation changeOperationType(requestID : Seq(Integer), className, opName, newType)
      self.respondNotYetImplemented("changeOperationType", self.vector2Seq(requestID))
    end
      
    @Operation changeAttributeOwner(requestID : Seq(Integer), idO_old, name, idO_new) 
      self.respondNotYetImplemented("changeAttributeOwner", self.vector2Seq(requestID))
    end
      
    @Operation changeOf(requestID : Seq(Integer), idO, idC_old, idC_new) 
      self.respondNotYetImplemented("changeOf", self.vector2Seq(requestID))
    end
      
    @Operation changeClassLevel(requestID : Seq(Integer), idO, newLevel) 
      self.respondNotYetImplemented("changeClassLevel", self.vector2Seq(requestID))
    end   
       
    @Operation addEnumeration(requestID : Seq(Integer), newEnumName:String)
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumeration(self.package, newEnumName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeEnumerationName(requestID : Seq(Integer), oldEnumName:String, newEnumName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationName(self.package, oldEnumName, newEnumName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation removeEnumeration(requestID : Seq(Integer), enumName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumeration(self.package, enumName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation addEnumerationValue(requestID : Seq(Integer), enumName:String, newEnumValueName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumerationValue(self.package, enumName, newEnumValueName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation changeEnumerationValueName(requestID : Seq(Integer), enumName:String, oldEnumValueName:String, newEnumValueName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationValueName(self.package, enumName, oldEnumValueName, newEnumValueName)
      in
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation removeEnumerationValue(requestID : Seq(Integer), enumName:String, enumValueName:String) 
      let 
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumerationValue(self.package, enumName, enumValueName)
      in
        ("removeEnumerationValue problems: " + problems).println();
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end
    
    @Operation printProtocol(requestID : Seq(Integer)) // to be removed
      self.log.println()
    end
    
    @Operation printLog(requestID : Seq(Integer))
      self.log.println()
    end
    
    @Operation assignToGlobal(requestID : Seq(Integer), objID:Integer, varName:String)
      let 
        class = self.getMapping(requestID).getMapping(objID).object
      in
        if 
          class <> null
        then
          class.assignToGlobal(varName)
        end;
        []
      end
    end
        
    @Operation showBody(requestID : Seq(Integer), objID:Integer, opName:String, arity:Integer)
      let 
        class = self.getMapping(requestID).getMapping(objID).object
      in
        if 
          class <> null andthen class.getOperation(opName) <> null
        then
          class.getOperation(opName).edit()
        end;
        []
      end
    end

    @Operation loadProjectFromXml(requestID : Seq(Integer), name : String)
        (name).println();

            let package : XCore::Element = XCore::Package(name)
        	in
        	let project : XCore::Element = Projects::Project(package,"",null)
        		in
        		Root.add(package);
        			//self.add(project);
                    xmf.projectManager("MyProjects").add(project);
        			if Root.hasElement("FMML")
        			then
        				package.addParent(FMML);
        				package.removeParent(Object)
        			end
        		end
        	end
        	[]
        end
    
    @Operation updateAll(obj:Element)
      let 
        clients = Clients::FmmlxDiagrams::FmmlxDiagramClient.allInstances()->select(a | a.package = obj.owner)
      in
        @For client in clients do 
          client.communicator.triggerUpdate()
        end
      end
    end
    
    @Operation evalList(requestID : Seq(Integer), text)
      ("eval List start: " + text).println();
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        result = [];
        error = [];
        parseResult = m.evalString(text, self.package)
      in
        if 
          parseResult.at(1) = null 
        then
          parseResult.at(0).println();
          if
            parseResult.at(0).isKindOf(Seq(Element))
          then
            @For element in parseResult.at(0) do
              result := result + [element.toString()]
            end
          else
            result:=["The expression " + text + " does not evaluate to a list."]
          end
        else
          parseResult.at(1).println();
          result:=[parseResult.at(1)]
        end;
        "eval List done".println();
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
        
    @Operation addDefaultEnums(p:Package)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        if not p.hasElement("Level") then
          m.addEnumeration(p, "Level");
          m.addEnumerationValue(p, "Level", "High");
          m.addEnumerationValue(p, "Level", "Medium");
          m.addEnumerationValue(p, "Level", "Low") end;
        if not p.hasElement("Gender") then
          m.addEnumeration(p, "Gender");
          m.addEnumerationValue(p, "Gender", "Male");
          m.addEnumerationValue(p, "Gender", "Female");
          m.addEnumerationValue(p, "Gender", "Unspecified") end;
        if not p.hasElement("LegalForm") then
          m.addEnumeration(p, "LegalForm");
          m.addEnumerationValue(p, "LegalForm", "Private_Limited_Partnership");
          m.addEnumerationValue(p, "LegalForm", "Limited_Liability");
          m.addEnumerationValue(p, "LegalForm", "Corporation");
          m.addEnumerationValue(p, "LegalForm", "Non_Profit") end;
        if not p.hasElement("Unit") then
          m.addEnumeration(p, "Unit");
          m.addEnumerationValue(p, "Unit", "piece");
          m.addEnumerationValue(p, "Unit", "kg");
          m.addEnumerationValue(p, "Unit", "litre");
          m.addEnumerationValue(p, "Unit", "gr");
          m.addEnumerationValue(p, "Unit", "meter");
          m.addEnumerationValue(p, "Unit", "km");
          m.addEnumerationValue(p, "Unit", "qm");
          m.addEnumerationValue(p, "Unit", "crate") end
      end
    end

    @Operation getDiagramData(requestID : Seq(Integer))
        //let 
        //  result = [log] 
        //in
    	  self.communicator.sendMessageToJava([self.vector2Seq(requestID), if log.size() = 0 then ["log"] else ["log"] + log end])
        //end
    end
    
    @Operation findOperationImplementation(requestID: Seq(Integer), opNames: Seq(String), model:String, arity:String, returnType:String)
      let
        result = [];
        allClasses = Class.allInstances();
        opName = self.vector2Seq(opNames).at(0)
      in
        @For class in allClasses do
          @For op in class.operations do
            if op.name.toString() = opName.toString() then
              let paramTypes = [] in 
                @For pt in op.paramTypes() do paramTypes := paramTypes + [pt.path()] end;
                result := result + [[
                  class.path(),
                  class.name.toString(),
                  op.arity,
                  op.paramNames(),
                  paramTypes,
                  op.type.path(),
                  op.codeBox.source()]]
              end
            end
          end
        end;
        self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation findOperationUsage(requestID: Seq(Integer), opName: String, usage:String)
    
    let
      result = [];
      n = 0;
      StringCheck = xmf.javaClass("tool.helper.StringCheck")
    then
      stringCheck = StringCheck()
    in
      @For class in Classifier.allInstances() do
        @For op in class.operations do
          n := n+1;
//          if n.mod(100) = 0 then (n + " Checking "+op.name+"...").println() end;
          if stringCheck.contains(op.codeBox.source(), opName) then 
            result := result + [[
              class.path(),
              class.name.toString(),
              op.arity,
              op.paramNames(),
              null,
              op.type.path(),
              op.codeBox.source()]]
          end
        end
      end;     
      
      self.communicator.sendMessageToJava([self.vector2Seq(requestID), result])
    end
    
    
    
    
    
    
    
    end

end
