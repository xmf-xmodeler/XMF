parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxDiagramClient extends Client

    @Attribute communicator : Element end
    @Attribute log : Seq(Element) = [] end
    @Attribute diagrams : Table = Table(10) end
    
    @Constructor(name)
      ("invoking FmmlxDiagramClient: " +  name).println();
//      self.setCommandInterpreter(DiagramCommandInterpreter());
//      self.setEventHandler(DiagramEventHandler())
        null
    end
    
    /* This operation returns an instance of 
      the java class "FmmlxDiagramCommunicator",
    For the only instance of FmmlxDiagramClient,
      there is only one instance of the communicator, 
      which is created once, if not yet present.
    */
    @Operation getCommunicator()
      if self.communicator = null then
        let
          FmmlxDiagramCommunicator = xmf.javaClass("tool.clients.fmmlxdiagrams.FmmlxDiagramCommunicator");
          handle = xmf.getHandle(self)
        in
          self.communicator := FmmlxDiagramCommunicator();
          self.communicator.setHandle(handle)
        end
      end;
      self.communicator
    end

    /* this (3) operation(s) is invoked when "show in diagram" 
       in the menu of the package is invoked.
       
       It allows the user to pick an existing one or to create a new one. */
       
    @Operation showDiagram(package,name)
      let 
        key = self.findDiagram(package,name)
      in
        self.showDiagramInView(key)
      end
    end
    
    @Operation showDiagramInView(key)
      if 
        key <> null
      then
        self.getCommunicator().newDiagram( // <-- from the java's point of view a NEW diagram is created
          key, 
          self.diagrams.get(key).diagramName.toString(), 
          self.diagrams.get(key).package.path(),
          self.diagrams.get(key).file.toString())
      end
    end    
    
    @Operation findDiagram(package,name)    
      let
        selectedNames = xmf.selects("Select Diagram",
          "select existing diagram - or none for new", 
          diagrams.values().diagramName,
          {},
          null)
      in
        if selectedNames = -1 then selectedNames := [] end;
        if
          selectedNames.size() = 0
        then
          self.createNewDiagram(package,name, "") // <-- create a new diagram
        elseif
          selectedNames.size() = 1
        then // if one name supplied: find it!
          let
            selectedName = selectedNames.at(0);
            keys = self.diagrams.keys();
            key = null;
            keyCount = 0
          in
            @While key = null and keyCount < keys.size() do
              if diagrams.get(keys.at(keyCount)).diagramName.toString() = selectedName.toString() then key := keys.at(keyCount) end;
              keyCount := keyCount + 1
            end;
            if key <> null then // <-- found an old diagram with that name
              //self.communicator.reopenDiagram(key, selectedName.toString(), diagrams.get(key).package.path())
              key
              //self.communicator.newDiagram(key, diagrams.get(key).diagramName.toString(), diagrams.get(key).package.path()) // <-- from the java's point of view a NEW diagram is created
            else
              null
              //"diagram not found".println()
            end
          end
        end
      end
    end

    @Operation createDiagramFromJava(packagePath, diagramName, file)
      let
  	    m = FmmlxDiagrams::FmmlxManipulator()
      then
        package = m.evalString(packagePath, Root).at(0)
      then
        newID = self.createNewDiagram(package,diagramName, file)
      in
        self.communicator.setNewDiagramId(newID)
      end      
    end

    /* This Operation creates a new diagram, 
       and returns its key!!! ... */
    @Operation createNewDiagram(package,name, file)
      //null.foo;
      //self.package := package;
       ///////////FIND ALTERNATIVE TO THIS///////////////////
      if
        package.of() <> FMML::FMMLxPackage
      then
        package.setOf(FMML::FMMLxPackage);
        Kernel_addAtt(package,"fmmlxAssociationInstances",{})
      end;
        //self.addDefaultEnums(package);
      //////////////////////////////////////////////////////
        
      let 
        handle = xmf.getHandle(self);
        diagram = FmmlxDiagram();
        newID = 0
      in
        @While diagrams.hasKey(newID) do newID := newID + 1 end;
          diagram.diagramName := ("Diagram " + package.name + " (id " + newID + ")");
        diagram.package := package;
        diagram.file := file;
        self.diagrams.put(newID, diagram);
        
        //diagram
        newID
      end
    end
    
    @Operation closeDiagram(requestID, diagramHandler : Integer) 
      ("yet unimplemented method for closing diagram " + diagramHandler).println()
    end
    
    // This operation is invoked by the java side while the window is closing
    @Operation removeDiagram(requestID, diagramHandler : Integer) 
      let
        diagramID = self.vector2Seq(requestID).at(0)
      in
        self.diagrams.remove(diagramID)
      end
    end

    @Operation getMapping(requestID : Seq(Integer))
      self.diagrams.get(self.vector2Seq(requestID).at(0)).mapping
    end
    
    @Operation getPackage(requestID : Seq(Integer))
      self.diagrams.get(self.vector2Seq(requestID).at(0)).package
    end

    //////////////////////// Queries ///////////////////////////////
    
    @Operation getAllObjectPositions(requestID : Seq(Integer), diagramID)
      let 
        result = [];
        diagram = self.diagrams.get(diagramID)
      then
        package = diagram.package;
        mapping = diagram.mapping
      in
        @For c in package.classes do
          let
    	    mappingInfo = mapping.addOrGetObjectMapping(c)	        
    	  in
    	    result := result.append([[
			  c.path(), // ownPath
    	      mappingInfo.lastKnownDiagramX,
    	      mappingInfo.lastKnownDiagramY,
			  mappingInfo.hidden,
			  diagram.toString()
			  ]])
	      end
	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllEdgePositions(requestID : Seq(Integer), diagramID)
      let 
        result = [];
        diagram = self.diagrams.get(diagramID)
      then
        package = diagram.package;
        mapping = diagram.mapping
      in
        @For mappingItem in mapping.mapping do
          let
    	    obj = mappingItem.object
    	  then
    	    key = if obj.isKindOf(Associations::Association) then obj.name else obj end
    	  in
    	    result := result.append([[
              key.toString(),
              mappingItem.points]])
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllLabelPositions(requestID : Seq(Integer), diagramID)
      self.getCommunicator()
          .sendMessageToJava([self.vector2Seq(requestID), 
               self
                  .diagrams
                  .get(diagramID)
                  .mapping
                  .labelMapping
                  .asSeq()])
    end

    @Operation getAllObjects(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For c in self.getPackage(requestID).classes do
    	    if c <> null andthen c.isKindOf(FMML::MetaClass) // TODO: find out how a null can possibly end up there
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(c)	        
    	      in
    	        result := result.append([[
    	        -1, //mappingInfo.id, // 0: id*
    	        c.name.toString(), // 1: name
    	        c.level, // level  // 2: level
    	        -1, //if c.of().isKindOf(FMML::MetaClass) then self.getMapping(requestID).addOrGetObjectMapping(c.of()).id else -1 end,// 3: of-ID
    	        -1, // self.getParentIdList(requestID, c),//[],// 4: parents-ID
    	        c.isAbstract, // 5
    	        mappingInfo.lastKnownDiagramX, // 6
    	        mappingInfo.lastKnownDiagramY, // 7
    	        mappingInfo.hidden, // 8: visibility in this diagram
    	        -1, // 9: reserved for delegation
    	        c.path(), // 10: ownPath
    	        c.of().path(), // 11: ofPath
    	        self.getParentsPathsList(requestID, c)// 12: parentsPaths
    	        ]])
    	      end
    	    else
    	      result := result + [[
    	      -2, // fake
    	      c.name.toString(),
    	      -1, // non-intrinsic
    	      -2, [],
    	      c.isAbstract,
    	      0,0,false,0,
              c.path(), // 10: ownPath
              c.of().path(), // 11: ofPath
              self.getParentsPathsList(requestID, c)// 12: parentsPaths
    	      ]]
    	    end
    	  end;
    	  // clean up mapping ?
    	  if requestID <> -3 then self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result]) end
        end
    end

    @Operation getAllDelegationEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object <> null andthen object.delegatesTo <> null then
            if object.delegatesTo.isKindOf(FMML::MetaClass) then
              let
                //delegatesFromPath = self.getMapping(requestID).addOrGetObjectMapping(object).object.path();
                //delegatesToPath = self.getMapping(requestID).addOrGetObjectMapping(object.delegatesTo).object.path();
                //delegatesToLevel = self.getMapping(requestID).addOrGetObjectMapping(object.delegatesToLevel).object.path()
                delegatesFromPath = object.path();
                delegatesToPath = object.delegatesTo.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createDelegationKey(delegatesFromPath, delegatesToPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            delegatesFromPath, // 1 start Path
  	            delegatesToPath, // 2 end Path
  	            object.delegatesToLevel, // 3 level
  	            mappingInfo.points // 4 points
  	          ]])
              end
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllRoleFillerEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object <> null then if object.roleFiller <> null then
            if object.roleFiller.isKindOf(FMML::MetaClass) then
              let
                childPath = self.getMapping(requestID).addOrGetObjectMapping(object).object.path();
                parentPath = self.getMapping(requestID).addOrGetObjectMapping(object.roleFiller).object.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createRoleKey(childPath, parentPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            childPath, // 1 start ID
  	            parentPath, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllInheritanceEdges(requestID : Seq(Integer))
      let
        result = []
      in
        @For object in self.getPackage(requestID).classes do
          if object <> null then @For parent in object.parents do
            if parent.isKindOf(FMML::MetaClass) then
              let
                childPath = self.getMapping(requestID).addOrGetObjectMapping(object).object.path();
                parentPath = self.getMapping(requestID).addOrGetObjectMapping(parent).object.path()
              then
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createInheritanceKey(childPath, parentPath))
              in
                result := result.append([[
  	            mappingInfo.id.toString(), // 0 ID
  	            childPath, // 1 start ID
  	            parentPath, // 2 end ID
  	            mappingInfo.points // 3 points
  	          ]])
              end
            end end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllAssociations(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For a in self.getPackage(requestID).associations do
    	    if a.isKindOf(Associations::Association)
    	    then
    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(a)
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          a.end1.type.path(), // 1 source ID
    	          a.end2.type.path(), // 2 target ID
    	          -1, // 3 parent ID
    	          mappingInfo.points, // 4 points
    	          a.name.toString(), // 5 name 1
    	          null, // 6 name 2
    	          a.end2.name.toString(), // 7 name start->end slot name
    	          a.end1.name.toString(), // 8 name end->start slot name
    	          a.end2.instLevel, // 9 level of source
    	          a.end1.instLevel, // 10 level of target
    	          FmmlxManipulator::multiplicity2ValueList(a.end2.mult()), // 11 mul s->t
    	          FmmlxManipulator::multiplicity2ValueList(a.end1.mult()),  // 12 mul t->s
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id), // 13 labels
    	          a.end1.visible, // 14 visibility t->s
    	          a.end2.visible, // 15 visibility s->t
    	          a.symmetric, // 16
    	          a.transitive // 17
    	        ]])
    	      end // let
    	    else ("a is of " + a.of()).println()
    	    end // if
    	  end;
    	  // clean up mapping ?
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAssociationInstances(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For i in (if self.getPackage(requestID).fmmlxAssociationInstances = null then {} else self.getPackage(requestID).fmmlxAssociationInstances end) do

    	      let
    	        mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(FmmlxDiagramMapping::createAssociationLinkKey(i.at(0).path(), i.at(1).path(), i.at(2).path()))
    	      in
    	        result := result.append([[
    	          mappingInfo.id, // 0 ID
    	          i.at(0).path(), // 1 start ID
    	          i.at(1).path(), // 2 end ID
    	          i.at(2).path(), // 3 assoc ID
    	          mappingInfo.points, // 4 points
    	          self.getMapping(requestID).getAllLabels(mappingInfo.id) // 5 labels
    	        ]])
    	      end // let
    	  end;
    	  // clean up mapping ?
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    /*@Operation getOwnAttributes(requestID : Seq(Integer), className)
        let
          result = []
        in
          @For c in self.getPackage(requestID).classes do
            if c <> null andthen c.isKindOf(FMML::MetaClass) andthen c.name.toString() = className then
              @For a in c.attributes do
                result := result.append([[a.name.toString(), a.type.name.toString(), a.instLevel, a.mult()]])
              end
            elseif c <> null andthen c.name.toString() = className then
              @For a in c.attributes do
                result := result.append([[a.name.toString(), a.type.name.toString(), -1, a.mult()]])
              end
            end
          end;
          ("").println();
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end*/

    @Operation getAllAttributes(requestID : Seq(Integer), className)
        let
          resultOwn   = [];
          resultOther = [];
          result = []
        in
          @For c in self.getPackage(requestID).classes do
            if c <> null andthen /*c.isKindOf(FMML::MetaClass) and*/ c.name.toString() = className
            then
              @For a in c.attributes do
                resultOwn   :=   resultOwn.append([[
                    a.name.toString(),
                    a.type.name.toString(),
                    if a.isIntrinsic then a.instLevel else -1 end,
                    FmmlxManipulator::multiplicity2ValueList(a.mult()),
                    c.path()
                    ]])
              end;
              @For a in (c.allAttributes() - c.attributes) do
                if a.isIntrinsic then
                  resultOther := resultOther.append([[
                    a.name.toString(),
                    a.type.name.toString(),
                    if a.isIntrinsic then a.instLevel else -1 end,
                    FmmlxManipulator::multiplicity2ValueList(a.mult()),
                    a.owner.path()
                    ]])
                end
              end
            end
          end;
          result := [resultOwn, resultOther];
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getSlots(requestID : Seq(Integer), objectName, slotList)
      let
        result = []
      in
        @For o in self.getPackage(requestID).classes do
          if o <> null andthen o.isKindOf(FMML::MetaClass) andthen o.name.toString() = objectName
          then
            @For name in slotList do
              if o.hasSlot(name)
              then
                let
                  value = o.get(name)
                then
                  text = if value.of().isKindOf(Enum) then value.name().toString() else value.toString() end
                in
                  result := result.append([[name, text]])
                end
              end
            end
          end
        end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getOperationValues(requestID : Seq(Integer), objectName, opNames)
      let
        result = []
      in
        @For obj in self.getPackage(requestID).classes do
          if obj <> null andthen obj.isKindOf(FMML::MetaClass) andthen obj.name.toString() = objectName andthen opNames.size() > 0
          then
            @For o in obj.of().allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
              if o.instLevel = obj.level then
                @For name in opNames do
                  if name = o.name.toString() then
                    let
                      opResult = try [o.invoke(obj,{}),null] catch (e) [null, e] end
                    then
                      value = opResult.at(0);
                      error = opResult.at(1);
                      monMin = o.hasProperty("monitorMin");
                      monMax = o.hasProperty("monitorMax")
                    then
                      minVal = if monMin then FmmlxDiagramClient::getOpProp(o, "monitorMin") else null end;
                      maxVal = if monMax then FmmlxDiagramClient::getOpProp(o, "monitorMax") else null end
                    then
                      hasRange = monMin or monMax or error <> null;
                      isInRange = (error = null) andthen
                                  if monMin then minVal <= value else true end andthen
                                  if monMax then maxVal >= value else true end
                    in
                      result := result.append([[
                        o.name.toString(),
                        if error = null then value else error.message.toString() end,
                        hasRange,
                        isInRange]])
                    end
                end end // if contains // for
              end // if level
            end end // if // for
          end
        end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getPathAsString(type:Class)
      try type.path() catch(e) Element.path() end
    end

    @Operation getReturnPathAsString(o) //:Operation
      try o.type().path() catch(e) Element.path() end
    end

    @Operation getOwnOperations(requestID : Seq(Integer), className)
        let
          result = []
        in
          @For c in self.getPackage(requestID).classes do
            if c <> null 
              andthen c.isKindOf(FMML::MetaClass) 
              andthen c.name.toString() = className
            then
              @For o in c.allOperations2() do if (not o.owner = null) and o.owner.isKindOf(FMML::MetaClass) then
                let
                  paramNames = o.paramNames();
                  paramTypesRaw = o.paramTypes();
                  paramTypes = []
                in
                  @For type in paramTypesRaw do
                    paramTypes := paramTypes.append([self.getPathAsString(type)])
                  end;
                  result := result.append([[
                  o.name.toString(),
                  paramNames,
                  paramTypes,
                  o.instLevel,
                  self.getReturnPathAsString(o),
                  o.source(),
                  o.owner.path(),
                  //if o.owner.isKindOf(FMML::MetaClass) then self.getMapping(requestID).getMappingId(o.owner) else -1 end,
                  [0,1,false,true], // to-do: multiplicity
                  self.isOperationMonitored(o),
                  let P = o.properties(); b = false in @For p in P do if p->head() = "delToClassAllowed" then b := p->tail() end end; b end
                  ]])
                end
              end end
            end;
            
            if c <> null 
              andthen (not c.isKindOf(FMML::MetaClass))
              andthen c.name.toString() = className
            then
              @For o in c.operations do if (not o.owner = null) then
                let
                  paramNames = o.paramNames();
                  paramTypesRaw = o.paramTypes();
                  paramTypes = []
                in
                  @For type in paramTypesRaw do
                    paramTypes := paramTypes.append([self.getPathAsString(type)])
                  end;
                  result := result.append([[
                  o.name.toString(),
                  paramNames,
                  paramTypes,
                  -1,
                  self.getReturnPathAsString(o),
                  o.source(),
                  o.owner.path(),
                  //if o.owner.isKindOf(FMML::MetaClass) then self.getMapping(requestID).getMappingId(o.owner) else -1 end,
                  [0,1,false,true], // to-do: multiplicity
                  self.isOperationMonitored(o),
                  false
                  ]])
                end
              end end
            end
          end;
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllEnums(requestID : Seq(Integer))
        let
          result = []
        in
    	  @For e in self.getPackage(requestID).classes do
    	    if e  <> null andthen e.isKindOf(Enum)
    	    then
    	      let
    	        enumItems = e.getChildren();
    	        itemList = []
    	      in
    	        @For item in enumItems do
    	          itemList := itemList + [item.name.toString()]
    	        end;
    	        result := result.append([[
    	        e.name.toString(),
    	        itemList]])
    	      end
    	    end
    	  end;
    	  // clean up mapping ?
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
        end
    end

    @Operation getAllAuxTypes(requestID : Seq(Integer))
      let
        result = []
      in
        if Root.hasElement("Auxiliary") then
    	  @For ac in Root::Auxiliary.getChildren() do
    	    if
    	      ac.isKindOf(Class)
    	    then
    	      result := result.append([[ac.name.toString()]])
    	    end
    	  end
    	end;
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end
    
    @Operation getAllDiagrams(requestID : Seq(Integer), packagePath : String) 
      let 
        result = []      
      in
        @For key in diagrams.keys() do
          if 
            diagrams.get(key).package.path().equals(packagePath)
          then
            result := result + [key]
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation getAllIssues(requestID : Seq(Integer))
      let
        result = []
      in
		@For obj in self.getPackage(requestID).classes do if obj <> null then
		  @For slot in obj.slots() do
		    if self.getPackage(requestID).classes.contains(slot.type.owner) then
		      if slot.type.mult().lowerBound > 0 andthen slot.value = null then
		        result := result + [[
		        "SLOT_NULL",
		        "The slot " + slot.name + " must not be empty.",
		        [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		        ["setSlotValue", self.getMapping(requestID).addOrGetObjectMapping(obj).id, slot.name.toString()]]]
		      end // if null and mandatory
		    end // if slot fmmlx
		  end; // for slots
		  if obj.delegatesTo <> null then @For otherObj in self.getPackage(requestID).classes do // if for (check delegation)
		    if FmmlxManipulator::isInstanceOf(otherObj, obj, obj.delegatesToLevel) andthen 
		     ( otherObj.roleFiller = null orelse not FmmlxManipulator::isInstanceOf(otherObj.roleFiller, obj.delegatesTo, obj.delegatesToLevel))
			then result := result + [[
			    "NO_ROLE_FILLER",
			    "A role filler is required",
			    [self.getMapping(requestID).addOrGetObjectMapping(otherObj).id],
			    ["addRoleFiller",
			      self.getMapping(requestID).addOrGetObjectMapping(otherObj).id,
			      self.getMapping(requestID).addOrGetObjectMapping(obj.delegatesTo).id]]]
			end
		  end end; // for/if delegation
/*		  if obj.of().isKindOf(FMML::MetaClass) andthen obj.of().delegatesTo <> null and obj.roleFiller = null
		  then result := result + [[
		    "NO_ROLE_FILLER",
		    "A role filler is required",
		    [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		    ["addRoleFiller",
		      self.getMapping(requestID).addOrGetObjectMapping(obj).id,
		      self.getMapping(requestID).addOrGetObjectMapping(obj.of().delegatesTo).id]]]
		  end;
*/		  @For assoc in self.getPackage(requestID).associations do
		    if FmmlxManipulator::isInstanceOf(obj, assoc.end1.type, assoc.end1.instLevel) // if obj fits sourceDef
		    then
		      let
		        count = FmmlxManipulator::countOccurences(obj, self.getPackage(requestID), assoc, true, false) // how many links go out of obj as source
		      in
		        if
		          count < assoc.end2.mult().lowerBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_LOW",
		            "The association " + assoc.name + " requires more links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["addMissingLink", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end;
		        if
		          assoc.end2.mult().hasUpperBound() andthen count > assoc.end2.mult().upperBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_HIGH",
		            "The association " + assoc.name + " requires fewer links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["removeTooManyLinks", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end
		      end // let
		    end; // if instance of
		    if FmmlxManipulator::isInstanceOf(obj, assoc.end2.type, assoc.end2.instLevel) // if obj fits targetDef
		    then
		      let
		        count = FmmlxManipulator::countOccurences(obj, self.getPackage(requestID), assoc, false, true)
		      in
		        if
		          count < assoc.end1.mult().lowerBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_LOW",
		            "The association " + assoc.name + " requires more links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["addMissingLink", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end;
		        if
		          assoc.end1.mult().hasUpperBound() andthen count > assoc.end1.mult().upperBound()
		        then
		          result := result + [[
		            "ASSOC_MULT_HIGH",
		            "The association " + assoc.name + " requires fewer links.",
		            [self.getMapping(requestID).addOrGetObjectMapping(obj).id],
		            ["removeTooManyLinks", self.getMapping(requestID).addOrGetObjectMapping(obj).id, self.getMapping(requestID).addOrGetObjectMapping(assoc).id]]]
		        end
		      end // let
		    end // if instance of
		  end // for assoc
		end end; // for/if obj
    	self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    ///////////////////// Updates to the View ////////////////////

    @Operation sendNewPosition(requestID : Seq(Integer), objectPath, x, y)
        self.getMapping(requestID).setNewPosition(objectPath, x, y);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation sendNewPositions(requestID : Seq(Integer), edgeID, listOfpoints)
        self.getMapping(requestID).setNewPositions(edgeID, listOfpoints);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation storeLabelInfo(requestID : Seq(Integer), edgeID, localID, x, y)
        self.getMapping(requestID).storeLabelInfo(edgeID, localID, x, y);
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    ////////////////// Class Manipulations ///////////////////

    @Operation addMetaClass(requestID : Seq(Integer), name, level, parents, abstract, x, y)
        let
          m = FmmlxDiagrams::FmmlxManipulator()
        then
          parentsList = self.getParentsList(requestID, parents)
        then
          newClass = m.addMetaClass(self.getPackage(requestID), name, level, parentsList, abstract)
        then
          mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newClass)
        in
          mappingInfo.lastKnownDiagramX := x;
          mappingInfo.lastKnownDiagramY := y;
	        self.log := self.log + [["addMetaClass", ["package", newClass.owner.path()], ["name",name] , ["level",level+""] , ["parents",self.getParentsPaths(requestID, parentsList)] , ["abstract",abstract+""]]]
        end;
         
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []]) // temporary empty result
    end

    @Operation addInstance(
            requestID : Seq(Integer),
            ofName,
            name,
            parents,
            abstract,
            x, y,
            slotValueList: Seq(Seq(String)) )
        try
          let
            m = FmmlxDiagrams::FmmlxManipulator()
          then
            ofClass = if self.getPackage(requestID).hasElement(ofName) then self.getPackage(requestID).getElement(ofName) else null end
            //ofClass = self.getMapping(requestID).getMapping(ofId).object
          then
            parentsList = self.getParentsList(requestID, parents)
          then
            newInstance = m.addInstance(self.getPackage(requestID), ofClass, name, parentsList, abstract, slotValueList)
          then
            mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(newInstance)
          in
            mappingInfo.lastKnownDiagramX := x;
            mappingInfo.lastKnownDiagramY := y;
            self.log := self.log + [["addInstance", ["package", newInstance.owner.path()], ["of", ofClass.path()] , ["name",name] , ["parents",self.getParentsPaths(requestID, parentsList)] , ["abstract",abstract+""]]]
          end;
          self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
        catch (exception)
          self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), [exception.message]])
        end
    end

    @Operation removeClass(requestID : Seq(Integer), className, strategy)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        classPath4Log = class.path()
      in
        m.removeClass(class, strategy);
        self.log := self.log + 	[["removeClass", ["package", self.getPackage(requestID).path()], ["class", classPath4Log]]]
      end;
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result 
    end

    @Operation changeClassName(requestID : Seq(Integer), className, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        oldPath = class.path()
      in
        m.changeClassName(class, newName);
        self.getMapping(requestID).updateKey(oldPath, class.path());
        self.log := self.log + [["changeClassName", ["package", class.owner.path()], ["class", className] , ["newName",newName]]]
      end;
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), []])
    end

    @Operation setClassAbstract(requestID : Seq(Integer), className, isAbstract)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.changeClassAbstract(class, isAbstract) else ["Class not found"] end
      in
        if problems.isEmpty() then
          self.log := self.log + [["setClassAbstract", ["package", class.owner.path()], ["class", class.path()] , ["abstract",isAbstract+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation levelRaiseAll(requestID : Seq(Integer), amount)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.levelRaiseAll(self.getPackage(requestID), amount)
      in
        if problems.isEmpty() then
           self.log := self.log + [["levelRaiseAll", ["package", self.getPackage(requestID).path()], ["amount", amount+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeParent(requestID : Seq(Integer), className, oldList, newList)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        oldSet = self.vector2Seq(oldList).asSet();
        newSet = self.vector2Seq(newList).asSet();
        problems = [];
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        oldParentList = class.parents;// for Log
        addSet = newSet - oldSet;
        removeSet = oldSet - newSet
      in
//        if
//          removeSet = {}
//        then
          @For parentName in addSet do
            let
              pr = m.evalString(parentName, self.getPackage(requestID))
            then
              parentToBeAdded = if pr.at(1) = null then pr.at(0) else null end
            in
              problems := problems + if parentToBeAdded = null then ["Cannot find new parent " + parentName] else m.addParent(class, parentToBeAdded) end
            end
          end
;//        elseif
//          addSet = {}
//        then
          @For parentName in removeSet do
            let
              pr = m.evalString(parentName, self.getPackage(requestID))
            then
              parentToBeRemoved = if pr.at(1) = null then pr.at(0) else null end
            in
              problems := problems + if parentToBeRemoved = null then ["Cannot find old parent " + parentName] else m.removeParent(class, parentToBeRemoved) end
            end
          end
;//        elseif
//          removeSet.size() = 1 and addSet.size() = 1 // move exactly one parent
//        then
//          let
//            parentToBeAdded = self.getMapping(requestID).getMapping(addSet.asSeq().at(0)).object;
//            parentToBeRemoved = self.getMapping(requestID).getMapping(removeSet.asSeq().at(0)).object
//          in
//            problems := problems + m.moveParent(class, parentToBeRemoved, parentToBeAdded)
//          end
//        else
//          problems := problems + ["Only one parent may be moved at a time."]
//        end;
        if problems.isEmpty() then
          self.log := self.log + [[
          "changeParent", 
          ["package", class.owner.path()], 
          ["class", class.path()], 
          ["old", self.getParentsPaths(requestID, oldParentList)], 
          ["new", self.getParentsPaths(requestID, class.parents)]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    //////////////////////// Attribute Manipulations /////////////////////

    @Operation addAttribute(requestID : Seq(Integer), className, name, level, typeName, multiplicityV)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
//        class = self.getMapping(requestID).getMapping(classId).object;
        type = m.getTypeForName(typeName, self.getPackage(requestID));
        multiplicity = m.valueList2Multiplicity(self.vector2Seq(multiplicityV))
      then
        problems = if class <> null then m.checkAddAttribute(class, name, level, typeName) else ["Class not found"] end
      in
        if
          problems.isEmpty()
        then
          problems := try
            m.addAttribute(class, name, level, type, multiplicity); []
          catch(e)
            [("addAttribute failed during transaction: " + e.message)]
          end // try
        end; // if
        if problems.isEmpty() then
            self.log := self.log + [["addAttribute", 
                                            ["package", class.owner.path()],
                                            ["class", class.path()],
                                            ["name", name],
                                            ["level", level+""],
                                            ["type", type.path()],
                                            ["multiplicity",  FmmlxManipulator::multiplicity2ValueList(multiplicity)+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end // in
    end

    @Operation changeAttributeName(requestID : Seq(Integer), className, oldName, newName)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
          then
		class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeAttributeName(class, oldName, newName) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeAttributeName(class, oldName, newName);
          self.log := self.log + [["changeAttributeName", ["package", class.owner.path()], ["class", class.path()] , ["oldName", oldName] , ["newName", newName]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeLevel(requestID : Seq(Integer), className, attName, oldLevel, newLevel)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel) else ["Class not found"] end
        //problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
      in
        if problems.isEmpty() then
          m.changeAttributeLevel(class, attName, oldLevel, newLevel);
          self.log := self.log + [["changeAttributeLevel", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldLevel", oldLevel+""] , ["newLevel", newLevel+""]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeType(requestID : Seq(Integer), className, attName, oldTypeName, newTypeName)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
          class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        problems = if class <> null then m.checkChangeAttributeType(class, attName, oldTypeName, newTypeName, self.getPackage(requestID)) else ["Class not found"] end
      in
        if problems.isEmpty() then
          m.changeAttributeType(class, attName, oldTypeName, newTypeName, self.getPackage(requestID));
          self.log := self.log + [["changeAttributeType", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldType", oldTypeName] , ["newType", newTypeName]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAttributeMultiplicity(requestID : Seq(Integer), className, attName, oldMul, newMul)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        oldMult = m.valueList2Multiplicity(self.vector2Seq(oldMul));
        newMult = m.valueList2Multiplicity(self.vector2Seq(newMul))
      then    // TODO !!!
//          problems = m.checkChangeAttributeLevel(class, attName, oldLevel, newLevel)
         problems = []
         
      in
        if problems.isEmpty() then
          m.changeAttributeMultiplicity(class, attName, null, newMult);
          self.log := self.log + [["changeAttributeMultiplicity", ["package", class.owner.path()], ["class", class.path()] , ["name", attName] , ["oldMul", FmmlxManipulator::multiplicity2ValueList(oldMult)+""] , ["newMul", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation removeAttribute(requestID : Seq(Integer), className, attName, strategy)
     // for now: ignore strategy and simply delete
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      in
        m.removeAttribute(class, attName, strategy);
        self.log := self.log + [["removeAttribute", ["package", class.owner.path()], ["class", class.path()], ["name", attName]]]
      end;
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), null]) // temporary empty result
    end

    //////////////////////// Slot Manipulations /////////////////////

    @Operation changeSlotValue(requestID : Seq(Integer), className, slotName, valueToBeParsed)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        obj = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
        error = null
      then
        class = obj.of();
        foundAtt = m.findAttributeForSlot(obj, slotName)
      in
        if
          foundAtt <> null
        then
          let
            parseResult = m.evalString(valueToBeParsed, self.getPackage(requestID))
          in
            if parseResult.at(1) = null then
              error := m.changeSlotValue(obj, slotName, parseResult.at(0), foundAtt.type, self.getPackage(requestID))
            else
              error := parseResult.at(1) // error as message or as return value? maybe try exceptions...
            end
          end

        else
          error := "no Slot Found"
        end;
	  self.log := self.log + [["changeSlotValue", 
                                  ["package", class.owner.path()],
                                  ["class", obj.path()],
                                  ["slotName", slotName],
                                  ["valueToBeParsed", valueToBeParsed]]];
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), if error = null then null else [error] end]) // temporary empty result
      end
    end

    //////////////// Local Operations ///////////////////

    @Operation vector2Seq(vec) // for local use
      let list = [] in
        @For id in vec do
          list := list.append([id])
        end; // for
        list
      end// let
    end

    @Operation getParentsList(requestID, parentNames) // for local use
      let
        list = [];
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        @For name in parentNames do
        let
            parent = try m.getTypeForName(name, self.getPackage(requestID)) catch(e) null end
        in
            if not parent = null then list := list.append([parent]) end
        end
        end; // for
        list
      end// let
    end

    @Operation getParentsPaths(requestID, parents) // for local use
      let list = "" in
        @For parent in parents do
          if not parent = null then list := list + parent.path() + "," end
        end; // for
        list.subString(0, list.size()-1)
      end// let
    end
    
    @Operation getParentsPathsList(requestID, c : FMML::MetaClass) // for local use
      let list = [] in
        @For p in c.parents do
          //if p.isKindOf(FMML::MetaClass) then 
            list := list.append([p.path()]) //end
        end; // for
        list
      end// let
    end

    @Operation isOperationMonitored(o)
      if o.hasProperty("monitor") then FmmlxDiagramClient::getOpProp(o, "monitor") else false end
    end

    ////////////////// Operations for editing associations ///////////////////

  @Operation addAssociation(requestID : Seq(Integer),
      classSourceName : String,
      classTargetName : String,
      accessSourceFromTargetName : String,
      accessTargetFromSourceName : String,
      fwName : String,
      reverseName : String,
      multTargetToSourceS : String,
      multSourceToTargetS : String,
      instLevelSource : Integer,
      instLevelTarget : Integer,
      sourceVisibleFromTarget : Boolean,
      targetVisibleFromSource : Boolean,
	  isSymmetric : Boolean,
	  isTransitive : Boolean):XCore::Element


  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator()
      then
        classSource = m.evalString(classSourceName, self.getPackage(requestID)).at(0);//if package.hasElement(classSourceName) then package.getElement(classSourceName) else null end;
        classTarget = m.evalString(classTargetName, self.getPackage(requestID)).at(0)//if package.hasElement(classTargetName) then package.getElement(classTargetName) else null end
      then
        multTargetToSource = m.valueList2Multiplicity(self.vector2Seq(multTargetToSourceS));
        multSourceToTarget = m.valueList2Multiplicity(self.vector2Seq(multSourceToTargetS))
      then
        problems = [] /*m.checkAddAssociation(self.getPackage(requestID),
  	      classSource, classTarget,
  	      accessSourceFromTargetName, accessTargetFromSourceName,
  	      fwName, reverseName,
  	      multTargetToSource, multSourceToTarget,
  	      instLevelSource, instLevelTarget) */
      in
        if problems.isEmpty() then
  	      problems := m.addAssociation(self.getPackage(requestID),
  	        classSource, classTarget,
  	        accessSourceFromTargetName, accessTargetFromSourceName,
  	        fwName, reverseName,
  	        multTargetToSource, multSourceToTarget,
  	        instLevelSource, instLevelTarget,
  	        sourceVisibleFromTarget, targetVisibleFromSource,
  	        isSymmetric, isTransitive);
          self.log := self.log + [["addAssociation", ["package", classSource.owner.path()],
            ["classSource", classSource.path()] ,["classTarget", classTarget.path()] ,
            ["accessSourceFromTargetName", accessSourceFromTargetName] , ["accessTargetFromSourceName", accessTargetFromSourceName] ,
            ["fwName", fwName+""],
            ["reverseName", reverseName+""],
            ["multTargetToSource", FmmlxManipulator::multiplicity2ValueList(multTargetToSource)+""] , ["multSourceToTarget", FmmlxManipulator::multiplicity2ValueList(multSourceToTarget)+""] ,
            ["instLevelSource", instLevelSource+""] , ["instLevelTarget", instLevelTarget+""] ,
            ["sourceVisibleFromTarget", sourceVisibleFromTarget+""] , ["targetVisibleFromSource", targetVisibleFromSource+""] ,
            ["isSymmetric", isSymmetric+""] , ["isTransitive", isTransitive+""]]]
   	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
  	end

    @Operation removeAssociation(
      requestID  : Seq(Integer),
      assocName    : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.removeAssociation(assoc);
        packagePath = assoc.owner.path();
        assocName =  assoc.name
      in
        if problems.isEmpty() then
          self.log := self.log + [["removeAssociation", ["package", packagePath], ["name", assocName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation setAssociationEndVisibility(
      requestID      : Seq(Integer),
      assocName      : String,
      concernsTarget : Boolean,
      newVisibility  : Boolean)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        problems = m.setAssociationEndVisibility(assoc, ["package", assoc.owner.path()], concernsTarget, newVisibility)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeAssociationForwardName(
      requestID  : Seq(Integer),
      assocName    : String,
      newName    : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assoc = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        oldName = assoc.name
      then
        problems = m.changeAssociationForwardName(assoc, newName)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeAssociationForwardName", ["package", assoc.owner.path()], ["newFwName", newName], ["oldFwName", oldName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

   @Operation changeAssociationEnd2StartMultiplicity(requestID : Seq(Integer), assocName, multV)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      then
        problems = m.changeAssociationMultiplicity(a, newMult, null)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeAssociationEnd2StartMultiplicity", ["package", a.owner.path()], ["name", a.name], ["multiplicity", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeAssociationStart2EndMultiplicity(requestID : Seq(Integer), assocName, multV)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        a = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
      then
        newMult = m.valueList2Multiplicity(self.vector2Seq(multV))
      then
        problems = m.changeAssociationMultiplicity(a, null, newMult)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeAssociationStart2EndMultiplicity", ["package", a.owner.path()], ["name", a.name], ["multiplicity", FmmlxManipulator::multiplicity2ValueList(newMult)+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    //////////////////////////////////////////////////////////

  	@Operation addAssociationInstance(requestID : Seq(Integer),
      obj1Name  : String,
      obj2Name  : String,
      assocName : String)

  	  let
  	    m = FmmlxDiagrams::FmmlxManipulator();
  	    obj1 = if self.getPackage(requestID).hasElement(obj1Name) then self.getPackage(requestID).getElement(obj1Name) else null end;
  	    obj2 = if self.getPackage(requestID).hasElement(obj2Name) then self.getPackage(requestID).getElement(obj2Name) else null end;
  	    association = if self.getPackage(requestID).hasAssociation(assocName) then self.getPackage(requestID).getAssociation(assocName) else null end
  	  then
        problems = m.addAssociationInstance(self.getPackage(requestID), obj1, obj2, association)
  	  in
  	    if problems.isEmpty() then
  	        self.log := self.log + [["addLink", ["package", association.owner.path()], ["name", association.name.toString()], ["classSource", obj1.path()], ["classTarget", obj2.path()]]]
  	    end;
  	    self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
  	  end
    end

    @Operation removeAssociationInstance(
      requestID   : Seq(Integer),
      linkId    : Integer)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        assocInstSeq = self.getMapping(requestID).getMapping(linkId).object
      then
        problems = m.removeAssociationInstance(assocInstSeq)
      in
        if problems.isEmpty() then
  	        self.log := self.log + [["removeLink", ["TODO", "Still using ID, no another possibility"]]]
  	    end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    ////////////////// Operations for delegation ///////////////////////////


    @Operation addDelegation(
      requestID   : Seq(Integer),
      delegateFromName  : String,
      delegateToName    : String,
      delegateToLevel   : Integer)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        delegateFrom = if self.getPackage(requestID).hasElement(delegateFromName) then self.getPackage(requestID).getElement(delegateFromName) else null end;
        delegateTo = if self.getPackage(requestID).hasElement(delegateToName) then self.getPackage(requestID).getElement(delegateToName) else null end
      then
        problems = m.addDelegation(delegateFrom, delegateTo, delegateToLevel)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addDelegation", ["package", delegateFrom.owner.path()],
              ["delegateFrom",  delegateFrom.path()],  
              ["delegateTo",  delegateTo.path()],  
              ["delegateToLevel",  delegateToLevel+""]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation setRoleFiller(
      requestID   : Seq(Integer),
      roleName  : String,
      roleFillerName    : String)
      let
        m = FmmlxDiagrams::FmmlxManipulator();
        role = if self.getPackage(requestID).hasElement(roleName) then self.getPackage(requestID).getElement(roleName) else null end;
        roleFiller = if self.getPackage(requestID).hasElement(roleFillerName) then self.getPackage(requestID).getElement(roleFillerName) else null end
      then
        problems = m.setRoleFiller(role, roleFiller)
      in
        if problems.isEmpty() then
            self.log := self.log + [["setRoleFiller", ["package", role.owner.path()], ["role", role.path()], ["roleFiller", roleFiller.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    ////////////////// Operations for editing operations ///////////////////

    @Operation changeOperationName(requestID : Seq(Integer), className, oldName, newName)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        problems = if class <> null then m.checkChangeOperationName(class, oldName, newName) else ["Class not found"] end
        //problems = m.checkChangeOperationName(class, oldName, newName)
      in
        if problems.isEmpty() then
          m.changeOperationName(class, oldName, newName);
          self.log := self.log + [["changeOperationName", ["package", class.owner.path()], ["oldName", oldName] , ["newName", newName] , ["class", class.path()]]]
          end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation changeOperationLevel(requestID : Seq(Integer), className, name, oldLevel, newLevel)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
        //class = self.getMapping(requestID).getMapping(classId).object
      then
        o = m.findOperation(class,name)
      then
        problems = if class <> null then m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o)) else ["Class not found"] end
        //problems = m.changeOperationLevel(class, o, newLevel, self.isOperationMonitored(o))
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeOperationLevel", ["package", class.owner.path()], ["oldLevel", oldLevel+""], ["newLevel", newLevel+""] , ["name", name] , ["class", class.path()]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation addOperation(
      requestID  : Seq(Integer),
      classId    : Integer,
      opName     : String,
      level      : Integer,
      returnType : String,
      body       : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = self.getMapping(requestID).getMapping(classId).object
      then
        type = m.getTypeForName(returnType, self.getPackage(requestID));
        problems = m.addOperation(class, opName, level, type, body)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addOperation", ["package", class.owner.path()],
                ["class", class.path()],
                ["opName", opName],
                ["level", level+""],
                ["returnType", returnType.path()],
                ["body", body]]]
            end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation addOperation2(
      requestID  : Seq(Integer),
      className  : String,
      level      : Integer,
      body       : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        problems = if class <> null then m.addOperation2(class, level, body) else ["Class not found"] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["addOperation2", ["package", class.owner.path()],
            ["class", class.path()],
            ["level", level+""],
            ["body", body]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation removeOperation(
      requestID  : Seq(Integer),
      className    : String,
      opName     : String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        //class = self.getMapping(requestID).getMapping(classId).object
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end
      then
        //problems = m.removeOperation(class, opName)
        problems = if class<>null then m.removeOperation(class, opName) else ["Class not found"] end
      in
        if problems.isEmpty() then
            self.log := self.log + [["removeOperation", ["package", class.owner.path()], ["class", class.path()], ["name", opName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems]) // return null or problems
      end
    end

    @Operation getOpProp(operation, name) // for local use
      let
        properties = operation.properties();
        tagFound = null
      in
        @For property in properties do
          if property->head() = name
            then tagFound := property->tail()
          end
        end;
        tagFound
      end
    end

    @Operation changeOperationOwner(requestID : Seq(Integer), className_old, name, className_new)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        oldOwner = if self.getPackage(requestID).hasElement(className_old) then self.getPackage(requestID).getElement(className_old) else null end;
        newOwner = if self.getPackage(requestID).hasElement(className_new) then self.getPackage(requestID).getElement(className_new) else null end
      then
        operation = oldOwner.getOperation(name)
      then
        problems = m.changeOperationOwner(oldOwner, operation, newOwner)
      in
        if problems.isEmpty() then
          self.log := self.log + [["changeOperationOwner", ["package", class.owner.path()], ["class_old", oldOwner.path()], ["class_new",newOwner.path()] , ["name",name]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation checkOperationNameLegal(op, name):Boolean // todo: check for duplicates, consider arity
      let nameSymbol = Symbol(name) in
        if nameSymbol = op.name()
        then
          true
        else
          op.legalNameChangeCheck(nameSymbol,op.name())
        end
      end
    end

    @Operation changeOperationBody(requestID : Seq(Integer), className:String, operationName:String, body:String)

      let
        m = FmmlxDiagrams::FmmlxManipulator();
        class = if self.getPackage(requestID).hasElement(className) then self.getPackage(requestID).getElement(className) else null end;
        problems = []
      then
        op = class.getOperation(operationName)
      then
        newName = body.splitBy("()[]",0,0)->head.subst("","@Operation ",false)
      in
        if operationName.toString() <> newName.toString() then
          problems := ["name change not allowed here"]
        elseif
          op = null then
          problems := ["operation not found"]
        else // let the manipulator try
          problems := m.changeOperationBody(class, op, newName, body)
        end;
        if problems.isEmpty() then
          self.log := self.log + [["changeOperationBody", ["package", class.owner.path()], ["class",className] , ["name",operationName], ["body", body]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    // Not yet implemented

    @Operation respondNotYetImplemented(name: String, requestID : Seq(Integer))
      self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), ["The feature \"" + name + "\" is temporarily unavailable. Please try again later."]])
    end

    @Operation changeAssociationStart2EndAccessName(requestID : Seq(Integer), associationID, name)
      self.respondNotYetImplemented("changeAssociationStart2EndAccessName", self.vector2Seq(requestID))
    end

    @Operation changeAssociationEnd2StartAccessName(requestID : Seq(Integer), associationID, name)
      self.respondNotYetImplemented("changeAssociationEnd2StartAccessName", self.vector2Seq(requestID))
    end

    @Operation changeAssociationStart2EndLevel(requestID : Seq(Integer), associationID, level)
      self.respondNotYetImplemented("changeAssociationStart2EndLevel", self.vector2Seq(requestID))
    end

    @Operation changeAssociationEnd2StartLevel(requestID : Seq(Integer), associationID,level)
      self.respondNotYetImplemented("changeAssociationEnd2StartLevel", self.vector2Seq(requestID))
    end

    @Operation updateAssociationInstance(requestID : Seq(Integer), startObjectPath : String, endObjectPath : String)
      self.respondNotYetImplemented("updateAssociationInstance", self.vector2Seq(requestID))
    end

    @Operation changeAssociationTarget(inA : Seq(Integer), nameT_o, nameT_n)
      self.respondNotYetImplemented("changeAssociationTarget", self.vector2Seq(requestID))
    end

    @Operation changeAssociationSource(inA : Seq(Integer), idS_o, idS_n)
      self.respondNotYetImplemented("changeAssociationSource", self.vector2Seq(requestID))
    end

    @Operation checkOperationBody(requestID : Seq(Integer), operationBodyToBeChecked)
      self.respondNotYetImplemented("checkOperationBody", self.vector2Seq(requestID))
    end

    @Operation changeOperationType(requestID : Seq(Integer), className, opName, newType)
      self.respondNotYetImplemented("changeOperationType", self.vector2Seq(requestID))
    end

    @Operation changeAttributeOwner(requestID : Seq(Integer), path_old, name, path_new)
      self.respondNotYetImplemented("changeAttributeOwner", self.vector2Seq(requestID))
    end

    @Operation changeOf(requestID : Seq(Integer), idO, idC_old, idC_new)
      self.respondNotYetImplemented("changeOf", self.vector2Seq(requestID))
    end

    @Operation changeClassLevel(requestID : Seq(Integer), idO, newLevel)
      self.respondNotYetImplemented("changeClassLevel", self.vector2Seq(requestID))
    end

    @Operation addEnumeration(requestID : Seq(Integer), newEnumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumeration(self.getPackage(requestID), newEnumName)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addEnumeration", ["name",newEnumName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeEnumerationName(requestID : Seq(Integer), oldEnumName:String, newEnumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationName(self.getPackage(requestID), oldEnumName, newEnumName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation removeEnumeration(requestID : Seq(Integer), enumName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumeration(self.getPackage(requestID), enumName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation addEnumerationValue(requestID : Seq(Integer), enumName:String, newEnumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.addEnumerationValue(self.getPackage(requestID), enumName, newEnumValueName)
      in
        if problems.isEmpty() then
            self.log := self.log + [["addEnumerationValue", ["enum_name",enumName], ["enum_value_name", newEnumValueName]]]
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation changeEnumerationValueName(requestID : Seq(Integer), enumName:String, oldEnumValueName:String, newEnumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.changeEnumerationValueName(self.getPackage(requestID), enumName, oldEnumValueName, newEnumValueName)
      in
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation removeEnumerationValue(requestID : Seq(Integer), enumName:String, enumValueName:String)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        problems = m.removeEnumerationValue(self.getPackage(requestID), enumName, enumValueName)
      in
        ("removeEnumerationValue problems: " + problems).println();
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), problems])
      end
    end

    @Operation printProtocol(requestID : Seq(Integer)) // to be removed
      self.log.println()
    end

    @Operation printLog(requestID : Seq(Integer))
      self.log.println()
    end

    @Operation assignToGlobal(requestID : Seq(Integer), objPath:String, varName:String)
      let
        class = self.getMapping(requestID).getMapping(objID).object
      in
        if
          class <> null
        then
          class.assignToGlobal(varName)
        end;
        []
      end
    end

    @Operation showBody(requestID : Seq(Integer), objID:Integer, opName:String, arity:Integer)
      let
        class = self.getMapping(requestID).getMapping(objID).object
      in
        if
          class <> null andthen class.getOperation(opName) <> null
        then
          class.getOperation(opName).edit()
        end;
        []
      end
    end

    @Operation updateAll(obj:Element)
      let
        clients = Clients::FmmlxDiagrams::FmmlxDiagramClient.allInstances()->select(a | a.package = obj.owner)
      in
        @For client in clients do
          client.communicator.triggerUpdate()
        end
      end
    end

    @Operation evalList(requestID : Seq(Integer), text)
      ("eval List start: " + text).println();
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      then
        result = [];
        error = [];
        parseResult = m.evalString(text, self.getPackage(requestID))
      in
        if
          parseResult.at(1) = null
        then
          parseResult.at(0).println();
          if
            parseResult.at(0).isKindOf(Seq(Element))
          then
            @For element in parseResult.at(0) do
              result := result + [element.toString()]
            end
          else
            result:=["The expression " + text + " does not evaluate to a list."]
          end
        else
          parseResult.at(1).println();
          result:=[parseResult.at(1)]
        end;
        "eval List done".println();
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation addDefaultEnums(p:Package)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        if not p.hasElement("Level") then
          m.addEnumeration(p, "Level");
          m.addEnumerationValue(p, "Level", "High");
          m.addEnumerationValue(p, "Level", "Medium");
          m.addEnumerationValue(p, "Level", "Low") end;
        if not p.hasElement("Gender") then
          m.addEnumeration(p, "Gender");
          m.addEnumerationValue(p, "Gender", "Male");
          m.addEnumerationValue(p, "Gender", "Female");
          m.addEnumerationValue(p, "Gender", "Unspecified") end;
        if not p.hasElement("LegalForm") then
          m.addEnumeration(p, "LegalForm");
          m.addEnumerationValue(p, "LegalForm", "Private_Limited_Partnership");
          m.addEnumerationValue(p, "LegalForm", "Limited_Liability");
          m.addEnumerationValue(p, "LegalForm", "Corporation");
          m.addEnumerationValue(p, "LegalForm", "Non_Profit") end;
        if not p.hasElement("Unit") then
          m.addEnumeration(p, "Unit");
          m.addEnumerationValue(p, "Unit", "piece");
          m.addEnumerationValue(p, "Unit", "kg");
          m.addEnumerationValue(p, "Unit", "litre");
          m.addEnumerationValue(p, "Unit", "gr");
          m.addEnumerationValue(p, "Unit", "meter");
          m.addEnumerationValue(p, "Unit", "km");
          m.addEnumerationValue(p, "Unit", "qm");
          m.addEnumerationValue(p, "Unit", "crate") end
      end
    end

    @Operation getDiagramData(requestID : Seq(Integer))
        //let
        //  result = [log]
        //in
    	  self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), if log.size() = 0 then ["log"] else ["log"] + log end])
        //end
    end

    @Operation findOperationImplementation(requestID: Seq(Integer), opNames: Seq(String), model:String, arity:String, returnType:String)
      let
        result = [];
        allClasses = Class.allInstances();
        opName = self.vector2Seq(opNames).at(0)
      in
        @For class in allClasses do
          @For op in class.operations do
            if op.name.toString() = opName.toString() then
              let paramTypes = [] in
                @For pt in op.paramTypes() do paramTypes := paramTypes + [pt.path()] end;
                result := result + [[
                  class.path(),
                  class.name.toString(),
                  op.arity,
                  op.paramNames(),
                  paramTypes,
                  op.type.path(),
                  op.codeBox.source()]]
              end
            end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end


    @Operation findAllOperations(requestID: Seq(Integer))
      let
        result = [];
        allClasses = Class.allInstances()
      in
        @For class in allClasses do
          @For op in class.operations do
              let paramTypes = [] in
                @For pt in op.paramTypes() do paramTypes := paramTypes + [pt.path()] end;
                result := result + [[
                  class.path(),
                  class.name.toString(),
                  op.arity,
                  op.paramNames(),
                  paramTypes,
                  op.type.path(),
                  op.codeBox.source()]]
              end
          end
        end;
        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end
    end

    @Operation findOperationUsage(requestID: Seq(Integer), opName: String, usage:String)

      let
        result = [];
        StringCheck = xmf.javaClass("tool.helper.StringCheck")
      then
        stringCheck = StringCheck()
      in
        @For class in Classifier.allInstances() do
          @For op in class.operations do
            if stringCheck.contains(op.codeBox.source(), opName) then
              result := result + [[
                class.path(),
                class.name.toString(),
                op.name.toString(),
                op.arity,
                op.paramNames(),
                null,
                op.type.path(),
                op.codeBox.source()]]
            end
          end
        end;

        self.getCommunicator().sendMessageToJava([self.vector2Seq(requestID), result])
      end // let
    end // @Op

    @Operation hideElements(requestID: Seq(Integer), elementPaths: String, hide:Boolean)
      let
        m = FmmlxDiagrams::FmmlxManipulator()
      in
        @For path in elementPaths do
          let
            element = m.evalString(path, self.getPackage(requestID)).at(0)
          in
            if
              element <> null
            then
              let
                mappingInfo = self.getMapping(requestID).addOrGetObjectMapping(element)
              in
                mappingInfo.hidden := hide
              end // let
            end // if
          end // let
        end // for
      end // let
    end // @Op

    @Operation loadProjectFromXml(requestID : Seq(Integer), packageName : String, diagramNames : Seq(String), file : String)
      let
        package : XCore::Element = XCore::Package(packageName)
      in
        let
          project : XCore::Element = Projects::Project(package,"",null)
        in
          Root.add(package);
          xmf.projectManager("MyProjects").add(project);
          if Root.hasElement("FMML")
          then
            package.addParent(FMML);

            @For diagramName in diagramNames do
                self.getCommunicator().createDiagram(package.path(), diagramName, file)
            end;
            self.getCommunicator().populateDiagram(file, self.vector2Seq(diagramNames).at(0))
          end
        end
      end;
      []
    end

    @Operation saveAsXml(requestID : Seq(Integer), packagePath, resourceName)
        let initName =
            if resourceName = ""
            then self.name + ".xml"
            else resourceName.toString().splitBy("/",0,0)->last
        end then
            file = xmf.saveFile(xmf.projDir(),"*.xml",initName)
        in
            if file <> "" then
            self.saveAsXml(requestID, file,packagePath, true)
        end
      end
    end

    @Operation saveAsXml(requestID : Seq(Integer), file:String, packagePath, confirm:Boolean)
        let write = true
        then
            package = self.getPackage(requestID)
        then
            project : XCore::Element = Projects::Project(package,"",null)
        in
            if not file.isReadOnly()
            then
                if file.fileExists() and self.loaded(package) and confirm
                then write := xmf.confirm(file + " exists. Overwrite?")
                end;
                if write //and self.ensureDir(dir)
                then
                    let dialog = xmf.busy("Saving")
                    in
                        project.savedBy := xmf.user();
                        project.saveDate := xmf.date();
                        self.getCommunicator().saveXmlFile(file, package.toString())
                    end;
                    xmf.message(
                        "Project " + project.name().toString() +
                        " saved (xml format).\nProject saved in file " + file + " on " + project.saveDate + ".\n" +
                        "Project created by " + project.creator + " on " + project.creationDate + ".\n" +
                        "Project saved by " + project.savedBy + ".\n")
                    end
                else
                    xmf.message("File " + file + " exists and is read only.  Cannot save to this file.")
                end
        end
    end

    @Operation loaded(package):Boolean
          package <> null
    end

end
