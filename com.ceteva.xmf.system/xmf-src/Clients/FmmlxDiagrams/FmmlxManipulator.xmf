parserImport XOCL;

import Clients;
import FmmlxDiagrams;

context FmmlxDiagrams

@Class FmmlxManipulator

  @Operation addMetaClass(package, name, level, parents, abstract)
    let 
      newClass = FMML::MetaClass(name, level)
    in
      package.add(newClass);
      newClass.isAbstract := abstract;
      if parents.size() > 0 then newClass.parents := parents.asSet() end;
      newClass
    end    
  end
    
  /* This operation creates a new instance. According to the attributes from its classes & parents & etc, 
     all slots need to be created. If the multiplicity of the slot mandates, a value needs to be acquired, either default or otherwise.
     For Associations, multiplicity must be checked as well.
     
     The following operation assumes the former to have been checked. 
     Until proving the mandatory slots has been taken care of, all slots will be simply initiated with null.
  
  */
  @Operation addInstance(package, ofClass, name, parents, abstract):Object

      // The following seems to be trivial, but better check once more
      if ofClass.level < 1 then self.error("Level " + ofClass.level + " does not allow instantiation.") end;

	  // We instantiate a new object "obj", whereas the class is "ofClass". Therefore: obj.of() is equal to ofClass
      let 
          // create new Object
        obj = Kernel_mkObj(); 
        myLevel = ofClass.level - 1;
        
          // We prepare a set of all Attributes from the class and a set of all Operations
          // !!! This needs to be changed to fit its purpose here.
          // !!! We need a list of all Attributes which are to be instantiated here.
        A = ofClass.allAttributes();
        O = ofClass.allOperations();

          // We also prepare a set to put (which?) Attributes/Operations into to (do what?)
          // !!! This can probably be dropped
        intrinsicA = Set{};
        intrinsicO = Set{}
      in 
        Kernel_setOf(obj,ofClass); // Now we set obj.of():=ofClass
      
         // Then we loop through the Attributes
         @While not A->isEmpty do
           let a = A->sel // pick any one Attribute
           in if a.isIntrinsic andthen a.instLevel < myLevel
              then // If it is intrinsic and not ready to become a slot the Attribute is put to the set we created before
                intrinsicA := intrinsicA.including(a)
              else // otherwise it becomes a slot and is initialised
                if a.init <> null
                then
                  Kernel_addAtt(obj,a.name,a.init.invoke(obj,Seq{}))
                else
                  Kernel_addAtt(obj,a.name,a.type.default())
                end;
                if a.hasProperty("visibility") then Kernel_setSlotVisibility(obj,a.name,a.visibility) end
              end;
              A := A->excluding(a) // we remove that attribute from the list as it has been handled
           end
         end;
         
         // Then we loop through the Operations
         @While not O->isEmpty do
           let op = O->sel // pick any one Operation
           in if op.isIntrinsic andthen op.instLevel < myLevel 
              then // If it is intrinsic and not ready to become available the Operation is put to the set we created before
                intrinsicO := intrinsicO.including(op)
              //else // otherwise it becomes available and we do nothing
              end;
              O := O->excluding(op) // we remove that attribute from the list as it has been handled
           end
         end;
         
         if ofClass.inheritsFrom(Classifier)
         then
           obj.parents := obj.defaultParents()
         else
           false
         end;

	    if parents.size() > 0 then obj.parents := parents.asSet() end;

         //then newClass.parents := parents.asSet() end; // test: may work or not...
         
         obj.init();
         
//                DON'T             
//         // Now       copy the intrinsic attributes to the object
//         @While not intrinsicA.isEmpty() do
//           let intA = intrinsicA.sel()
//           in 
//			obj.add(intA);
//              intrinsicA := intrinsicA.excluding(intA)
//           end
//		 end;
//         
//         // Copy the operations as well
//         @While not intrinsicO.isEmpty() do
//           let intO = intrinsicO.sel()
//           in 
//			obj.add(intO);
//              intrinsicO := intrinsicO.excluding(intO)
//           end
//		 end;
//
//		   if ofClass.delegatesTo <> null	
//		   then ofClass.selectRoleFiller(obj, ofClass) end;
//
//         if Root.contents.keys().includes("TargetPackage".asSymbol())
//         then
//           TargetPackage.add(obj)
//         else
//           false
//         end;

         ofClass.instances := ofClass.instances.including(obj);
         
         // todo: name, parents, abstract ...
        obj.level := myLevel;
        package.add(obj);         
        obj.setName(Symbol(name)); // todo: test name
        
        obj.isAbstract := abstract; // todo: check level 0
        obj.addParent(FMML::MetaClass);
        obj
      end
    end
    
    @Operation checkAddAttribute(class, name, level, type, multiplicity) 
      let 
        problems = []
      in 
        if not name.isValidName() then problems := problems + [("Identifier " + name + " not valid.")] end;
        @For attribute in class.allAttributes() do 
          if attribute.name.toString() = name 
            then problems := problems + [("Identifier " + name + " already in use (see " +attribute.owner.name.toString()+ ").")] 
          end
        end;
        @For child in class.allMetaInstances() do
          @For attribute in child.of().allAttributes() do 
            if attribute.name.toString() = name 
              then problems := problems + [("Identifier " + name + " already in use in " + child.name.toString() + " (see " +attribute.owner.name.toString()+ ").")] 
            end
          end
        end;
        problems
      end
    end    
    
    @Operation checkChangeAttributeName(class, oldName, newName)
      let
        attribute = null;
        problems = []
      in
		@For att in class.attributes do
		  if att.name.toString() = oldName then
		    attribute := att
		  end
		end;
		if attribute = null then problems := ["Attribute " + oldName + " not found in " + class.name + "."] 
		else
		  problems := self.checkAddAttribute(class, newName, attribute.instLevel, attribute.type, attribute.mult())
		end
		// add further tests here...
       ;problems
     end
    end
    
    @Operation getTypeForName(typeName)
      /* if typeName = "Integer" then 
        Integer 
      elseif typeName = "Float" then 
        Float 
      elseif typeName = "String" then 
        String 
      elseif typeName = "Boolean" then 
        Boolean 
      else
        Object 
      end */
      let
        parseResult = self.evalString(typeName)
      in
        //("parseValue: "+ parseResult.at(0)).println();
        //("parseError: "+ parseResult.at(1)).println();
        if parseResult.at(1) = null then 
          if parseResult.at(0).isKindOf(Classifier) then
            parseResult.at(0)
          else
            xmf.message(typeName + " is not a Classifier"); Object
          end
        else
          xmf.message(parseResult.at(1)); Object
        end
      end
    end
    
    @Operation addAttribute(class, name, instLevel, typeName, multiplicity) 
      // for now assume that checkAddAttribute did not return any trouble
      let 
        a = Attribute(name);
        allInst = class.allMetaInstances();
        type = self.getTypeForName(typeName)
      in 
        //("addAttribute type: " + type).println();
        a.isIntrinsic := true;
        a.type := type;
        a.instLevel := instLevel;
        
        class.addAttribute(a);
        
        @For instance in allInst do
          if instance.level = instLevel then 
            //if a.init <> null
            //then
            //  Kernel_addAtt(instance,a.name,a.init.invoke(obj,Seq{}))
            //else
              Kernel_addAtt(instance,a.name,a.type.default())
            //end;
          end
        end;
        
        a
      end
    end
    
    @Operation removeAttribute(class, attName, strategy)
        @For attribute in class.ownAttributes() do
          if attribute.name.toString() = attName then 
            // remove attribute
            class.remove(attribute);
            // remove slots
            @For instance in class.allMetaInstances() do
              // this instance may have a slot, check level first, otherwise ignore (no else)
              if attribute.instLevel = instance.level then 
                // now, the slot with the given name should be the one we are looking for
                // UNLESS: by an unknown coincidence, there is another attribute from double inheritance,
                // should not happen, but check anyway
                if self.instanceHasAttribute(instance, attName, attribute.instLevel) then
                  "Double Inheritance! Won't remove Slot".println()
                else // now remove
                  instance.removeStructuralFeature(attName)
                end // if something wrong, print msg, otherwise do
            end end // foor-loop+if, once for each instance, where the slot existed
        end end // for-loop+if, only once if att existed, never if not
    end
    
    @Operation changeAttributeName(class, oldName, newName)
      // for now assume that changeAttributeName did not return any trouble
      let
        attribute = null;
        allInst = class.allMetaInstances()
      in
        @For att in class.attributes do
          if att.name.toString() = oldName then
            attribute := att
          end
        end;
        
        attribute.name := newName.asSymbol();
                
        @For instance in allInst do
          if instance.level = attribute.instLevel then 
            Kernel_addAtt(instance,newName,instance.get(oldName));
            instance.removeStructuralFeature(oldName)
          end
        end;
        
        null
      end
    end

    @Operation instanceHasAttribute(instance, attName, instLevel)
      let found = false in
        @For attribute in instance.of().allAttributes() do 
          if attribute.name.toString() = attName 
            then found:=true
          end
        end;
      found   
      end
    end
    
    @Operation changeClassName(class, newName)
      let 
        package = class.owner
      in
        if
          package.hasElement(newName)
        then
          xmf.error(newName + " already in use in " + package)
        else
          if
            newName.isValidName() 
          then
            class.name := newName.asSymbol()
          else
            xmf.error(newName + " is not a valid name")
          end
        end
      end;
      null
    end
    
    @Operation checkChangeOperationName(class, oldName, newName)
      let
        operation = null;
        problems = []
      in
		@For o in class.operations do
		  if o.name.toString() = oldName then
		    operation := o
		  end;
		  if o.name.toString() = newName then
		    problems := problems + ["Operation " + newName + " already exists in " + class.name + "."]
		  end
		end;
		if operation = null then problems := problems + ["Operation " + oldName + " not found in " + class.name + "."] 
		end
		// add further tests here...
		// todo: check parent and of classes...
      ;problems
      end
    end
        
    @Operation changeOperationName(class, oldName, newName)
      // for now assume that changeOperationName did not return any trouble
      let
        operation = null
      in
        @For o in class.operations do
          if o.name.toString() = oldName then
            operation := o
          end
        end;
        
        operation.name := newName.asSymbol();
                
        null
      end
    end
    
    @Operation changeSlotValue(obj, slotName, valueToBeParsed) 
      let
        parseResult = self.evalString(valueToBeParsed)
      in
        //("parseValue: "+ parseResult.at(0)).println();
        //("parseError: "+ parseResult.at(1)).println();
        if parseResult.at(1) = null then 
          obj.set(slotName, parseResult.at(0))
          //if parseResult.at(0).isKindOf(Classifier) then
          //  parseResult.at(0)
          //else
          //  xmf.message(typeName + " is not a Classifier"); Object
          //end
        else
          xmf.message(parseResult.at(1)); null
        end
      end
    end
    
    @Operation evalString(text)
      if text.indexOf("(") >= 0 or text.indexOf(")") >= 0 then
        [null, "This is dangerous. Don't use '(' or ')' here!"]
      else
        try
          let 
            exp = OCL::OCL.grammar.parseString(text,"Exp1",Seq{XOCL})
          then 
            value = exp.eval(self,Env::NullEnv(),Seq{XCore,Root})
          in
            [value, null]
          end
        catch(exception)
        //xmf.message(exception.toString()); null
          [null, exception.toString()]
        end
      end
    end

end // Class