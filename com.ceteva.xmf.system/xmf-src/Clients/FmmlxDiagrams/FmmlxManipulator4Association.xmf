parserImport XOCL;

import Clients;
import FmmlxDiagrams;

  context FmmlxManipulator
   @Operation addAssociation(
     p: Package,
     source : MetaClass,
     target : MetaClass,
     accessSourceFromTargetName : String, // ref1
     accessTargetFromSourceName : String, // ref2
     fwName : String,
     assocType : AssociationType,
     multTargetToSource : XCore::Element,
     multSourceToTarget : XCore::Element,
     instLevelSource : XCore::Element,
     instLevelTarget : XCore::Element,
     sourceVisibleFromTarget : Boolean, 
     targetVisibleFromSource : Boolean,
     isSymmetric : Boolean,
     isTransitive : Boolean):XCore::Element
	      
  	  if // 1 check if fwName is valid and unique in p
  	    not fwName.isValidName()
  	  then
  	    [fwName + " is not a valid identifier"]
  	  elseif 
  	    not self.assocNameIsUniqueInPackage(fwName, p)
  	  then 
  	    [fwName + " is not unique"]
  	    
  	  // IGNORE 2 check if reverseName is valid and unique in p (and obviously different from fwName)
  	  
  	  elseif // 3 check if accessSourceFromTargetName is valid and unique in Target ! (in Target!)
  	    [] <> self.checkAddAttribute(target, accessSourceFromTargetName, instLevelTarget, source, null) 
  	  then
  	    [accessSourceFromTargetName + " is not unique in " + target.name]
  	  
  	  elseif //  4 check if accessTargetFromSourceName is valid and unique in Source !
  	    [] <> self.checkAddAttribute(source, accessTargetFromSourceName, instLevelSource, target, null) 
  	  then
  	    [accessTargetFromSourceName + " is not unique in " + source.name]
  	    
  	  //  5 check if one or more of mult1 and mult2 have a minimum of zero.
  	  //  5a check for circular mandatory multiplicity
  	  //  5b if one multiplicity > 0, demand default value // or leave inconsistent and demand subsequent repair.
  	  //  6 check instLevel plausibility  	  
  	      
  	  // can a class symmetrically self-associate?   
  	  
  	  else // all checks passed
        let 
          sourceFromTargetEnd = Associations::End(accessSourceFromTargetName,source,multTargetToSource);
          targetFromSourceEnd = Associations::End(accessTargetFromSourceName,target,multSourceToTarget)
        in 
          sourceFromTargetEnd.isIntrinsic := true;
          targetFromSourceEnd.isIntrinsic := true;
          sourceFromTargetEnd.instLevel := instLevelTarget;
          targetFromSourceEnd.instLevel := instLevelSource;
          sourceFromTargetEnd.visible := sourceVisibleFromTarget;
          targetFromSourceEnd.visible := targetVisibleFromSource;
          
          let
            a = assocType(fwName,sourceFromTargetEnd,targetFromSourceEnd)
          in
            target.addAttribute(sourceFromTargetEnd);
            source.addAttribute(targetFromSourceEnd);
            sourceFromTargetEnd.association := a;
            targetFromSourceEnd.association := a
          end;
          ("assoc: " + fwName).println();
          ("sourceLevel: " + sourceFromTargetEnd.instLevel.toString()).println();
          ("targetLevel: " + targetFromSourceEnd.instLevel.toString()).println();
          
          /*
          Now the slots must be set in the appropriate classes.
          To do so, the appropriate objects are selected, 
          and then the slots are added
          */
          
          @For obj in p.classes->select(o |
            o.isKindOf(FMMLx::FmmlxObject) andthen
            o.isDescendantOf(source) andthen 
            o.level.minLevel = targetFromSourceEnd.instLevel.minLevel) do
            (obj.name + "(" + obj.level.toString() + ") needs a slot ("+targetFromSourceEnd.name+") for new association").println();
            Kernel_addAtt(obj,targetFromSourceEnd.name,null)
          end;
          
          if sourceVisibleFromTarget then @For obj in p.classes->select(o | 
            o.isKindOf(FMMLx::FmmlxObject) andthen
            o.isDescendantOf(target) andthen 
            o.level.minLevel = sourceFromTargetEnd.instLevel.minLevel) do
            (obj.name + "(" + obj.level.toString() + ") needs a slot ("+sourceFromTargetEnd.name+") for new bidirectional association").println();
            Kernel_addAtt(obj,sourceFromTargetEnd.name,null)
          end end;
          
          /*let 
            a = Associations::Association(fwName,sourceFromTargetEnd,targetFromSourceEnd)
          in 
            p.associations := p.associations->including(a);
            a.owner := p;
            a.symmetric := isSymmetric;
            a.transitive := isTransitive;
            
            if sourceVisibleFromTarget then 
              self.addGettersAndSetters4Links(target, accessSourceFromTargetName, instLevelTarget, source, a, false, multTargetToSource)
            end;
            
            if targetVisibleFromSource then 
              self.addGettersAndSetters4Links(source, accessTargetFromSourceName, instLevelSource, target, a, true, multSourceToTarget)
            end;*/
            
            []
          //end
        end
      end
    end
    
    
  context FmmlxManipulator
    @Operation removeAssociation(association)
      let
        package = association.owner
      in
        // if an association exists, 
        // it can be removed as long as the 
        // association instances are removed first
        
        // remove instances
        self.removeAllAssociationInstances(association);
        
        // then remove itself
        package.associations := package.associations->excluding(association);
        association.owner := null; []
      end
    end
    
  context FmmlxManipulator
    @Operation changeAssociationForwardName(
      association : Association, 
      newName     : String) 
      let
        package = association.owner;
        nameChangeOk = true
      in
        if newName = null orelse "".equals(newName) then ["name not valid"] else
          @For a in package.associations do
            if newName.equals(a.name) then nameChangeOk := false end
          end;
          if nameChangeOk then 
            association.name := newName; []
          else
            ["the name already exists as an association name"]
          end
        end
      end
    end
    
  context FmmlxManipulator
    @Operation changeAssociationLevel(association, newEnd1Level, newEnd2Level)
      
      if     newEnd1Level <> null andthen newEnd1Level < 0 
        then ["source level too small"]
      elseif newEnd2Level <> null andthen newEnd2Level < 0 
        then ["target level too small"]
      elseif newEnd1Level <> null andthen newEnd1Level >= association.end1.type.level
        then ["source level too high"]
      elseif newEnd2Level <> null andthen newEnd2Level >= association.end2.type.level
        then ["target level too high"]
      elseif newEnd1Level <> null andthen newEnd1Level <> association.end1.instLevel 
             andthen [] <> self.checkAddAttribute(association.end2.type, association.end1.name, newEnd1Level, association.end1.type, null)
        then ["source level cannot be changed due to potential getter name collision"]
      elseif newEnd2Level <> null andthen newEnd2Level <> association.end2.instLevel 
             andthen [] <> self.checkAddAttribute(association.end1.type, association.end2.name, newEnd2Level, association.end2.type, null)
        then ["target level cannot be changed due to potential getter name collision"]
      else 
        ["All checks have passed but the change operation has not been implemented yet "]
      end
        
      // check new level
      // remove-add-assoc?
      // remove links
      
    end   
     
  context FmmlxManipulator
    @Operation changeAssociationAccessName(association, newEnd1Name, newEnd2Name)
      if
             (newEnd1Name <> null orelse newEnd1Name.toString() = association.end1.name)
             andthen self.checkAddAttribute(association.end2.type, newEnd1Name, association.end1.instLevel, association.end1.type, null).isEmpty()
      then
        ["source name duplicate"]
      elseif (newEnd2Name <> null orelse newEnd2Name.toString() = association.end2.name)
             andthen self.checkAddAttribute(association.end1.type, newEnd2Name, association.end2.instLevel, association.end2.type, null).isEmpty()
      then
        ["target name duplicate"]
      else
        ["All checks have passed but the change operation has not been implemented yet"]
      end
    end
    
  context FmmlxManipulator
    @Operation changeAssociationMultiplicity(association, newSourceMult, newTargetMult)
      let 
        package = association.owner;
        oldSourceMult = association.end1.mult();
        oldTargetMult = association.end2.mult();
        problems = [];
        oldSourceCount = null;
        oldTargetCount = null
      in
        newSourceMult := if newSourceMult = null then oldSourceMult else newSourceMult end;
        newTargetMult := if newTargetMult = null then oldTargetMult else newTargetMult end;
        
        oldSourceCount := self.countOccurencesForType(association.end1.type,association.end1.instLevel,package,association,true,false);
        oldTargetCount := self.countOccurencesForType(association.end2.type,association.end2.instLevel,package,association,false,true); 
        
        if newSourceMult.lowerBound > oldSourceMult.lowerBound then 
          if oldSourceCount.at(0) <> null andthen oldSourceCount.at(0) < newSourceMult.lowerBound then 
            problems := problems + ["Minimum multiplicity increase for source not possible. "] end end;
        
        if newTargetMult.lowerBound > oldTargetMult.lowerBound then 
          if oldTargetCount.at(0) <> null andthen oldTargetCount.at(0) < newTargetMult.lowerBound then 
            problems := problems + ["Minimum multiplicity increase for target not possible. "] end end;

        if newSourceMult.hasUpperBound andthen ((not oldSourceMult.hasUpperBound) orelse newSourceMult.upperBound < oldSourceMult.upperBound) then
          if oldSourceCount.at(1) <> null andthen oldSourceCount.at(1) > newSourceMult.upperBound then 
            problems := problems + ["Maximum multiplicity decrease for source not possible. "] end end;
        
        if newTargetMult.hasUpperBound andthen ((not oldTargetMult.hasUpperBound) orelse newTargetMult.upperBound < oldTargetMult.upperBound) then
          if oldTargetCount.at(1) <> null andthen oldTargetCount.at(1) > newTargetMult.upperBound then 
            problems := problems + ["Maximum multiplicity decrease for source not possible. "] end end;
            
        if problems.size() = 0 then 
          association.end1.mult := newSourceMult;
          association.end2.mult := newTargetMult
        end;
        
        problems
      end
    end
    
    // change assoc direction
    // change assoc name 4x
    // change assoc multi 2x
    // change assoc source/target 2x
    // remove assoc direction
    
    // ??? assoc refinement
    
    // add assoc value (new val1, new val2)
    // remove assoc value (old val1, old val2)
    // replace assoc value (old val1, old val2, new val1, new val2) -> use remove + add?
    
  context FmmlxManipulator
    @Operation setAssociationEndVisibility(
      assoc          : Association,
      concernsTarget : Boolean, 
      newVisibility  : Boolean)
      
      let 
        End       = if concernsTarget then assoc.end2 else assoc.end1 end;
        class     = if concernsTarget then assoc.end1 else assoc.end2 end.type
       then 
        type          = End.type;
        name          = End.name;
        instLevel     = End.instLevel;
        oldVisibility = End.visible;
        mult          = End.mult
      in
        End.visible := newVisibility;
        if newVisibility and not oldVisibility then 
          self.addGettersAndSetters4Links(class, name.toString(), instLevel, type, assoc, concernsTarget, mult) end;
        if oldVisibility and not newVisibility then 
          self.removeGettersAndSetters(class, name.toString(), instLevel, type) end;
        []
      end
    end
    
  context FmmlxManipulator
    @Operation assocNameIsUniqueInPackage(fwName, p)
      let result = true in 
        @For assoc in p.associations do
          result := result and (not (assoc.name.toString() = fwName.toString()))
        end;
        result
      end
    end
    
  context FmmlxManipulator
    @Operation addGettersAndSetters4Links(class, name, instLevel, type, assoc, selfIsSource, multiplicity) // actually, only one getter
      // selfIsSource => true  where self is on the source side
      // selfIsSource => false where self is on the target side
      
      /*
      If multiplicity max = 1 then add "getX", "setX" where all use a single Object
      If multiplicity max = 1 then add "getXs", "addX", "removeX", "replaceX?" where all use Set
      */
      
      let
        camelCaseName = name.subString(0,1).toUpper() + name.subString(1,name.size());
        max1 = multiplicity.hasUpperBound andthen multiplicity.upperBound < 2
      then
        get1Name = "get"+camelCaseName;
        set1Name = "set"+camelCaseName;
        getAllName = "get" + camelCaseName + "s";
        addAllName = "add" + camelCaseName + "s";
        remAllName = "remove" + camelCaseName + "s";        
        pName = assoc.owner.path()
      in
        if max1 then
          if multiplicity.lowerBound = 0 then 
            self.addOperation2(class, instLevel, 
            "  @Operation "+get1Name+"[getterKey=\""+name+"\"]():"+type.path()+"
"+          "    try            
"+          "      " + pName + ".getLinkEnds(self, \"" + assoc.name.toString() + "\","+(not selfIsSource)+","+selfIsSource+").asSeq().at(0)
"+          "    catch(ex)            
"+          "      null                  
"+          "    end            
"+          "  end") 
          else
            self.addOperation2(class, instLevel, 
            "  @Operation "+get1Name+"[getterKey=\""+name+"\"]():"+type.path()+"
"+          "    try            
"+          "      " + pName + ".getLinkEnds(self, \"" + assoc.name.toString() + "\","+(not selfIsSource)+","+selfIsSource+").asSeq().at(0)
"+          "    catch(ex)  
"+          "      throw(Exception(\"No link found in obligatory association.\"))               
"+          "    end            
"+          "  end") 
          end
/*;
		  self.addOperation2(class, instLevel, 
          "  @Operation "+set1Name+"[setterKey=\""+name+"\"](newLinkEnd:"+type.path()+"):Element  
"+        "    self.addAssociationInstance("+pName+", self, newLinkEnd, pName.getAssociation(assoc.name.toString()))
"+        "  end")*/
        else
          self.addOperation2(class, instLevel, 
          "  @Operation "+getAllName+"[getterKey=\""+name+"\"]():Set("+type.path()+")
"+        "    " + pName + ".getLinkEnds(self, \"" + assoc.name.toString() + "\","+(not selfIsSource)+","+selfIsSource+")
"+        "  end")/*;
          self.addOperation2(class, instLevel, 
          "  @Operation "+addAllName+"[setterKey=\""+name+"\"](newLinkEnds:Set("+type.path()+")):Element 
"+        "    @For newLinkEnd in newLinkEnds do self.addAssociationInstance("+pName+", self, newLinkEnd, pName.getAssociation(assoc.name.toString())) end
"+        "  end");
          self.addOperation2(class, instLevel, 
          "  @Operation "+remAllName+"[setterKey=\""+name+"\"](oldLinkEnds:Set("+type.path()+")):Element 
"+        "    @For oldLinkEnd in oldLinkEnds do " + pName + ".removeAssociationInstance(self, oldLinkEnd, pName.getAssociation(assoc.name.toString())) end
"+        "  end")*/
        end
      end
    end    