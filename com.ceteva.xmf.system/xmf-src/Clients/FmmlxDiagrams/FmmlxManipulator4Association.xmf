parserImport XOCL;

import Clients;
import FmmlxDiagrams;

  context FmmlxManipulator
   @Operation addAssociation(
     p: Package,
     source : MetaClass,
     target : MetaClass,
     accessSourceFromTargetName : String, // ref1
     accessTargetFromSourceName : String, // ref2
     fwName : String,
     reverseName : String,
     mult1 : XCore::Element,
     mult2 : XCore::Element,
     instLevel1 : XCore::Element,
     instLevel2 : XCore::Element,
     sourceVisibleFromTarget : Boolean, 
     targetVisibleFromSource : Boolean,
     isSymmetric : Boolean,
     isTransitive : Boolean):XCore::Element
	      
  	  if // 1 check if fwName is valid and unique in p
  	    not fwName.isValidName()
  	  then
  	    [fwName + " is not a valid identifier"]
  	  elseif 
  	    not self.assocNameIsUniqueInPackage(fwName, p)
  	  then 
  	    [fwName + " is not unique"]
  	    
  	  // IGNORE 2 check if reverseName is valid and unique in p (and obviously different from fwName)
  	  
  	  elseif // 3 check if accessSourceFromTargetName is valid and unique in Target ! (in Target!)
  	    [] <> self.checkAddAttribute(target, accessSourceFromTargetName, instLevel1, source) 
  	  then
  	    [accessSourceFromTargetName + " is not unique in " + target.name]
  	  
  	  elseif //  4 check if accessTargetFromSourceName is valid and unique in Source !
  	    [] <> self.checkAddAttribute(source, accessTargetFromSourceName, instLevel2, target) 
  	  then
  	    [accessTargetFromSourceName + " is not unique in " + source.name]
  	    
  	  //  5 check if one or more of mult1 and mult2 have a minimum of zero.
  	  //  5a check for circular mandatory multiplicity
  	  //  5b if one multiplicity > 0, demand default value // or leave inconsistent and demand subsequent repair.
  	  //  6 check instLevel plausibility  	  
  	      
  	  // can a class symmetrically self-associate?   
  	  
  	  else // all checks passed
        let 
          e1 = Associations::End(accessSourceFromTargetName,source,mult1);
          e2 = Associations::End(accessTargetFromSourceName,target,mult2)
        in 
          e1.instLevel := instLevel1;
          e2.instLevel := instLevel2;
          e1.visible := sourceVisibleFromTarget;
          e2.visible := targetVisibleFromSource;
          let 
            a = Associations::Association(fwName,e1,e2)
          in 
            p.associations := p.associations->including(a);
            a.owner := p;
            a.symmetric := isSymmetric;
            a.transitive := isTransitive;
            
            if sourceVisibleFromTarget then 
              self.addGettersAndSetters4Links(target, accessSourceFromTargetName, instLevel1, source, a)
            end;
            
            if targetVisibleFromSource then 
              self.addGettersAndSetters4Links(source, accessTargetFromSourceName, instLevel2, target, a)
            end;
            
            []
          end
        end
      end
    end
  context FmmlxManipulator
    @Operation removeAssociation(association)
      let
        package = association.owner
      in
        // if an association exists, 
        // it can be removed as long as the 
        // association instances are removed first
        
        // remove instances
        self.removeAllAssociationInstances(association);
        
        // then remove itself
        package.associations := package.associations->excluding(association);
        association.owner := null; []
      end
    end
    
  context FmmlxManipulator
    @Operation changeAssociationForwardName(
      association : Association, 
      newName     : String) 
      let
        package = association.owner;
        nameChangeOk = true
      in
        if newName = null orelse "".equals(newName) then ["name not valid"] else
          @For a in package.associations do
            if newName.equals(a.name) then nameChangeOk := false end
          end;
          if nameChangeOk then 
            association.name := newName; []
          else
            ["the name already exists as an association name"]
          end
        end
      end
    end
    
  context FmmlxManipulator
    @Operation changeAssociationMultiplicity(association, newSourceMult, newTargetMult)
      let 
        package = association.owner;
        oldSourceMult = association.end1.mult();
        oldTargetMult = association.end2.mult();
        problems = [];
        oldSourceCount = null;
        oldTargetCount = null
      in
        newSourceMult := if newSourceMult = null then oldSourceMult else newSourceMult end;
        newTargetMult := if newTargetMult = null then oldTargetMult else newTargetMult end;
        
        oldSourceCount := self.countOccurencesForType(association.end1.type,association.end1.instLevel,package,association);
        oldTargetCount := self.countOccurencesForType(association.end2.type,association.end2.instLevel,package,association); 
        
        if newSourceMult.lowerBound > oldSourceMult.lowerBound then 
          if oldSourceCount.at(0) <> null andthen oldSourceCount.at(0) < newSourceMult.lowerBound then 
            problems := problems + ["Minimum multiplicity increase for source not possible. "] end end;
        
        if newTargetMult.lowerBound > oldTargetMult.lowerBound then 
          if oldTargetCount.at(0) <> null andthen oldTargetCount.at(0) < newTargetMult.lowerBound then 
            problems := problems + ["Minimum multiplicity increase for target not possible. "] end end;

        if newSourceMult.hasUpperBound andthen ((not oldSourceMult.hasUpperBound) orelse newSourceMult.upperBound < oldSourceMult.upperBound) then
          if oldSourceCount.at(1) <> null andthen oldSourceCount.at(1) > newSourceMult.upperBound then 
            problems := problems + ["Maximum multiplicity decrease for source not possible. "] end end;
        
        if newTargetMult.hasUpperBound andthen ((not oldTargetMult.hasUpperBound) orelse newTargetMult.upperBound < oldTargetMult.upperBound) then
          if oldTargetCount.at(1) <> null andthen oldTargetCount.at(1) > newTargetMult.upperBound then 
            problems := problems + ["Maximum multiplicity decrease for source not possible. "] end end;
            
        if problems.size() = 0 then 
          association.end1.mult := newSourceMult;
          association.end2.mult := newTargetMult
        end;
        
        problems
      end
    end
    
    // change assoc direction
    // change assoc name 4x
    // change assoc multi 2x
    // change assoc source/target 2x
    // remove assoc direction
    
    // ??? assoc refinement
    
    // add assoc value (new val1, new val2)
    // remove assoc value (old val1, old val2)
    // replace assoc value (old val1, old val2, new val1, new val2) -> use remove + add?
    
  context FmmlxManipulator
    @Operation setAssociationEndVisibility(
      assoc          : Association,
      concernsTarget : Boolean, 
      newVisibility  : Boolean)
      
      let 
        End       = if concernsTarget then assoc.end2 else assoc.end1 end;
        class     = if concernsTarget then assoc.end1 else assoc.end2 end.type
       then 
        type          = End.type;
        name          = End.name;
        instLevel     = End.instLevel;
        oldVisibility = End.visible
      in
        End.visible := newVisibility;
        if newVisibility and not oldVisibility then 
          self.addGettersAndSetters4Links(class, name.toString(), instLevel, type, assoc) end;
        if oldVisibility and not newVisibility then 
          self.removeGettersAndSetters(class, name.toString(), instLevel, type) end;
        []
      end
    end
    
  context FmmlxManipulator
    @Operation assocNameIsUniqueInPackage(fwName, p)
      let result = true in 
        @For assoc in p.associations do
          result := result and (not (assoc.name.toString() = fwName.toString()))
        end;
        result
      end
    end
    
  context FmmlxManipulator
    @Operation addGettersAndSetters4Links(class, name, instLevel, type, assoc) // actually, only one getter
      let
        camelCaseName = name.subString(0,1).toUpper() + name.subString(1,name.size())
      then
        getterName = "get"+camelCaseName;
        setterName = "set"+camelCaseName;
        pName = assoc.owner.path()
      in
        self.addOperation2(class, instLevel, 
        "  @Operation "+getterName+"[getterKey=\""+name+"\"]():"+type.path()+"
"+      "    " + pName + ".getLinkEnds(self, \"" + assoc.name.toString() + "\")
//"+      "    throw(Exception(\"This operation has not been implemented yet.\"))
"+      "  end")
        

      end
    end    