parserImport XOCL;

context Root
  @Class Complex
    @Attribute real:Number end
    @Attribute imaginary:Number end
    
    @Operation toString() real + "+" + imaginary + "i" end
  end

context Root
@Class BikeSetup

  @Operation setup(p:Package) // Level 5 only

    // Level 5

    self.addClass(p, "Component", 5);
    self.addClass(p, "Configuration", 5);
    self.addClass(p, "Part", 5);
    self.addClass(p, "CompPart", 5);
    p::Part.addParent(p::Component);
    p::CompPart.addParent(p::Component);
    self.addAttribute(p::Component, "foo", Complex, 4);
    self.addAttribute(p::Component, "weight", Float, 1);
//    self.addAttribute(p::Configuration, "Name", String, 4);
    p::Configuration.addOperation(BikeSetup.getOperation("totalRevenues"));
    self.createAssociation(p,
  	p::Configuration, p::Part,
  	"role1","role2",
  	0, 1,
  	0, 1,
  	2);
    BikeSetup.getOperation("time").instLevel:=4;
    BikeSetup.getOperation("time").isIntrinsic:=true;
    p::Configuration.addOperation(BikeSetup.getOperation("time"))

  end

  @Operation setup4(p:Package)
    
    // Level 4
    self.addInstance(p, p::Configuration, "Bicycle");
    self.addAttribute(p::Bicycle, "allTerrain", Boolean, 3);
    self.addAttribute(p::Bicycle, "race", Boolean, 3);
    self.addAttribute(p::Bicycle, "city", Boolean, 3);
    self.addAttribute(p::Bicycle, "salesPrice", Float, 1);
    self.addAttribute(p::Bicycle, "weight", Float, 1);
    self.addAttribute(p::Bicycle, "partSalesPrice", Float, 0);
    self.addAttribute(p::Bicycle, "serialNo", String, 0);
    BikeSetup.getOperation("highestPrice").instLevel:=2;
    BikeSetup.getOperation("highestPrice").isIntrinsic:=true;
    p::Bicycle.addOperation(BikeSetup.getOperation("highestPrice"));
    BikeSetup.getOperation("averagePrice").instLevel:=2;
    BikeSetup.getOperation("averagePrice").isIntrinsic:=true;
    p::Bicycle.addOperation(BikeSetup.getOperation("averagePrice"));
    BikeSetup.getOperation("isBikeComplete").instLevel:=0;
    BikeSetup.getOperation("isBikeComplete").isIntrinsic:=true;
    p::Bicycle.addOperation(BikeSetup.getOperation("isBikeComplete"));
    
    
    self.addInstance(p, p::Part, "Fork");
    let c = Complex() in
      c.real := 1; 
      c.imaginary := 0.5;
      p::Fork.foo := c
    end;

    self.addAttribute(p::Fork, "color", String, 1);
    self.addAttribute(p::Fork, "suspension", String, 2);
    self.addAttribute(p::Fork, "material", String, 1);
    self.addAttribute(p::Fork, "serialNo", String, 0);
    self.addAttribute(p::Fork, "mudMount", Boolean, 0);
    
    self.addInstance(p, p::Part, "Frame");
    self.addAttribute(p::Frame, "allTerrain", Boolean, 3);
    self.addAttribute(p::Frame, "race", Boolean, 3);
    self.addAttribute(p::Frame, "color", String, 1);
    self.addAttribute(p::Frame, "width", Float, 1);
    self.addAttribute(p::Frame, "height", Float, 1);
    self.addAttribute(p::Frame, "serialNo", String, 0);
    self.addAttribute(p::Frame, "material", String, 2);
    self.addInstance(p, p::Part, "Wheel");
    
    self.addAttribute(p::Wheel, "safetyRefl", Boolean, 3);
    self.addAttribute(p::Wheel, "material", String, 1);
    self.addAttribute(p::Wheel, "size", Float, 1);
    self.addAttribute(p::Wheel, "width", Float, 1);
    self.addAttribute(p::Wheel, "tubeless", Boolean, 2);
    self.addAttribute(p::Wheel, "serialNo", String, 0)
    
  end
  
  @Operation setup3(p:Package)

    // Level 3
    self.addInstance(p, p::Bicycle, "RacingBike");
    self.addInstance(p, p::Fork, "RacingFork");
    self.addInstance(p, p::Frame, "RacingFrame");
    self.addInstance(p, p::Wheel, "RacingWheel")
    
  end
  
  @Operation setup2(p:Package)
  
    // Level 2
    self.addInstance(p, p::RacingBike, "ProRacer");
    self.addInstance(p, p::RacingFork, "LightFork");
    self.addInstance(p, p::RacingFrame, "ProRaceFrame");
    self.addInstance(p, p::RacingWheel, "ProRaceWheel")
    
  end
  
  @Operation setup1(p:Package)
  
    // Level 1
    self.addInstance(p, p::ProRacer, "ChallengerA2XL");
    self.addInstance(p, p::LightFork, "Superfork800");
    self.addInstance(p, p::ProRaceFrame, "RocketA1XL");
    self.addInstance(p, p::ProRaceWheel, "XForceDJ")

  end
  
  @Operation setup0(p:Package, index:String)
  
    // Level 0
    self.addInstance(p, p::ChallengerA2XL, "myBike_"+index);
    self.addInstance(p, p::Superfork800, "myFork_"+index);
    self.addInstance(p, p::RocketA1XL, "myFrame_"+index);
    self.addInstance(p, p::XForceDJ, "myWheel_"+index)

  end
  
  @Operation addNewClasses(p:Package)
    self.addInstance(p, p::LightFork, "mySuperLightFork")
  end
  
  @Operation addClass(p:Package, name:String, level:Integer)
	let c = FMML::MetaClass(name, level) in p.add(c); c end
  end 
  
  @Operation addInstance(p:Package, class:FMML::MetaClass, name:String)
	let c = class(name) in p.add(c); c end
  end 
  
  @Operation addAttribute(class:FMML::MetaClass, name:String, type:FMML::MetaClass, instLevel:Integer)
    let 
      a = Attribute(name)
//      allInst = self.allMetaInstances(class, instLevel);
//      allInstLevel = self.allMetaInstancesOneLevel(class, instLevel)
    in 
      a.isIntrinsic := true;
      a.type := type;
      a.instLevel := instLevel;
      
      class.addAttribute(a);
      a
    end
  end
  
  	@Operation createAssociation(
  	p: Package,
  	class1 : MetaClass,
  	class2 : MetaClass,
  	role1 : String,
  	role2 : String,
  	lower1 : Integer,
  	upper1 : Integer,
  	lower2 : Integer,
  	upper2 : Integer,
  	inst_lev : XCore::Element):XCore::Element
      let c1 = Multiplicities::CollectionMult(false,true,lower1,upper1);
          c2 = Multiplicities::CollectionMult(false,true,lower2,upper2)
      in let e1 = Associations::End(role1,class1,c1);
             e2 = Associations::End(role2,class2,c2)
         in 
            e1.instLevel := 1;
            e2.instLevel := 2;
            let a = Associations::Association("fwName",e1,e2)
            in a.println();p.println();p.addAssociation(a);a
            end
         end
      end
    end
   
  @Operation time[monitor=true]()
	xmf.date()
  end
  
  @Operation pi()
	3.141592654
  end
  
  @Operation totalRevenues[monitor=true]()
	self.allInstances().size() * 3.141592654
  end
  
  @Operation highestPrice[monitor=true]()
    if self.allInstances().size() = 0
    then "N/A"
    else
      let max = 0
      in
        @For x in self.allInstances() do
          if x.salesPrice>max then max := x.salesPrice end
        end;
        max
      end
    end
  end

  @Operation averagePrice[monitor=true]()
    if self.allInstances().size() = 0
    then "div/zero"
    else
      let sum = 0; count = 0
      in
        @For x in self.allInstances() do
          sum := sum + x.salesPrice;
          count := count + 1
        end;
        sum/count
      end
    end
  end
  
  @Operation isBikeComplete[monitor=true]()
    if self.frame = null then "a Frame is missing"
    elseif self.fork = null then "a Fork is missing"
    elseif self.wheel = null then "a Wheel is missing"
    else "complete"
    end
  end
  
  @Operation testCatch(x) // try testCatch(null) to provoke error
    let 
      problem = false;
      y = null
    in
      y := try
        1 / x
      catch(exception)
        "War wohl nichts"
      end;
      y
    end
  end

end

