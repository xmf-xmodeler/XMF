parserImport XOCL;

context Root

  @Package FMML metapackage XCore extends XCore
  end

context Root
  @Package Auxiliary end
  
context Root::Auxiliary
  @Class Complex
    @Attribute real:Number end
    @Attribute imaginary:Number end
    
    @Constructor(real,imaginary) end
        
    @Operation toString()  
      let 
        iText = 
          if     imaginary =  1 then  "i"
          elseif imaginary = -1 then "-i"
          else  (imaginary + "i") end
      in
        ""+
        if 
          imaginary = 0 
        then 
          real
        else
          if 
            real = 0
          then
            iText
          else
            real + if imaginary > 0 then "+" else "" end + iText
          end
        end
      end
    end
    
    @Operation magnitude() ((self.real*self.real)+(self.imaginary*self.imaginary)).sqrt() end
    @Operation argument() xmf.javaClass("java.lang.Math").atan2(self.imaginary+0.0,self.real+0.0) end
    
    @Operation add(other) Complex(self.real+other.real,self.imaginary+other.imaginary) end
    @Operation sub(other) Complex(self.real-other.real,self.imaginary-other.imaginary) end
    @Operation mul(other) Complex((self.real*other.real)-(self.imaginary*other.imaginary),(self.real*other.imaginary)+(other.real*self.imaginary)) end
    @Operation div(other) Complex(
        ((self.real*other.real)+(self.imaginary*other.imaginary))/((other.real*other.real)+(other.imaginary*other.imaginary)),
        ((self.real*other.imaginary)-(other.real*self.imaginary))/((other.real*other.real)+(other.imaginary*other.imaginary)))
    end
    
    @Operation createFromPolar(magnitude, argument) 
      Complex(magnitude * xmf.javaClass("java.lang.Math").cos(argument), magnitude * xmf.javaClass("java.lang.Math").sin(argument))
    end
    
    @Operation rotate(angle) 
      Complex::createFromPolar(self.magnitude(), self.argument() + angle)
    end
    
    @Operation exp(z:Complex)
      let 
        a = xmf.javaClass("java.lang.Math").exp(z.real) 
      in
      Complex(
        a * xmf.javaClass("java.lang.Math").cos(z.imaginary),
        a * xmf.javaClass("java.lang.Math").sin(z.imaginary)
        )
      end
    end
    
    @Operation pi() Complex(-1,0).argument() end
    
  end
  
context Root::Auxiliary
  @Class AuxiliaryClass isabstract
    @Attribute symbol:String end
    @Attribute abbreviation:String end
    @Attribute refValue:Float end
    
    @AbstractOp getAsString():String end
    @AbstractOp setAsString(s:String) end
  end
  
context Root::Auxiliary
  @Class Currency
    @Attribute symbol:String end
    @Attribute abbreviation:String end
    @Attribute refValue:Float end
    
    @Constructor(symbol, abbreviation, refValue) end
    
    @Operation update() self.refValue := if "EUR"=self.abbreviation then 1.0 else 1.0 / xmf.javaClass("tool.helper.CurrencyRates").getpriceOf1EUR(abbreviation) end end
  end

context Root::Auxiliary
  @Class MonetaryValue
    @Attribute amount:Float end
    @Attribute currency:Root::Auxiliary::Currency end
    
    @Constructor(amount, currency) end
    
    @Operation value():Float self.amount end
    @Operation getAsString():String self.amount + self.currency.symbol end
    @Operation toString():String self.getAsString() end
    @Operation valueIn(otherCurrency:Root::Auxiliary::Currency):Float self.amount * self.currency.refValue / otherCurrency.refValue end
    @Operation getAmount():Float self.amount end
    @Operation getCurrency():Float self.currency end
  end
  
context Root::Auxiliary
  @Class Date
    @Attribute date:ForeignObject end
  	
    @Constructor() 
      let 
        dateClass = xmf.javaClass("tool.helper.XDate")
      in 
        self.date := dateClass();
        self.date.setNow()
      end
    end
  	
    @Operation create(year, month, day, hour, minute, second)
      let
        d = Date()
      in
        d.date.setYearMonthDayHourMinuteSecond(year, month, day, hour, minute, second);
        d
      end
    end

    @Operation diff(other)
      self.date.getDifference(other.date)
    end

    @Operation toString()
      self.date.printDate("dd MMM yyyy HH:mm:ss")
    end
  end
  
  
  
  
Root::Auxiliary::euro := Root::Auxiliary::Currency("€", "EUR", 1.0);

Root::Auxiliary::dollar := Root::Auxiliary::Currency("$", "USD", 1.0);
Root::Auxiliary::dollar.update();
    
    