parserImport XOCL;

import Root::FMML;

context Root::FMML

  @Class MetaClass metaclass Root::Extensions::MetaAdaptor extends Root::Extensions::MetaAdaptor

    @Attribute metaClass : *MetaClass end

    @Attribute model : 1..1 Model end

	@Operation allAssociations():XCore::Element
      self.allEnds->collect(e |
        e.association)
    end
	
	@Operation allAttributesWithoutIntrinsic():XCore::Element
      let all = super();
          newAll = Set{}
      in @While not all.isEmpty() do
           let a = all.sel()
           in if not a.isIntrinsic
              then
                newAll := newAll.including(a)
              else
                false
              end;
              all := all.excluding(a)
           end
         end;
         newAll
      end
    end
	
	@Operation allEnds():XCore::Element
      self.allAttributes()->select(a |
        a.of() = Associations::End)
    end
	
	@Operation allInstances():XCore::Element
      Root.allContentsOf(self)
    end
	
	@Operation allMEMOAttributes():XCore::Element
      self.allAttributes()->select(a |
        a.isCore or (a.isIntrinsic and self.level = a.instLevel + 1)) + self.attributes->select(a |
        not a.isIntrinsic)
    end
	
	@Operation checkForNeededConstraints()
		let ends = Seq{};
			selectedEnd = null;
			otherEnd = null;
			classPool = Seq{};
			instancePool = Seq{};
			selectedClass = null;
			tmp = Seq{}
		in 
			@For att in self.attributes do
				if att.isKindOf(Associations::End) and att.isIntrinsic
				then
					ends := ends.including(att)
				end
			end;
			if not ends.isEmpty()
			then 
				if ends.size() > 1
				then
					tmp := Seq{};
					@For element in ends do
						tmp := tmp.including(Seq{element})	
	 				end;
					selectedEnd := xmf.treeSelection("Select End",Seq{"Ends","*",tmp},Seq{"Classes"},null)
				else 
					selectedEnd := ends.head()
				end;
				if selectedEnd <> null 
				then 
					if selectedEnd.association.end1 = selectedEnd
					then 
						otherEnd := selectedEnd.association.end2
					else
						otherEnd := selectedEnd.association.end1
					end;
					classPool := classPool.including(otherEnd.owner);
					@While not classPool.isEmpty() andthen classPool.head().level > otherEnd.instLevel + 1
					do
						@For c in classPool do
						  instancePool := instancePool + c.allInstances().asSeq()
						end;
						classPool := instancePool;
						instancePool := Seq{}
					end;
					if not classPool.isEmpty()
					then
						tmp := Seq{};
						@For element in classPool do
							tmp := tmp.including(Seq{element})	
		 				end;
						selectedClass := xmf.treeSelection("Select Target",Seq{"Classes","*",tmp},Seq{"Classes"},null);
						if selectedClass <> null and selectedClass <> "Classes"
						then 
							self.newIntrinsicAssociationConstraint(selectedEnd.name, selectedClass);
							if self.owner = null 
							then self.setOwner(selectedClass.owner)
							end;
							selectedClass.newIntrinsicAssociationConstraint(otherEnd.name, self);
							self.createIntrinsicAssociationEdge(self, selectedClass,selectedEnd.association )
						end
					else
						xmf.warning("There is no class which is a suited counterpart for the intrinsic association")
					end
				end
			end
		end
	end

	@Operation createAssociation(elem2 : MetaEntity,role1 : String,role2 : String,lower1 : Integer,upper1 : Integer,lower2 : Integer,upper2 : Integer,inst_lev : XCore::Element):XCore::Element
      let c1 = CollectionMult(false,true,lower1,upper1);
          c2 = CollectionMult(false,true,lower2,upper2)
      in let e1 = Associations::End(role1,self.of(),c1);
             e2 = Associations::End(role2,elem2.of(),c2)
         in let a = Associations::Association("regular","regularOther",e1,e2)
            in a.instLevel := inst_lev
            end
         end
      end
    end
    
    @Operation createIntrinsicAssociationEdge(source, target, association)
		let mapping = xmf.clientManager().findClientByName("com.ceteva.mappingMapping").mappingsFor(self.owner).head()
		in
      		@Find(sourceMap, mapping.classMaps)
		    when sourceMap.class = source do
    	  		@Find(targetMap, mapping.classMaps)
      			when targetMap.class = target do
					mapping.addIntrinsicAssociationEdge(sourceMap,targetMap, association)
      			end
      		end
		end      
    end
	
	@Operation getInstanceSlot(object : XCore::Element,name : XCore::Element):XCore::Element
      Kernel_setDefaultGetMOP(object.of(),true);
      Kernel_getSlotValue(object,name)
    end
	
	@Operation hasInstanceSlot(object : XCore::Element,name : XCore::Element):XCore::Element
      if not Kernel_hasSlot(object,name)
      then
        throw Exception(name + " is intrinsic and cannot be accessed on this level.")
      else
        true
      end
    end
	
//	@Constructor(name)
//		self.checkForNeededConstraints();
//		self
//    end

	@Operation isInstantiableAttOfName(name : String):XCore::Boolean
      if self.of() = FMML::MetaClass
      then
        true
      else
        let a = self.of().retrieveAttribute(name)
        in if a <> null
           then
             if a.isIntrinsic and a.instLevel < self.level
             then
               false
             else
               true
             end
           else
             false
           end
        end
      end
    end

	@Operation newIntrinsicAssociationConstraint(slotname, classifier):XCore::Element
      let name : XCore::Element = self.newName(slotname) then
      	  constraintString : XCore::Element = "@Constraint " + name + " self." + slotname + ".of() = " + classifier.path() + " fail \"Unspecified Reason\" end" then
          conAS : XCore::Element = OCL::OCL.grammar.parseString(constraintString,"Exp1",Seq{XOCL}) then
          conASfun : XCore::Element = Compiler::compileToFun("",conAS,Seq{},Seq{Seq{2 | Root.contents},Seq{2 | XCore.contents}},true) then
          constraint : XCore::Element = conASfun()
       in constraint.setName(name);
          self.add(constraint)
      end
    end

	@Operation retrieveAttribute(n : String):XCore::Attribute
      let attList = self.allAttributes()->select(a |
                      a.name = n.asSymbol())
      in if not attList.isEmpty()
         then
           attList.sel()
         else
           null
         end
      end
    end
	
	@Operation set(name : String,value : Element):Element
      if not self.isInstantiableAttOfName(name)
      then
        throw Exception(name + " is intrinsic and cannot be instantiated on this level.")
      else
        if self.of().of() = XCore::Class
        then
          Kernel_setSlotValue(self,name,value)
        else
          self.of().setInstanceSlot(self,name,value)
        end;
        self
      end
    end
  end
